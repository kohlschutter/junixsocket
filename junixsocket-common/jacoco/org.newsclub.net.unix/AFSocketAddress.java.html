<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AFSocketAddress.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">junixsocket-common</a> &gt; <a href="index.source.html" class="el_package">org.newsclub.net.unix</a> &gt; <span class="el_source">AFSocketAddress.java</span></div><h1>AFSocketAddress.java</h1><pre class="source lang-java linenums">/*
 * junixsocket
 *
 * Copyright 2009-2022 Christian Kohlschütter
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.newsclub.net.unix;

import java.io.File;
import java.io.FileDescriptor;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.net.DatagramSocket;
import java.net.InetAddress;
import java.net.InetSocketAddress;
import java.net.ServerSocket;
import java.net.SocketAddress;
import java.net.SocketException;
import java.net.URI;
import java.nio.ByteBuffer;
import java.util.HashMap;
import java.util.Locale;
import java.util.Map;
import java.util.Objects;

import org.eclipse.jdt.annotation.NonNull;
import org.eclipse.jdt.annotation.Nullable;

/**
 * Some {@link SocketAddress} that is supported by junixsocket, such as {@link AFUNIXSocketAddress}.
 * 
 * @author Christian Kohlschütter
 */
public abstract class AFSocketAddress extends InetSocketAddress {
  private static final long serialVersionUID = 1L;

  /**
   * Just a marker for &quot;don't actually bind&quot; (checked with &quot;==&quot;). Used in combination with a
   * superclass' bind method, which should trigger &quot;setBound()&quot;, etc.
   */
<span class="fc" id="L52">  static final AFSocketAddress INTERNAL_DUMMY_BIND = new SentinelSocketAddress(0);</span>
<span class="fc" id="L53">  static final AFSocketAddress INTERNAL_DUMMY_CONNECT = new SentinelSocketAddress(1);</span>
<span class="fc" id="L54">  static final AFSocketAddress INTERNAL_DUMMY_DONT_CONNECT = new SentinelSocketAddress(2);</span>

<span class="pc bpc" id="L56" title="1 of 2 branches missed.">  private static final int SOCKADDR_NATIVE_FAMILY_OFFSET = NativeUnixSocket.isLoaded() //</span>
<span class="pc" id="L57">      ? NativeUnixSocket.sockAddrNativeFamilyOffset() : -1;</span>

<span class="pc bpc" id="L59" title="1 of 2 branches missed.">  private static final int SOCKADDR_NATIVE_DATA_OFFSET = NativeUnixSocket.isLoaded() //</span>
<span class="pc" id="L60">      ? NativeUnixSocket.sockAddrNativeDataOffset() : -1;</span>

<span class="pc bpc" id="L62" title="1 of 2 branches missed.">  private static final int SOCKADDR_MAX_LEN = NativeUnixSocket.isLoaded() //</span>
<span class="pc" id="L63">      ? NativeUnixSocket.sockAddrLength(0) : 256;</span>

<span class="fc" id="L65">  private static final Map&lt;AFAddressFamily&lt;?&gt;, Map&lt;Integer, Map&lt;ByteBuffer, AFSocketAddress&gt;&gt;&gt; ADDRESS_CACHE =</span>
      new HashMap&lt;&gt;();

<span class="fc" id="L68">  static final ThreadLocal&lt;ByteBuffer&gt; SOCKETADDRESS_BUFFER_TL = new ThreadLocal&lt;ByteBuffer&gt;() {</span>

    @Override
    protected ByteBuffer initialValue() {
<span class="fc" id="L72">      return AFSocketAddress.newSockAddrDirectBuffer(SOCKADDR_MAX_LEN);</span>
    }
  };

  /**
   * Some byte-level representation of this address, which can only be converted to a native
   * representation in combination with the domain ID.
   */
  private final byte[] bytes;

  /**
   * An {@link InetAddress}-wrapped representation of this address. Only created upon demand.
   */
<span class="fc" id="L85">  private InetAddress inetAddress = null;</span>

  /**
   * The system-native representation of this address, or {@code null}.
   */
  private final ByteBuffer nativeAddress;

  /**
   * The address family.
   */
  private final AFAddressFamily&lt;?&gt; addressFamily;

  /**
   * Creates a new socket address.
   * 
   * @param port The port.
   * @param socketAddress The socket address in junixsocket-specific byte-array representation.
   * @param nativeAddress The socket address in system-native representation.
   * @param af The address family.
   * @throws SocketException on error.
   */
  protected AFSocketAddress(int port, final byte[] socketAddress, ByteBuffer nativeAddress,
      AFAddressFamily&lt;?&gt; af) throws SocketException {
    /*
     * Initializing the superclass with an unresolved hostname helps us pass the #equals and
     * #hashCode checks, which unfortunately are declared final in InetSocketAddress.
     * 
     * Using a resolved address (with the address bit initialized) would be ideal, but resolved
     * addresses can only be IPv4 or IPv6 (at least as of Java 16 and earlier).
     */
<span class="fc" id="L115">    super(AFInetAddress.createUnresolvedHostname(socketAddress, af), 0);</span>
<span class="fc bfc" id="L116" title="All 2 branches covered.">    this.nativeAddress = nativeAddress == null ? null : (ByteBuffer) nativeAddress.duplicate()</span>
<span class="fc" id="L117">        .rewind();</span>
<span class="fc bfc" id="L118" title="All 2 branches covered.">    if (port &lt; -1) {</span>
<span class="fc" id="L119">      throw new IllegalArgumentException(&quot;port out of range&quot;);</span>
    }
<span class="fc bfc" id="L121" title="All 2 branches covered.">    if (port &gt; 0) {</span>
<span class="pc bpc" id="L122" title="1 of 2 branches missed.">      if (!NativeUnixSocket.isLoaded()) {</span>
<span class="nc" id="L123">        throw (SocketException) new SocketException(</span>
<span class="nc" id="L124">            &quot;Cannot set SocketAddress port - junixsocket JNI library is not available&quot;).initCause(</span>
<span class="nc" id="L125">                NativeUnixSocket.unsupportedException());</span>
      }
<span class="fc" id="L127">      NativeUnixSocket.setPort1(this, port);</span>
    }
<span class="pc bpc" id="L129" title="1 of 2 branches missed.">    if (socketAddress.length == 0) {</span>
<span class="nc" id="L130">      throw new SocketException(&quot;Illegal address length: &quot; + socketAddress.length);</span>
    }

<span class="fc" id="L133">    this.bytes = socketAddress.clone();</span>
<span class="fc" id="L134">    this.addressFamily = af;</span>
<span class="fc" id="L135">  }</span>

  /**
   * Only for {@link SentinelSocketAddress}.
   * 
   * @param clazz The {@link SentinelSocketAddress} class.
   * @param port A sentinel port number.
   */
  @SuppressWarnings(&quot;PMD.UnusedFormalParameter&quot;)
  protected AFSocketAddress(Class&lt;SentinelSocketAddress&gt; clazz, int port) {
<span class="fc" id="L145">    super(InetAddress.getLoopbackAddress(), port);</span>
<span class="fc" id="L146">    this.nativeAddress = null;</span>
<span class="fc" id="L147">    this.bytes = new byte[0];</span>
<span class="fc" id="L148">    this.addressFamily = null;</span>
<span class="fc" id="L149">  }</span>

  /**
   * Checks if the address can be resolved to a {@link File}.
   * 
   * @return {@code true} if the address has a filename.
   */
  public abstract boolean hasFilename();

  /**
   * Returns the {@link File} corresponding with this address, if possible.
   * 
   * A {@link FileNotFoundException} is thrown if there is no filename associated with the address,
   * which applies to addresses in the abstract namespace, for example.
   * 
   * @return The filename.
   * @throws FileNotFoundException if the address is not associated with a filename.
   */
  public abstract File getFile() throws FileNotFoundException;

  /**
   * Returns the corresponding {@link AFAddressFamily}.
   * 
   * @return The address family instance.
   */
  public final AFAddressFamily&lt;?&gt; getAddressFamily() {
<span class="fc" id="L175">    return addressFamily;</span>
  }

  /**
   * Wraps the socket name/peer name of a file descriptor as an {@link InetAddress}.
   * 
   * @param fdesc The file descriptor.
   * @param peerName If {@code true}, the remote peer name (instead of the local name) is retrieved.
   * @param af The address family.
   * @return The {@link InetAddress}.
   */
  protected static final InetAddress getInetAddress(FileDescriptor fdesc, boolean peerName,
      AFAddressFamily&lt;?&gt; af) {
<span class="pc bpc" id="L188" title="1 of 2 branches missed.">    if (!fdesc.valid()) {</span>
<span class="nc" id="L189">      return null;</span>
    }
<span class="fc" id="L191">    byte[] addr = NativeUnixSocket.sockname(af.getDomain(), fdesc, peerName); // FIXME</span>
<span class="fc bfc" id="L192" title="All 2 branches covered.">    if (addr == null) {</span>
<span class="fc" id="L193">      return null;</span>
    }
<span class="fc" id="L195">    return AFInetAddress.wrapAddress(addr, af);</span>
  }

  /**
   * Gets the socket name/peer name of a file descriptor as an {@link AFSocketAddress}.
   * 
   * @param &lt;A&gt; The corresponding address type.
   * @param fdesc The file descriptor.
   * @param peerName If {@code true}, the remote peer name (instead of the local name) is retrieved.
   * @param port The port.
   * @param af The address family.
   * @return The {@link InetAddress}.
   */
  protected static final &lt;A extends AFSocketAddress&gt; @Nullable A getSocketAddress(
      FileDescriptor fdesc, boolean peerName, int port, AFAddressFamily&lt;A&gt; af) {
<span class="pc bpc" id="L210" title="1 of 2 branches missed.">    if (!fdesc.valid()) {</span>
<span class="nc" id="L211">      return null;</span>
    }
<span class="fc" id="L213">    byte[] addr = NativeUnixSocket.sockname(af.getDomain(), fdesc, peerName); // FIXME</span>
<span class="fc bfc" id="L214" title="All 2 branches covered.">    if (addr == null) {</span>
<span class="fc" id="L215">      return null;</span>
    }
    try {
      // FIXME we could infer the &quot;port&quot; from the path if the socket factory supports that
<span class="fc" id="L219">      return AFSocketAddress.unwrap(AFInetAddress.wrapAddress(addr, af), port, af);</span>
<span class="nc" id="L220">    } catch (SocketException e) {</span>
<span class="nc" id="L221">      throw new IllegalStateException(e);</span>
    }
  }

  static final AFSocketAddress preprocessSocketAddress(
      Class&lt;? extends AFSocketAddress&gt; supportedAddressClass, SocketAddress endpoint,
      AFSocketAddressFromHostname&lt;?&gt; afh) throws SocketException {
<span class="fc" id="L228">    Objects.requireNonNull(endpoint);</span>
<span class="fc bfc" id="L229" title="All 2 branches covered.">    if (endpoint instanceof SentinelSocketAddress) {</span>
<span class="fc" id="L230">      return (SentinelSocketAddress) endpoint;</span>
    }

<span class="fc bfc" id="L233" title="All 2 branches covered.">    if (!(endpoint instanceof AFSocketAddress)) {</span>
<span class="fc bfc" id="L234" title="All 2 branches covered.">      if (afh != null) {</span>
<span class="pc bpc" id="L235" title="1 of 2 branches missed.">        if (endpoint instanceof InetSocketAddress) {</span>
<span class="fc" id="L236">          InetSocketAddress isa = (InetSocketAddress) endpoint;</span>

<span class="fc" id="L238">          String hostname = isa.getHostString();</span>
<span class="fc bfc" id="L239" title="All 2 branches covered.">          if (afh.isHostnameSupported(hostname)) {</span>
            try {
<span class="fc" id="L241">              endpoint = afh.addressFromHost(hostname, isa.getPort());</span>
<span class="fc" id="L242">            } catch (SocketException e) {</span>
<span class="fc" id="L243">              throw e;</span>
<span class="fc" id="L244">            }</span>
          }
        }
      }
    }

<span class="fc" id="L250">    Objects.requireNonNull(endpoint);</span>

<span class="fc bfc" id="L252" title="All 2 branches covered.">    if (!supportedAddressClass.isAssignableFrom(endpoint.getClass())) {</span>
<span class="fc" id="L253">      throw new IllegalArgumentException(&quot;Can only connect to endpoints of type &quot;</span>
<span class="fc" id="L254">          + supportedAddressClass.getName() + &quot;, got: &quot; + endpoint.getClass() + &quot;: &quot; + endpoint);</span>
    }

<span class="fc" id="L257">    return (AFSocketAddress) endpoint;</span>
  }

  /**
   * Returns the (non-native) byte-level representation of this address.
   * 
   * @return The byte array.
   */
  protected final byte[] getBytes() {
<span class="fc" id="L266">    return bytes; // NOPMD</span>
  }

  /**
   * Returns a &quot;special&quot; {@link InetAddress} that contains information about this
   * {@link AFSocketAddress}.
   * 
   * IMPORTANT: This {@link InetAddress} does not properly compare (using
   * {@link InetAddress#equals(Object)} and {@link InetAddress#hashCode()}). It should be used
   * exclusively to circumvent existing APIs like {@link DatagramSocket} that only accept/return
   * {@link InetAddress} and not arbitrary {@link SocketAddress} types.
   * 
   * @return The &quot;special&quot; {@link InetAddress}.
   */
  public final InetAddress wrapAddress() {
<span class="fc" id="L281">    return AFInetAddress.wrapAddress(bytes, getAddressFamily());</span>
  }

  /**
   * A reference to the constructor of an AFSocketAddress subclass.
   * 
   * @param &lt;T&gt; The actual subclass.
   * @author Christian Kohlschütter
   */
  @FunctionalInterface
  protected interface AFSocketAddressConstructor&lt;T extends AFSocketAddress&gt; {
    /**
     * Constructs a new AFSocketAddress instance.
     * 
     * @param port The port.
     * @param socketAddress The socket address in junixsocket-specific byte-array representation.
     * @param nativeAddress The socket address in system-native representation.
     * @return The instance.
     * @throws SocketException on error.
     */
    @NonNull
    T newAFSocketAddress(int port, byte[] socketAddress, ByteBuffer nativeAddress)
        throws SocketException;
  }

  /**
   * Resolves a junixsocket-specific byte-array representation of an {@link AFSocketAddress} to an
   * actual {@link AFSocketAddress} instance, possibly reusing a cached instance.
   * 
   * @param &lt;A&gt; The concrete {@link AFSocketAddress} that is supported by this type.
   * @param socketAddress The socket address in junixsocket-specific byte-array representation.
   * @param port The port.
   * @param af The address family.
   * @return The instance.
   * @throws SocketException on error.
   */
  @SuppressWarnings({&quot;unchecked&quot;, &quot;null&quot;})
  protected static final &lt;A extends AFSocketAddress&gt; A resolveAddress(final byte[] socketAddress,
      int port, AFAddressFamily&lt;A&gt; af) throws SocketException {
    A instance;

<span class="fc bfc" id="L322" title="All 2 branches covered.">    if (socketAddress.length == 0) {</span>
<span class="fc" id="L323">      throw new SocketException(&quot;Address cannot be empty&quot;);</span>
    }

<span class="fc bfc" id="L326" title="All 2 branches covered.">    if (port == -1) {</span>
<span class="fc" id="L327">      port = 0;</span>
    }

<span class="fc" id="L330">    ByteBuffer direct = SOCKETADDRESS_BUFFER_TL.get();</span>
<span class="pc bpc" id="L331" title="1 of 2 branches missed.">    int limit = NativeUnixSocket.isLoaded() ? NativeUnixSocket.bytesToSockAddr(af.getDomain(),</span>
<span class="pc" id="L332">        direct, socketAddress) : -1;</span>
<span class="fc bfc" id="L333" title="All 2 branches covered.">    if (limit == -1) {</span>
      // not supported, but we can still create an address
<span class="fc" id="L335">      return af.getAddressConstructor().newAFSocketAddress(port, socketAddress, null);</span>
<span class="pc bpc" id="L336" title="1 of 2 branches missed.">    } else if (limit &gt; SOCKADDR_MAX_LEN) {</span>
<span class="nc" id="L337">      throw new IllegalStateException(&quot;Unexpected address length&quot;);</span>
    }
<span class="fc" id="L339">    direct.rewind();</span>
<span class="fc" id="L340">    direct.limit(limit);</span>

<span class="fc" id="L342">    synchronized (AFSocketAddress.class) {</span>
      Map&lt;ByteBuffer, AFSocketAddress&gt; map;
<span class="fc" id="L344">      Map&lt;Integer, Map&lt;ByteBuffer, AFSocketAddress&gt;&gt; mapPorts = ADDRESS_CACHE.get(af);</span>
<span class="fc bfc" id="L345" title="All 2 branches covered.">      if (mapPorts == null) {</span>
<span class="fc" id="L346">        instance = null;</span>
<span class="fc" id="L347">        mapPorts = new HashMap&lt;&gt;();</span>
<span class="fc" id="L348">        map = new HashMap&lt;&gt;();</span>
<span class="fc" id="L349">        mapPorts.put(port, map);</span>
<span class="fc" id="L350">        ADDRESS_CACHE.put(af, mapPorts);</span>
      } else {
<span class="fc" id="L352">        map = mapPorts.get(port);</span>
<span class="fc bfc" id="L353" title="All 2 branches covered.">        if (map == null) {</span>
<span class="fc" id="L354">          instance = null;</span>
<span class="fc" id="L355">          map = new HashMap&lt;&gt;();</span>
<span class="fc" id="L356">          mapPorts.put(port, map);</span>
        } else {
<span class="fc" id="L358">          instance = (A) map.get(direct);</span>
        }
      }

<span class="pc bpc" id="L362" title="1 of 2 branches missed.">      if (instance == null) {</span>
<span class="fc" id="L363">        ByteBuffer key = newSockAddrKeyBuffer(limit);</span>
<span class="fc" id="L364">        key.put(direct);</span>
<span class="fc" id="L365">        key = key.asReadOnlyBuffer();</span>

<span class="fc" id="L367">        instance = af.getAddressConstructor().newAFSocketAddress(port, socketAddress, key);</span>

<span class="fc" id="L369">        map.put(key, instance);</span>
      }
<span class="fc" id="L371">    }</span>

<span class="fc" id="L373">    return instance;</span>
  }

  @SuppressWarnings(&quot;null&quot;)
  static final &lt;A extends AFSocketAddress&gt; A ofInternal(ByteBuffer socketAddressBuffer,
      AFAddressFamily&lt;A&gt; af) throws SocketException {
<span class="fc" id="L379">    synchronized (AFSocketAddress.class) {</span>
<span class="fc" id="L380">      Map&lt;Integer, Map&lt;ByteBuffer, AFSocketAddress&gt;&gt; mapPorts = ADDRESS_CACHE.get(af);</span>
<span class="pc bpc" id="L381" title="1 of 2 branches missed.">      if (mapPorts != null) {</span>
<span class="fc" id="L382">        Map&lt;ByteBuffer, AFSocketAddress&gt; map = mapPorts.get(0); // FIXME get port, something like</span>
                                                                // sockAddrToPort
<span class="pc bpc" id="L384" title="1 of 2 branches missed.">        if (map != null) {</span>
          @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L386">          A address = (A) map.get(socketAddressBuffer.rewind());</span>
<span class="pc bpc" id="L387" title="1 of 2 branches missed.">          if (address != null) {</span>
<span class="nc" id="L388">            return address;</span>
          }
        }
      }

<span class="pc bpc" id="L393" title="1 of 2 branches missed.">      if (!socketAddressBuffer.isDirect()) {</span>
<span class="nc" id="L394">        ByteBuffer buf = getNativeAddressDirectBuffer(Math.min(socketAddressBuffer.limit(),</span>
            SOCKADDR_MAX_LEN));
<span class="nc" id="L396">        buf.put(socketAddressBuffer);</span>
<span class="nc" id="L397">        socketAddressBuffer = buf;</span>
      }
<span class="fc" id="L399">      byte[] sockAddrToBytes = NativeUnixSocket.sockAddrToBytes(af.getDomain(),</span>
          socketAddressBuffer);
<span class="pc bpc" id="L401" title="1 of 2 branches missed.">      if (sockAddrToBytes == null) {</span>
<span class="nc" id="L402">        return null;</span>
      } else {
<span class="fc" id="L404">        return AFSocketAddress.resolveAddress(sockAddrToBytes, 0, af);</span>
      }
    }
  }

  /**
   * Wraps an address as an {@link InetAddress}.
   * 
   * @param af The address family.
   * @return The {@link InetAddress}.
   */
  protected final synchronized InetAddress getInetAddress(AFAddressFamily&lt;?&gt; af) {
<span class="pc bpc" id="L416" title="1 of 2 branches missed.">    if (inetAddress == null) {</span>
<span class="fc" id="L417">      inetAddress = AFInetAddress.wrapAddress(bytes, af);</span>
    }
<span class="fc" id="L419">    return inetAddress;</span>
  }

  /**
   * Wraps this address as an {@link InetAddress}.
   * 
   * @return The {@link InetAddress}.
   */
  protected final InetAddress getInetAddress() {
<span class="fc" id="L428">    return getInetAddress(getAddressFamily());</span>
  }

  static final ByteBuffer newSockAddrDirectBuffer(int length) {
<span class="fc" id="L432">    return ByteBuffer.allocateDirect(length);</span>
  }

  static final ByteBuffer newSockAddrKeyBuffer(int length) {
<span class="fc" id="L436">    return ByteBuffer.allocate(length);</span>
  }

  /**
   * Returns an {@link AFSocketAddress} given a special {@link InetAddress} that encodes the byte
   * sequence of an AF_UNIX etc. socket address, like those returned by {@link #wrapAddress()}.
   * 
   * @param &lt;A&gt; The corresponding address type.
   * @param address The &quot;special&quot; {@link InetAddress}.
   * @param port The port (use 0 for &quot;none&quot;).
   * @param af The address family.
   * @return The {@link AFSocketAddress} instance.
   * @throws SocketException if the operation fails, for example when an unsupported address is
   *           specified.
   */
  @SuppressWarnings(&quot;null&quot;)
  @NonNull
  protected static final &lt;A extends AFSocketAddress&gt; A unwrap(InetAddress address, int port,
      AFAddressFamily&lt;A&gt; af) throws SocketException {
<span class="fc" id="L455">    Objects.requireNonNull(address);</span>
<span class="fc" id="L456">    return resolveAddress(AFInetAddress.unwrapAddress(address, af), port, af);</span>
  }

  /**
   * Returns an {@link AFSocketAddress} given a special {@link InetAddress} hostname that encodes
   * the byte sequence of an AF_UNIX etc. socket address, like those returned by
   * {@link #wrapAddress()}.
   * 
   * @param &lt;A&gt; The corresponding address type.
   * @param hostname The &quot;special&quot; hostname, as provided by {@link InetAddress#getHostName()}.
   * @param port The port (use 0 for &quot;none&quot;).
   * @param af The address family.
   * @return The {@link AFSocketAddress} instance.
   * @throws SocketException if the operation fails, for example when an unsupported address is
   *           specified.
   */
  @SuppressWarnings(&quot;null&quot;)
  @NonNull
  protected static final &lt;A extends AFSocketAddress&gt; A unwrap(String hostname, int port,
      AFAddressFamily&lt;A&gt; af) throws SocketException {
<span class="nc" id="L476">    Objects.requireNonNull(hostname);</span>
<span class="nc" id="L477">    return resolveAddress(AFInetAddress.unwrapAddress(hostname, af), port, af);</span>
  }

  static final int unwrapAddressDirectBufferInternal(ByteBuffer socketAddressBuffer,
      SocketAddress address) throws SocketException {
<span class="nc" id="L482">    Objects.requireNonNull(address);</span>
    // FIXME: add support for UnixDomainSocketAddress
<span class="nc bnc" id="L484" title="All 2 branches missed.">    if (!(address instanceof AFSocketAddress)) {</span>
<span class="nc" id="L485">      throw new SocketException(&quot;Unsupported address&quot;);</span>
    }

<span class="nc" id="L488">    byte[] addr = ((AFSocketAddress) address).getBytes();</span>
<span class="nc" id="L489">    int domain = ((AFSocketAddress) address).getAddressFamily().getDomain();</span>
<span class="nc bnc" id="L490" title="All 2 branches missed.">    int len = NativeUnixSocket.isLoaded() ? NativeUnixSocket.bytesToSockAddr(domain,</span>
<span class="nc" id="L491">        socketAddressBuffer, addr) : -1;</span>
<span class="nc bnc" id="L492" title="All 2 branches missed.">    if (len == -1) {</span>
<span class="nc" id="L493">      throw new SocketException(&quot;Unsupported domain&quot;);</span>
    }
<span class="nc" id="L495">    return len;</span>
  }

  /**
   * Returns a thread-local direct ByteBuffer containing the native socket address representation of
   * this {@link AFSocketAddress}.
   * 
   * @return The direct {@link ByteBuffer}.
   */
  final ByteBuffer getNativeAddressDirectBuffer() {
<span class="fc" id="L505">    ByteBuffer direct = getNativeAddressDirectBuffer(nativeAddress.limit());</span>
<span class="fc" id="L506">    nativeAddress.position(0);</span>
<span class="fc" id="L507">    direct.put(nativeAddress);</span>

<span class="fc" id="L509">    return direct;</span>
  }

  static final ByteBuffer getNativeAddressDirectBuffer(int limit) {
<span class="fc" id="L513">    ByteBuffer direct = SOCKETADDRESS_BUFFER_TL.get();</span>
<span class="fc" id="L514">    direct.position(0);</span>
<span class="fc" id="L515">    direct.limit(limit);</span>
<span class="fc" id="L516">    return direct;</span>
  }

  /**
   * Checks if the given address is supported by this address family.
   * 
   * @param addr The address.
   * @param af The address family.
   * @return {@code true} if supported.
   */
  protected static final boolean isSupportedAddress(InetAddress addr, AFAddressFamily&lt;?&gt; af) {
<span class="nc" id="L527">    return AFInetAddress.isSupportedAddress(addr, af);</span>
  }

  /**
   * Writes the native (system-level) representation of this address to the given buffer.
   * 
   * The position of the target buffer will be at the end (i.e., after) the written data.
   * 
   * @param buf The target buffer.
   * @throws IOException on error.
   */
  public final void writeNativeAddressTo(ByteBuffer buf) throws IOException {
<span class="nc bnc" id="L539" title="All 2 branches missed.">    if (nativeAddress == null) {</span>
<span class="nc" id="L540">      throw new IOException(&quot;Cannot access native address&quot;);</span>
    }
<span class="nc" id="L542">    buf.put(nativeAddress);</span>
<span class="nc" id="L543">  }</span>

  /**
   * Creates a new socket connected to this address.
   * 
   * @return The socket instance.
   * @throws IOException on error.
   */
  public AFSocket&lt;?&gt; newConnectedSocket() throws IOException {
<span class="nc" id="L552">    AFSocket&lt;?&gt; socket = getAddressFamily().newSocket();</span>
<span class="nc" id="L553">    socket.connect(this);</span>
<span class="nc" id="L554">    return socket;</span>
  }

  /**
   * Creates a new server socket bound to this address.
   * 
   * @return The server socket instance.
   * @throws IOException on error.
   */
  public AFServerSocket&lt;?&gt; newBoundServerSocket() throws IOException {
<span class="nc" id="L564">    AFServerSocket&lt;?&gt; serverSocket = getAddressFamily().newServerSocket();</span>
<span class="nc" id="L565">    serverSocket.bind(this);</span>
<span class="nc" id="L566">    return serverSocket;</span>
  }

  /**
   * Creates a new server socket force-bound to this address (i.e., any additional call to
   * {@link ServerSocket#bind(SocketAddress)} will ignore the passed address and use this one
   * instead.
   * 
   * @return The server socket instance.
   * @throws IOException on error.
   */
  public AFServerSocket&lt;?&gt; newForceBoundServerSocket() throws IOException {
<span class="nc" id="L578">    AFServerSocket&lt;?&gt; serverSocket = getAddressFamily().newServerSocket();</span>
<span class="nc" id="L579">    serverSocket.forceBindAddress(this).bind(this);</span>
<span class="nc" id="L580">    return serverSocket;</span>
  }

  /**
   * Tries to parse the given URI and return a corresponding {@link AFSocketAddress} for it.
   * 
   * NOTE: Only certain URI schemes are supported, such as {@code unix://} (for
   * {@link AFUNIXSocketAddress}) and {@code tipc://} for {@link AFTIPCSocketAddress}.
   * 
   * @param u The URI.
   * @return The address.
   * @throws SocketException on error.
   * @see AFAddressFamily#uriSchemes()
   */
  @SuppressWarnings(&quot;PMD.ShortMethodName&quot;)
  public static AFSocketAddress of(URI u) throws SocketException {
<span class="fc" id="L596">    return of(u, -1);</span>
  }

  /**
   * Tries to parse the given URI and return a corresponding {@link AFSocketAddress} for it.
   * 
   * NOTE: Only certain URI schemes are supported, such as {@code unix://} (for
   * {@link AFUNIXSocketAddress}) and {@code tipc://} for {@link AFTIPCSocketAddress}.
   * 
   * @param u The URI.
   * @param overridePort The port to forcibly use, or {@code -1} for &quot;don't override&quot;.
   * @return The address.
   * @throws SocketException on error.
   * @see AFAddressFamily#uriSchemes()
   */
  @SuppressWarnings(&quot;PMD.ShortMethodName&quot;)
  public static AFSocketAddress of(URI u, int overridePort) throws SocketException {
<span class="fc" id="L613">    AFAddressFamily&lt;?&gt; af = AFAddressFamily.getAddressFamily(u);</span>
<span class="pc bpc" id="L614" title="1 of 2 branches missed.">    if (af == null) {</span>
<span class="nc" id="L615">      throw new SocketException(&quot;Cannot resolve AFSocketAddress from URI scheme: &quot; + u.getScheme());</span>
    }
<span class="fc" id="L617">    return af.parseURI(u, overridePort);</span>
  }

  /**
   * Tries to create a URI based on this {@link AFSocketAddress}.
   * 
   * @param scheme The target scheme.
   * @param template An optional template to reuse certain parameters (e.g., the &quot;path&quot; component
   *          for an {@code http} request), or {@code null}.
   * @return The URI.
   * @throws IOException on error.
   */
  public URI toURI(String scheme, URI template) throws IOException {
<span class="nc" id="L630">    throw new IOException(&quot;Unsupported operation&quot;);</span>
  }

  /**
   * Returns a address string that can be used with {@code socat}'s {@code SOCKET-CONNECT},
   * {@code SOCKET-LISTEN}, {@code SOCKET-DATAGRAM}, etc., address types, or {@code null} if the
   * address type is not natively supported by this platform.
   * 
   * This call is mostly suited for debugging purposes. The resulting string is specific to the
   * platform the code is executed on, and thus may be different among platforms (or {@code null}).
   * 
   * @param socketType The socket type, or {@code null} to omit from string.
   * @param socketProtocol The socket protocol, or {@code null} to omit from string.
   * @return The string (such as 1:0:x2f746d702f796f), or {@code null} if unable to retrieve.
   * @throws IOException on error.
   */
  public @Nullable @SuppressWarnings(&quot;PMD.NPathComplexity&quot;) String toSocatAddressString(
      AFSocketType socketType, AFSocketProtocol socketProtocol) throws IOException {

<span class="pc bpc" id="L649" title="2 of 4 branches missed.">    if (SOCKADDR_NATIVE_FAMILY_OFFSET == -1 || SOCKADDR_NATIVE_DATA_OFFSET == -1) {</span>
<span class="nc" id="L650">      return null;</span>
    }
<span class="fc bfc" id="L652" title="All 2 branches covered.">    if (nativeAddress == null) {</span>
<span class="fc" id="L653">      return null;</span>
    }
<span class="pc bpc" id="L655" title="2 of 4 branches missed.">    if (socketProtocol != null &amp;&amp; socketProtocol.getId() != 0) {</span>
<span class="nc" id="L656">      throw new IOException(&quot;Protocol not (yet) supported&quot;); // FIXME</span>
    }

<span class="fc" id="L659">    int family = (nativeAddress.get(SOCKADDR_NATIVE_FAMILY_OFFSET) &amp; 0xFF);</span>
<span class="fc bfc" id="L660" title="All 2 branches covered.">    int type = socketType == null ? -1 : NativeUnixSocket.sockTypeToNative(socketType.getId());</span>
<span class="fc" id="L661">    StringBuilder sb = new StringBuilder();</span>
<span class="fc" id="L662">    sb.append(family);</span>
<span class="fc bfc" id="L663" title="All 2 branches covered.">    if (type != -1) {</span>
<span class="fc" id="L664">      sb.append(':');</span>
<span class="fc" id="L665">      sb.append(type);</span>
    }
<span class="pc bpc" id="L667" title="1 of 2 branches missed.">    if (socketProtocol != null) {</span>
<span class="fc" id="L668">      sb.append(':');</span>
<span class="fc" id="L669">      sb.append(socketProtocol.getId()); // FIXME needs native conversion</span>
    }
<span class="fc" id="L671">    sb.append(&quot;:x&quot;);</span>
<span class="fc" id="L672">    int n = nativeAddress.limit();</span>
<span class="pc bpc" id="L673" title="1 of 4 branches missed.">    while (n &gt; 1 &amp;&amp; nativeAddress.get(n - 1) == 0) {</span>
<span class="fc" id="L674">      n--;</span>
    }
<span class="fc bfc" id="L676" title="All 2 branches covered.">    for (int pos = SOCKADDR_NATIVE_DATA_OFFSET; pos &lt; n; pos++) {</span>
<span class="fc" id="L677">      byte b = nativeAddress.get(pos);</span>
<span class="fc" id="L678">      sb.append(String.format(Locale.ENGLISH, &quot;%02x&quot;, b));</span>
    }
<span class="fc" id="L680">    return sb.toString();</span>
  }

  /**
   * Checks if the given address could cover another address.
   * 
   * By default, this is only true if both addresses are regarded equal using
   * {@link #equals(Object)}.
   * 
   * However, implementations may support &quot;wildcard&quot; addresses, and this method would compare a
   * wildcard address against some non-wildcard address, for example.
   * 
   * @param other The other address that could be covered by this address.
   * @return {@code true} if the other address could be covered.
   */
  public boolean covers(AFSocketAddress other) {
<span class="nc" id="L696">    return this.equals(other);</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>