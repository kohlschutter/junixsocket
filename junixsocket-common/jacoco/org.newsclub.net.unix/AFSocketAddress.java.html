<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AFSocketAddress.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">junixsocket-common</a> &gt; <a href="index.source.html" class="el_package">org.newsclub.net.unix</a> &gt; <span class="el_source">AFSocketAddress.java</span></div><h1>AFSocketAddress.java</h1><pre class="source lang-java linenums">/*
 * junixsocket
 *
 * Copyright 2009-2023 Christian Kohlschütter
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.newsclub.net.unix;

import java.io.ByteArrayInputStream;
import java.io.File;
import java.io.FileDescriptor;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.net.DatagramSocket;
import java.net.InetAddress;
import java.net.InetSocketAddress;
import java.net.ServerSocket;
import java.net.SocketAddress;
import java.net.SocketException;
import java.net.URI;
import java.nio.ByteBuffer;
import java.nio.charset.StandardCharsets;
import java.util.HashMap;
import java.util.Locale;
import java.util.Map;
import java.util.Objects;

import org.eclipse.jdt.annotation.NonNull;
import org.eclipse.jdt.annotation.Nullable;

import com.google.errorprone.annotations.Immutable;
import com.kohlschutter.annotations.compiletime.SuppressFBWarnings;

/**
 * Some {@link SocketAddress} that is supported by junixsocket, such as {@link AFUNIXSocketAddress}.
 *
 * @author Christian Kohlschütter
 */
@Immutable
@SuppressWarnings({&quot;PMD.CouplingBetweenObjects&quot;, &quot;PMD.CyclomaticComplexity&quot;})
public abstract class AFSocketAddress extends InetSocketAddress {
  private static final long serialVersionUID = 1L; // do not change!

  /**
   * Just a marker for &quot;don't actually bind&quot; (checked with &quot;==&quot;). Used in combination with a
   * superclass' bind method, which should trigger &quot;setBound()&quot;, etc.
   */
<span class="fc" id="L61">  static final AFSocketAddress INTERNAL_DUMMY_BIND = new SentinelSocketAddress(0);</span>
<span class="fc" id="L62">  static final AFSocketAddress INTERNAL_DUMMY_CONNECT = new SentinelSocketAddress(1);</span>
<span class="fc" id="L63">  static final AFSocketAddress INTERNAL_DUMMY_DONT_CONNECT = new SentinelSocketAddress(2);</span>

<span class="pc bpc" id="L65" title="1 of 2 branches missed.">  private static final int SOCKADDR_NATIVE_FAMILY_OFFSET = NativeUnixSocket.isLoaded() //</span>
<span class="pc" id="L66">      ? NativeUnixSocket.sockAddrNativeFamilyOffset() : -1;</span>

<span class="pc bpc" id="L68" title="1 of 2 branches missed.">  private static final int SOCKADDR_NATIVE_DATA_OFFSET = NativeUnixSocket.isLoaded() //</span>
<span class="pc" id="L69">      ? NativeUnixSocket.sockAddrNativeDataOffset() : -1;</span>

<span class="pc bpc" id="L71" title="1 of 2 branches missed.">  private static final int SOCKADDR_MAX_LEN = NativeUnixSocket.isLoaded() //</span>
<span class="pc" id="L72">      ? NativeUnixSocket.sockAddrLength(0) : 256;</span>

<span class="fc" id="L74">  private static final Map&lt;AFAddressFamily&lt;?&gt;, Map&lt;Integer, Map&lt;ByteBuffer, AFSocketAddress&gt;&gt;&gt; ADDRESS_CACHE =</span>
      new HashMap&lt;&gt;();

<span class="fc" id="L77">  static final ThreadLocal&lt;ByteBuffer&gt; SOCKETADDRESS_BUFFER_TL = new ThreadLocal&lt;ByteBuffer&gt;() {</span>

    @Override
    protected ByteBuffer initialValue() {
<span class="fc" id="L81">      return AFSocketAddress.newSockAddrDirectBuffer(SOCKADDR_MAX_LEN);</span>
    }
  };

  private static final boolean USE_DESERIALIZATION_FOR_INIT;

  static {
<span class="fc" id="L88">    String v = System.getProperty(&quot;org.newsclub.net.unix.AFSocketAddress.deserialize&quot;, &quot;&quot;);</span>
<span class="pc bpc" id="L89" title="1 of 2 branches missed.">    USE_DESERIALIZATION_FOR_INIT = v.isEmpty() ? NativeLibraryLoader.isAndroid() : Boolean.valueOf(</span>
        v);
<span class="fc" id="L91">  }</span>

  /**
   * Some byte-level representation of this address, which can only be converted to a native
   * representation in combination with the domain ID.
   */
  @SuppressFBWarnings(&quot;JCIP_FIELD_ISNT_FINAL_IN_IMMUTABLE_CLASS&quot;)
  private byte[] bytes;

  /**
   * An {@link InetAddress}-wrapped representation of this address. Only created upon demand.
   */
<span class="fc" id="L103">  @SuppressFBWarnings(&quot;JCIP_FIELD_ISNT_FINAL_IN_IMMUTABLE_CLASS&quot;) // only modified during</span>
                                                                  // construction/deserialization
  private InetAddress inetAddress = null; // derived from bytes

  /**
   * The system-native representation of this address, or {@code null}.
   */
  @SuppressWarnings(&quot;PMD.ImmutableField&quot;)
  private transient ByteBuffer nativeAddress;

  /**
   * The address family.
   */
  private transient AFAddressFamily&lt;?&gt; addressFamily;

  /**
   * Creates a new socket address.
   *
   * @param port The port.
   * @param socketAddress The socket address in junixsocket-specific byte-array representation.
   * @param nativeAddress The socket address in system-native representation.
   * @param af The address family.
   * @throws SocketException on error.
   */
  protected AFSocketAddress(int port, final byte[] socketAddress, ByteBuffer nativeAddress,
      AFAddressFamily&lt;?&gt; af) throws SocketException {
    /*
     * Initializing the superclass with an unresolved hostname helps us pass the #equals and
     * #hashCode checks, which unfortunately are declared final in InetSocketAddress.
     *
     * Using a resolved address (with the address bit initialized) would be ideal, but resolved
     * addresses can only be IPv4 or IPv6 (at least as of Java 16 and earlier).
     */
<span class="fc bfc" id="L136" title="All 4 branches covered.">    super(AFInetAddress.createUnresolvedHostname(socketAddress, af), port &gt;= 0 &amp;&amp; port &lt;= 0xffff</span>
<span class="fc" id="L137">        ? port : 0);</span>
<span class="fc" id="L138">    initAFSocketAddress(this, port, socketAddress, nativeAddress, af);</span>
<span class="fc" id="L139">  }</span>

  /**
   * Only for {@link SentinelSocketAddress}.
   *
   * @param clazz The {@link SentinelSocketAddress} class.
   * @param port A sentinel port number.
   */
  @SuppressWarnings(&quot;PMD.UnusedFormalParameter&quot;)
  AFSocketAddress(Class&lt;SentinelSocketAddress&gt; clazz, int port) {
<span class="fc" id="L149">    super(InetAddress.getLoopbackAddress(), port);</span>
<span class="fc" id="L150">    this.nativeAddress = null;</span>
<span class="fc" id="L151">    this.bytes = new byte[0];</span>
<span class="fc" id="L152">    this.addressFamily = null;</span>
<span class="fc" id="L153">  }</span>

  @SuppressWarnings({&quot;cast&quot;, &quot;this-escape&quot;})
  private static void initAFSocketAddress(AFSocketAddress addr, int port,
      final byte[] socketAddress, ByteBuffer nativeAddress, AFAddressFamily&lt;?&gt; af)
      throws SocketException {
<span class="pc bpc" id="L159" title="1 of 2 branches missed.">    if (socketAddress.length == 0) {</span>
<span class="nc" id="L160">      throw new SocketException(&quot;Illegal address length: &quot; + socketAddress.length);</span>
    }

<span class="fc bfc" id="L163" title="All 2 branches covered.">    addr.nativeAddress = nativeAddress == null ? null : (ByteBuffer) (Object) nativeAddress</span>
<span class="fc" id="L164">        .duplicate().rewind();</span>
<span class="fc bfc" id="L165" title="All 2 branches covered.">    if (port &lt; -1) {</span>
<span class="fc" id="L166">      throw new IllegalArgumentException(&quot;port out of range&quot;);</span>
<span class="fc bfc" id="L167" title="All 2 branches covered.">    } else if (port &gt; 0xffff) {</span>
<span class="pc bpc" id="L168" title="1 of 2 branches missed.">      if (!NativeUnixSocket.isLoaded()) {</span>
<span class="nc" id="L169">        throw (SocketException) new SocketException(</span>
<span class="nc" id="L170">            &quot;Cannot set SocketAddress port - junixsocket JNI library is not available&quot;).initCause(</span>
<span class="nc" id="L171">                NativeUnixSocket.unsupportedException());</span>
      }
<span class="fc" id="L173">      NativeUnixSocket.setPort1(addr, port);</span>
    }

<span class="fc" id="L176">    addr.bytes = socketAddress.clone();</span>
<span class="fc" id="L177">    addr.addressFamily = af;</span>
<span class="fc" id="L178">  }</span>

  /**
   * Returns a new {@link AFSocketAddress} instance via deserialization. This is a trick to
   * workaround certain environments that do not allow the construction of {@link InetSocketAddress}
   * instances without trying DNS resolution.
   *
   * @param &lt;A&gt; The subclass (must be a direct subclass of {@link AFSocketAddress}).
   * @param port The port to use.
   * @param socketAddress The junixsocket representation of the socket address.
   * @param nativeAddress The system-native representation of the socket address, or {@code null}.
   * @param af The address family, corresponding to the subclass
   * @param constructor The constructor to use as fallback
   * @return The new instance.
   * @throws SocketException on error.
   */
  protected static &lt;A extends AFSocketAddress&gt; A newDeserializedAFSocketAddress(int port,
      final byte[] socketAddress, ByteBuffer nativeAddress, AFAddressFamily&lt;A&gt; af,
      AFSocketAddressConstructor&lt;A&gt; constructor) throws SocketException {
<span class="fc" id="L197">    String hostname = AFInetAddress.createUnresolvedHostname(socketAddress, af);</span>
<span class="pc bpc" id="L198" title="2 of 4 branches missed.">    if (hostname == null || hostname.isEmpty()) {</span>
<span class="nc" id="L199">      return constructor.newAFSocketAddress(port, socketAddress, nativeAddress);</span>
    }
<span class="fc" id="L201">    try (ObjectInputStream oin = new ObjectInputStream(new ByteArrayInputStream(AFSocketAddress</span>
<span class="pc bpc" id="L202" title="2 of 4 branches missed.">        .craftSerializedObject(af.getSocketAddressClass(), hostname, (port &gt;= 0 &amp;&amp; port &lt;= 0xffff</span>
<span class="pc" id="L203">            ? port : 0))))) {</span>
      @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L205">      A addr = (A) oin.readObject();</span>
<span class="fc" id="L206">      initAFSocketAddress(addr, port, socketAddress, nativeAddress, af);</span>
<span class="fc" id="L207">      return addr;</span>
<span class="nc" id="L208">    } catch (SocketException e) {</span>
<span class="nc" id="L209">      throw e;</span>
<span class="nc" id="L210">    } catch (ClassNotFoundException | IOException e) {</span>
<span class="nc" id="L211">      throw (SocketException) new SocketException(&quot;Unexpected deserialization problem&quot;).initCause(</span>
          e);
    }
  }

  /**
   * Creates a byte-representation of a serialized {@link AFSocketAddress} instance, overriding
   * hostname and port, which allows bypassing DNS resolution.
   *
   * @param className The actual subclass.
   * @param hostname The hostname to use (must not be empty or null).
   * @param port The port to use.
   * @return The byte representation.
   */
  private static byte[] craftSerializedObject(Class&lt;? extends AFSocketAddress&gt; className,
      String hostname, int port) {
<span class="fc" id="L227">    ByteBuffer bb = ByteBuffer.allocate(768);</span>
<span class="fc" id="L228">    bb.putShort((short) 0xaced); // STREAM_MAGIC</span>
<span class="fc" id="L229">    bb.putShort((short) 5); // STREAM_VERSION</span>
<span class="fc" id="L230">    bb.put((byte) 0x73); // TC_OBJECT</span>
<span class="fc" id="L231">    bb.put((byte) 0x72); // TC_CLASSDESC</span>

<span class="fc" id="L233">    putShortLengthUtf8(bb, className.getName());</span>
<span class="fc" id="L234">    bb.putLong(1); // serialVersionUID of subclass (expected to be 1)</span>
<span class="fc" id="L235">    bb.putInt(0x02000078);</span>
<span class="fc" id="L236">    bb.put((byte) 0x72);</span>

<span class="fc" id="L238">    putShortLengthUtf8(bb, AFSocketAddress.class.getName());</span>
<span class="fc" id="L239">    bb.putLong(serialVersionUID); // serialVersionUID of AFSocketAddress</span>
<span class="fc" id="L240">    bb.putInt(0x0300025B);</span>
<span class="fc" id="L241">    putShortLengthUtf8(bb, &quot;bytes&quot;);</span>

<span class="fc" id="L243">    bb.putInt(0x7400025B);</span>
<span class="fc" id="L244">    bb.putShort((short) 0x424C);</span>

<span class="fc" id="L246">    putShortLengthUtf8(bb, &quot;inetAddress&quot;);</span>
<span class="fc" id="L247">    bb.put((byte) 0x74);</span>

<span class="fc" id="L249">    putShortLengthEncodedClassName(bb, InetAddress.class);</span>

<span class="fc" id="L251">    bb.putShort((short) 0x7872);</span>
<span class="fc" id="L252">    putShortLengthUtf8(bb, InetSocketAddress.class.getName());</span>
<span class="fc" id="L253">    bb.putLong(5076001401234631237L); // NOPMD InetSocketAddress serialVersionUID</span>

<span class="fc" id="L255">    bb.putInt(0x03000349);</span>
<span class="fc" id="L256">    putShortLengthUtf8(bb, &quot;port&quot;);</span>

<span class="fc" id="L258">    bb.put((byte) 0x4C);</span>
<span class="fc" id="L259">    putShortLengthUtf8(bb, &quot;addr&quot;);</span>

<span class="fc" id="L261">    bb.putInt(0x71007E00);</span>
<span class="fc" id="L262">    bb.putShort((short) 0x034C);</span>
<span class="fc" id="L263">    putShortLengthUtf8(bb, &quot;hostname&quot;);</span>
<span class="fc" id="L264">    bb.put((byte) 0x74);</span>

<span class="fc" id="L266">    putShortLengthEncodedClassName(bb, String.class);</span>

<span class="fc" id="L268">    bb.putShort((short) 0x7872);</span>
<span class="fc" id="L269">    putShortLengthUtf8(bb, SocketAddress.class.getName());</span>
<span class="fc" id="L270">    bb.putLong(5215720748342549866L); // NOPMD SocketAddress serialVersionUID</span>

<span class="fc" id="L272">    bb.putInt(0x02000078);</span>
<span class="fc" id="L273">    bb.put((byte) 0x70);</span>
<span class="fc" id="L274">    bb.putInt(port);</span>

<span class="fc" id="L276">    bb.putShort((short) 0x7074);</span>
<span class="fc" id="L277">    putShortLengthUtf8(bb, hostname);</span>

<span class="fc" id="L279">    bb.putInt(0x78707077);</span>
<span class="fc" id="L280">    bb.put((byte) 0x0B);</span>

<span class="fc" id="L282">    putShortLengthUtf8(bb, &quot;undefined&quot;);</span>

<span class="fc" id="L284">    bb.put((byte) 0x78); // TC_ENDBLOCKDATA</span>
<span class="fc" id="L285">    bb.flip();</span>

<span class="fc" id="L287">    byte[] buf = new byte[bb.remaining()];</span>
<span class="fc" id="L288">    bb.get(buf);</span>
<span class="fc" id="L289">    return buf;</span>
  }

  private static void putShortLengthEncodedClassName(ByteBuffer bb, Class&lt;?&gt; klazz) {
<span class="fc" id="L293">    putShortLengthUtf8(bb, &quot;L&quot; + klazz.getName().replace('.', '/') + &quot;;&quot;);</span>
<span class="fc" id="L294">  }</span>

  private static void putShortLengthUtf8(ByteBuffer bb, String s) {
<span class="fc" id="L297">    byte[] utf8 = s.getBytes(StandardCharsets.UTF_8);</span>
<span class="fc" id="L298">    bb.putShort((short) utf8.length);</span>
<span class="fc" id="L299">    bb.put(utf8);</span>
<span class="fc" id="L300">  }</span>

  /**
   * Checks if {@link AFSocketAddress} instantiation should be performed via deserialization.
   *
   * @return {@code true} if so.
   * @see #newDeserializedAFSocketAddress(int, byte[], ByteBuffer, AFAddressFamily,
   *      AFSocketAddressConstructor)
   */
  protected static boolean isUseDeserializationForInit() {
<span class="fc" id="L310">    return USE_DESERIALIZATION_FOR_INIT;</span>
  }

  /**
   * Checks if the address can be resolved to a {@link File}.
   *
   * @return {@code true} if the address has a filename.
   */
  public abstract boolean hasFilename();

  /**
   * Returns the {@link File} corresponding with this address, if possible.
   *
   * A {@link FileNotFoundException} is thrown if there is no filename associated with the address,
   * which applies to addresses in the abstract namespace, for example.
   *
   * @return The filename.
   * @throws FileNotFoundException if the address is not associated with a filename.
   */
  public abstract File getFile() throws FileNotFoundException;

  /**
   * Returns the corresponding {@link AFAddressFamily}.
   *
   * @return The address family instance.
   */
  public final AFAddressFamily&lt;?&gt; getAddressFamily() {
<span class="fc" id="L337">    return addressFamily;</span>
  }

  /**
   * Wraps the socket name/peer name of a file descriptor as an {@link InetAddress}.
   *
   * @param fdesc The file descriptor.
   * @param peerName If {@code true}, the remote peer name (instead of the local name) is retrieved.
   * @param af The address family.
   * @return The {@link InetAddress}.
   */
  protected static final InetAddress getInetAddress(FileDescriptor fdesc, boolean peerName,
      AFAddressFamily&lt;?&gt; af) {
<span class="pc bpc" id="L350" title="1 of 2 branches missed.">    if (!fdesc.valid()) {</span>
<span class="nc" id="L351">      return null;</span>
    }
<span class="fc" id="L353">    byte[] addr = NativeUnixSocket.sockname(af.getDomain(), fdesc, peerName);</span>
<span class="fc bfc" id="L354" title="All 2 branches covered.">    if (addr == null) {</span>
<span class="fc" id="L355">      return null;</span>
    }
<span class="fc" id="L357">    return AFInetAddress.wrapAddress(addr, af);</span>
  }

  /**
   * Gets the socket name/peer name of a file descriptor as an {@link AFSocketAddress}.
   *
   * @param &lt;A&gt; The corresponding address type.
   * @param fdesc The file descriptor.
   * @param peerName If {@code true}, the remote peer name (instead of the local name) is retrieved.
   * @param port The port.
   * @param af The address family.
   * @return The {@link InetAddress}.
   */
  protected static final &lt;A extends AFSocketAddress&gt; @Nullable A getSocketAddress(
      FileDescriptor fdesc, boolean peerName, int port, AFAddressFamily&lt;A&gt; af) {
<span class="pc bpc" id="L372" title="1 of 2 branches missed.">    if (!fdesc.valid()) {</span>
<span class="nc" id="L373">      return null;</span>
    }
<span class="fc" id="L375">    byte[] addr = NativeUnixSocket.sockname(af.getDomain(), fdesc, peerName);</span>
<span class="fc bfc" id="L376" title="All 2 branches covered.">    if (addr == null) {</span>
<span class="fc" id="L377">      return null;</span>
    }
    try {
      // FIXME we could infer the &quot;port&quot; from the path if the socket factory supports that
<span class="fc" id="L381">      return AFSocketAddress.unwrap(AFInetAddress.wrapAddress(addr, af), port, af);</span>
<span class="nc" id="L382">    } catch (SocketException e) {</span>
<span class="nc" id="L383">      throw new IllegalStateException(e);</span>
    }
  }

  static final AFSocketAddress preprocessSocketAddress(
      Class&lt;? extends AFSocketAddress&gt; supportedAddressClass, SocketAddress endpoint,
      AFSocketAddressFromHostname&lt;?&gt; afh) throws SocketException {
<span class="fc" id="L390">    Objects.requireNonNull(endpoint);</span>
<span class="fc bfc" id="L391" title="All 2 branches covered.">    if (endpoint instanceof SentinelSocketAddress) {</span>
<span class="fc" id="L392">      return (SentinelSocketAddress) endpoint;</span>
    }

<span class="fc bfc" id="L395" title="All 2 branches covered.">    if (!(endpoint instanceof AFSocketAddress)) {</span>
<span class="fc bfc" id="L396" title="All 2 branches covered.">      if (afh != null) {</span>
<span class="pc bpc" id="L397" title="1 of 2 branches missed.">        if (endpoint instanceof InetSocketAddress) {</span>
<span class="fc" id="L398">          InetSocketAddress isa = (InetSocketAddress) endpoint;</span>

<span class="fc" id="L400">          String hostname = isa.getHostString();</span>
<span class="fc bfc" id="L401" title="All 2 branches covered.">          if (afh.isHostnameSupported(hostname)) {</span>
            try {
<span class="fc" id="L403">              endpoint = afh.addressFromHost(hostname, isa.getPort());</span>
<span class="fc" id="L404">            } catch (SocketException e) {</span>
<span class="fc" id="L405">              throw e;</span>
<span class="fc" id="L406">            }</span>
          }
        }
      }
    }

<span class="fc" id="L412">    Objects.requireNonNull(endpoint);</span>

<span class="fc bfc" id="L414" title="All 2 branches covered.">    if (!supportedAddressClass.isAssignableFrom(endpoint.getClass())) {</span>
<span class="fc" id="L415">      throw new IllegalArgumentException(&quot;Can only connect to endpoints of type &quot;</span>
<span class="fc" id="L416">          + supportedAddressClass.getName() + &quot;, got: &quot; + endpoint.getClass() + &quot;: &quot; + endpoint);</span>
    }

<span class="fc" id="L419">    return (AFSocketAddress) endpoint;</span>
  }

  /**
   * Returns the (non-native) byte-level representation of this address.
   *
   * @return The byte array.
   */
  protected final byte[] getBytes() {
<span class="fc" id="L428">    return bytes; // NOPMD</span>
  }

  /**
   * Returns a &quot;special&quot; {@link InetAddress} that contains information about this
   * {@link AFSocketAddress}.
   *
   * IMPORTANT: This {@link InetAddress} does not properly compare (using
   * {@link InetAddress#equals(Object)} and {@link InetAddress#hashCode()}). It should be used
   * exclusively to circumvent existing APIs like {@link DatagramSocket} that only accept/return
   * {@link InetAddress} and not arbitrary {@link SocketAddress} types.
   *
   * @return The &quot;special&quot; {@link InetAddress}.
   */
  public final InetAddress wrapAddress() {
<span class="fc" id="L443">    return AFInetAddress.wrapAddress(bytes, getAddressFamily());</span>
  }

  /**
   * A reference to the constructor of an AFSocketAddress subclass.
   *
   * @param &lt;T&gt; The actual subclass.
   * @author Christian Kohlschütter
   */
  @FunctionalInterface
  protected interface AFSocketAddressConstructor&lt;T extends AFSocketAddress&gt; {
    /**
     * Constructs a new AFSocketAddress instance.
     *
     * @param port The port.
     * @param socketAddress The socket address in junixsocket-specific byte-array representation.
     * @param nativeAddress The socket address in system-native representation.
     * @return The instance.
     * @throws SocketException on error.
     */
    @NonNull
    T newAFSocketAddress(int port, byte[] socketAddress, ByteBuffer nativeAddress)
        throws SocketException;
  }

  /**
   * Resolves a junixsocket-specific byte-array representation of an {@link AFSocketAddress} to an
   * actual {@link AFSocketAddress} instance, possibly reusing a cached instance.
   *
   * @param &lt;A&gt; The concrete {@link AFSocketAddress} that is supported by this type.
   * @param socketAddress The socket address in junixsocket-specific byte-array representation.
   * @param port The port.
   * @param af The address family.
   * @return The instance.
   * @throws SocketException on error.
   */
  @SuppressWarnings({&quot;unchecked&quot;, &quot;null&quot;})
  protected static final &lt;A extends AFSocketAddress&gt; A resolveAddress(final byte[] socketAddress,
      int port, AFAddressFamily&lt;A&gt; af) throws SocketException {
<span class="fc bfc" id="L482" title="All 2 branches covered.">    if (socketAddress.length == 0) {</span>
<span class="fc" id="L483">      throw new SocketException(&quot;Address cannot be empty&quot;);</span>
    }

<span class="fc bfc" id="L486" title="All 2 branches covered.">    if (port == -1) {</span>
<span class="fc" id="L487">      port = 0;</span>
    }

<span class="fc" id="L490">    ByteBuffer direct = SOCKETADDRESS_BUFFER_TL.get();</span>
<span class="pc bpc" id="L491" title="1 of 2 branches missed.">    int limit = NativeUnixSocket.isLoaded() ? NativeUnixSocket.bytesToSockAddr(af.getDomain(),</span>
<span class="pc" id="L492">        direct, socketAddress) : -1;</span>
<span class="fc bfc" id="L493" title="All 2 branches covered.">    if (limit == -1) {</span>
      // not supported, but we can still create an address
<span class="fc" id="L495">      return af.getAddressConstructor().newAFSocketAddress(port, socketAddress, null);</span>
<span class="pc bpc" id="L496" title="1 of 2 branches missed.">    } else if (limit &gt; SOCKADDR_MAX_LEN) {</span>
<span class="nc" id="L497">      throw new IllegalStateException(&quot;Unexpected address length&quot;);</span>
    }
<span class="fc" id="L499">    direct.rewind();</span>
<span class="fc" id="L500">    direct.limit(limit);</span>

    A instance;
<span class="fc" id="L503">    synchronized (AFSocketAddress.class) {</span>
      Map&lt;ByteBuffer, AFSocketAddress&gt; map;
<span class="fc" id="L505">      Map&lt;Integer, Map&lt;ByteBuffer, AFSocketAddress&gt;&gt; mapPorts = ADDRESS_CACHE.get(af);</span>
<span class="fc bfc" id="L506" title="All 2 branches covered.">      if (mapPorts == null) {</span>
<span class="fc" id="L507">        instance = null;</span>
<span class="fc" id="L508">        mapPorts = new HashMap&lt;&gt;();</span>
<span class="fc" id="L509">        map = new HashMap&lt;&gt;();</span>
<span class="fc" id="L510">        mapPorts.put(port, map);</span>
<span class="fc" id="L511">        ADDRESS_CACHE.put(af, mapPorts);</span>
      } else {
<span class="fc" id="L513">        map = mapPorts.get(port);</span>
<span class="fc bfc" id="L514" title="All 2 branches covered.">        if (map == null) {</span>
<span class="fc" id="L515">          instance = null;</span>
<span class="fc" id="L516">          map = new HashMap&lt;&gt;();</span>
<span class="fc" id="L517">          mapPorts.put(port, map);</span>
        } else {
<span class="fc" id="L519">          instance = (A) map.get(direct);</span>
        }
      }

<span class="pc bpc" id="L523" title="1 of 2 branches missed.">      if (instance == null) {</span>
<span class="fc" id="L524">        ByteBuffer key = newSockAddrKeyBuffer(limit);</span>
<span class="fc" id="L525">        key.put(direct);</span>
<span class="fc" id="L526">        key = key.asReadOnlyBuffer();</span>

<span class="fc" id="L528">        instance = af.getAddressConstructor().newAFSocketAddress(port, socketAddress, key);</span>

<span class="fc" id="L530">        map.put(key, instance);</span>
      }
<span class="fc" id="L532">    }</span>

<span class="fc" id="L534">    return instance;</span>
  }

  @SuppressWarnings(&quot;null&quot;)
  static final &lt;A extends AFSocketAddress&gt; A ofInternal(ByteBuffer socketAddressBuffer,
      AFAddressFamily&lt;A&gt; af) throws SocketException {
<span class="fc" id="L540">    synchronized (AFSocketAddress.class) {</span>
<span class="fc" id="L541">      socketAddressBuffer.rewind();</span>

<span class="fc" id="L543">      Map&lt;Integer, Map&lt;ByteBuffer, AFSocketAddress&gt;&gt; mapPorts = ADDRESS_CACHE.get(af);</span>
<span class="pc bpc" id="L544" title="1 of 2 branches missed.">      if (mapPorts != null) {</span>
<span class="fc" id="L545">        Map&lt;ByteBuffer, AFSocketAddress&gt; map = mapPorts.get(0); // FIXME get port, something like</span>
                                                                // sockAddrToPort
<span class="pc bpc" id="L547" title="1 of 2 branches missed.">        if (map != null) {</span>
          @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L549">          A address = (A) map.get(socketAddressBuffer);</span>
<span class="pc bpc" id="L550" title="1 of 2 branches missed.">          if (address != null) {</span>
<span class="nc" id="L551">            return address;</span>
          }
        }
      }

<span class="pc bpc" id="L556" title="1 of 2 branches missed.">      if (!socketAddressBuffer.isDirect()) {</span>
<span class="nc" id="L557">        ByteBuffer buf = getNativeAddressDirectBuffer(Math.min(socketAddressBuffer.limit(),</span>
            SOCKADDR_MAX_LEN));
<span class="nc" id="L559">        buf.put(socketAddressBuffer);</span>
<span class="nc" id="L560">        socketAddressBuffer = buf;</span>
      }

<span class="fc" id="L563">      byte[] sockAddrToBytes = NativeUnixSocket.sockAddrToBytes(af.getDomain(),</span>
          socketAddressBuffer);
<span class="pc bpc" id="L565" title="1 of 2 branches missed.">      if (sockAddrToBytes == null) {</span>
<span class="nc" id="L566">        return null;</span>
      } else {
<span class="fc" id="L568">        return AFSocketAddress.resolveAddress(sockAddrToBytes, 0, af);</span>
      }
    }
  }

  /**
   * Wraps an address as an {@link InetAddress}.
   *
   * @param af The address family.
   * @return The {@link InetAddress}.
   */
  protected final synchronized InetAddress getInetAddress(AFAddressFamily&lt;?&gt; af) {
<span class="pc bpc" id="L580" title="1 of 2 branches missed.">    if (inetAddress == null) {</span>
<span class="fc" id="L581">      inetAddress = AFInetAddress.wrapAddress(bytes, af);</span>
    }
<span class="fc" id="L583">    return inetAddress;</span>
  }

  /**
   * Wraps this address as an {@link InetAddress}.
   *
   * @return The {@link InetAddress}.
   */
  protected final InetAddress getInetAddress() {
<span class="fc" id="L592">    return getInetAddress(getAddressFamily());</span>
  }

  static final ByteBuffer newSockAddrDirectBuffer(int length) {
<span class="fc" id="L596">    return ByteBuffer.allocateDirect(length);</span>
  }

  static final ByteBuffer newSockAddrKeyBuffer(int length) {
<span class="fc" id="L600">    return ByteBuffer.allocate(length);</span>
  }

  /**
   * Returns an {@link AFSocketAddress} given a special {@link InetAddress} that encodes the byte
   * sequence of an AF_UNIX etc. socket address, like those returned by {@link #wrapAddress()}.
   *
   * @param &lt;A&gt; The corresponding address type.
   * @param address The &quot;special&quot; {@link InetAddress}.
   * @param port The port (use 0 for &quot;none&quot;).
   * @param af The address family.
   * @return The {@link AFSocketAddress} instance.
   * @throws SocketException if the operation fails, for example when an unsupported address is
   *           specified.
   */
  @SuppressWarnings(&quot;null&quot;)
  @NonNull
  protected static final &lt;A extends AFSocketAddress&gt; A unwrap(InetAddress address, int port,
      AFAddressFamily&lt;A&gt; af) throws SocketException {
<span class="fc" id="L619">    Objects.requireNonNull(address);</span>
<span class="fc" id="L620">    return resolveAddress(AFInetAddress.unwrapAddress(address, af), port, af);</span>
  }

  /**
   * Returns an {@link AFSocketAddress} given a special {@link InetAddress} hostname that encodes
   * the byte sequence of an AF_UNIX etc. socket address, like those returned by
   * {@link #wrapAddress()}.
   *
   * @param &lt;A&gt; The corresponding address type.
   * @param hostname The &quot;special&quot; hostname, as provided by {@link InetAddress#getHostName()}.
   * @param port The port (use 0 for &quot;none&quot;).
   * @param af The address family.
   * @return The {@link AFSocketAddress} instance.
   * @throws SocketException if the operation fails, for example when an unsupported address is
   *           specified.
   */
  @SuppressWarnings(&quot;null&quot;)
  @NonNull
  protected static final &lt;A extends AFSocketAddress&gt; A unwrap(String hostname, int port,
      AFAddressFamily&lt;A&gt; af) throws SocketException {
<span class="nc" id="L640">    Objects.requireNonNull(hostname);</span>
<span class="nc" id="L641">    return resolveAddress(AFInetAddress.unwrapAddress(hostname, af), port, af);</span>
  }

  static final int unwrapAddressDirectBufferInternal(ByteBuffer socketAddressBuffer,
      SocketAddress address) throws SocketException {
<span class="pc bpc" id="L646" title="1 of 2 branches missed.">    if (!NativeUnixSocket.isLoaded()) {</span>
<span class="nc" id="L647">      throw new SocketException(&quot;Unsupported operation; junixsocket native library is not loaded&quot;);</span>
    }
<span class="fc" id="L649">    Objects.requireNonNull(address);</span>

<span class="pc bpc" id="L651" title="1 of 2 branches missed.">    if (!(address instanceof AFSocketAddress)) {</span>
<span class="nc" id="L652">      AFSupplier&lt;? extends AFSocketAddress&gt; supp = AFUNIXSocketAddress.supportedAddressSupplier(</span>
          address);
<span class="nc bnc" id="L654" title="All 2 branches missed.">      address = supp == null ? null : supp.get();</span>
<span class="nc bnc" id="L655" title="All 2 branches missed.">      if (address == null) {</span>
<span class="nc" id="L656">        throw new SocketException(&quot;Unsupported address&quot;);</span>
      }
    }

<span class="fc" id="L660">    AFSocketAddress socketAddress = (AFSocketAddress) address;</span>

<span class="fc" id="L662">    byte[] addr = socketAddress.getBytes();</span>
<span class="fc" id="L663">    int domain = socketAddress.getAddressFamily().getDomain();</span>

<span class="fc" id="L665">    int len = NativeUnixSocket.bytesToSockAddr(domain, socketAddressBuffer, addr);</span>
<span class="pc bpc" id="L666" title="1 of 2 branches missed.">    if (len == -1) {</span>
<span class="nc" id="L667">      throw new SocketException(&quot;Unsupported domain&quot;);</span>
    }
<span class="fc" id="L669">    return len;</span>
  }

  /**
   * Returns a thread-local direct ByteBuffer containing the native socket address representation of
   * this {@link AFSocketAddress}.
   *
   * @return The direct {@link ByteBuffer}.
   */
  final ByteBuffer getNativeAddressDirectBuffer() throws SocketException {
<span class="fc" id="L679">    ByteBuffer address = nativeAddress;</span>
<span class="pc bpc" id="L680" title="1 of 2 branches missed.">    if (address == null) {</span>
<span class="nc" id="L681">      throw (SocketException) new SocketException(&quot;Cannot access native address&quot;).initCause(</span>
<span class="nc" id="L682">          NativeUnixSocket.unsupportedException());</span>
    }
<span class="fc" id="L684">    address = address.duplicate();</span>

<span class="fc" id="L686">    ByteBuffer direct = getNativeAddressDirectBuffer(address.limit());</span>
<span class="fc" id="L687">    address.position(0);</span>
<span class="fc" id="L688">    direct.put(address);</span>

<span class="fc" id="L690">    return direct;</span>
  }

  static final ByteBuffer getNativeAddressDirectBuffer(int limit) {
<span class="fc" id="L694">    ByteBuffer direct = SOCKETADDRESS_BUFFER_TL.get();</span>
<span class="fc" id="L695">    direct.position(0);</span>
<span class="fc" id="L696">    direct.limit(limit);</span>
<span class="fc" id="L697">    return direct;</span>
  }

  /**
   * Checks if the given address is supported by this address family.
   *
   * @param addr The address.
   * @param af The address family.
   * @return {@code true} if supported.
   */
  protected static final boolean isSupportedAddress(InetAddress addr, AFAddressFamily&lt;?&gt; af) {
<span class="nc" id="L708">    return AFInetAddress.isSupportedAddress(addr, af);</span>
  }

  /**
   * Writes the native (system-level) representation of this address to the given buffer.
   *
   * The position of the target buffer will be at the end (i.e., after) the written data.
   *
   * @param buf The target buffer.
   * @throws IOException on error.
   */
  public final void writeNativeAddressTo(ByteBuffer buf) throws IOException {
<span class="nc bnc" id="L720" title="All 2 branches missed.">    if (nativeAddress == null) {</span>
<span class="nc" id="L721">      throw (SocketException) new SocketException(&quot;Cannot access native address&quot;).initCause(</span>
<span class="nc" id="L722">          NativeUnixSocket.unsupportedException());</span>
    }
<span class="nc" id="L724">    buf.put(nativeAddress);</span>
<span class="nc" id="L725">  }</span>

  /**
   * Creates a new socket connected to this address.
   *
   * @return The socket instance.
   * @throws IOException on error.
   */
  public AFSocket&lt;?&gt; newConnectedSocket() throws IOException {
<span class="fc" id="L734">    AFSocket&lt;?&gt; socket = getAddressFamily().newSocket();</span>
<span class="fc" id="L735">    socket.connect(this);</span>
<span class="fc" id="L736">    return socket;</span>
  }

  /**
   * Creates a new server socket bound to this address.
   *
   * @return The server socket instance.
   * @throws IOException on error.
   */
  public AFServerSocket&lt;?&gt; newBoundServerSocket() throws IOException {
<span class="fc" id="L746">    AFServerSocket&lt;?&gt; serverSocket = getAddressFamily().newServerSocket();</span>
<span class="fc" id="L747">    serverSocket.bind(this);</span>
<span class="fc" id="L748">    return serverSocket;</span>
  }

  /**
   * Creates a new server socket force-bound to this address (i.e., any additional call to
   * {@link ServerSocket#bind(SocketAddress)} will ignore the passed address and use this one
   * instead.
   *
   * @return The server socket instance.
   * @throws IOException on error.
   */
  public AFServerSocket&lt;?&gt; newForceBoundServerSocket() throws IOException {
<span class="nc" id="L760">    AFServerSocket&lt;?&gt; serverSocket = getAddressFamily().newServerSocket();</span>
<span class="nc" id="L761">    serverSocket.forceBindAddress(this).bind(this);</span>
<span class="nc" id="L762">    return serverSocket;</span>
  }

  /**
   * Tries to parse the given URI and return a corresponding {@link AFSocketAddress} for it.
   *
   * NOTE: Only certain URI schemes are supported, such as {@code unix://} (for
   * {@link AFUNIXSocketAddress}) and {@code tipc://} for {@link AFTIPCSocketAddress}.
   *
   * @param u The URI.
   * @return The address.
   * @throws SocketException on error.
   * @see AFAddressFamily#uriSchemes()
   */
  @SuppressWarnings(&quot;PMD.ShortMethodName&quot;)
  public static AFSocketAddress of(URI u) throws SocketException {
<span class="fc" id="L778">    return of(u, -1);</span>
  }

  /**
   * Tries to parse the given URI and return a corresponding {@link AFSocketAddress} for it.
   *
   * NOTE: Only certain URI schemes are supported, such as {@code unix://} (for
   * {@link AFUNIXSocketAddress}) and {@code tipc://} for {@link AFTIPCSocketAddress}.
   *
   * @param u The URI.
   * @param overridePort The port to forcibly use, or {@code -1} for &quot;don't override&quot;.
   * @return The address.
   * @throws SocketException on error.
   * @see AFAddressFamily#uriSchemes()
   */
  @SuppressWarnings(&quot;PMD.ShortMethodName&quot;)
  public static AFSocketAddress of(URI u, int overridePort) throws SocketException {
<span class="fc" id="L795">    AFAddressFamily&lt;?&gt; af = AFAddressFamily.getAddressFamily(u);</span>
<span class="pc bpc" id="L796" title="1 of 2 branches missed.">    if (af == null) {</span>
<span class="nc" id="L797">      throw new SocketException(&quot;Cannot resolve AFSocketAddress from URI scheme: &quot; + u.getScheme());</span>
    }
<span class="fc" id="L799">    return af.parseURI(u, overridePort);</span>
  }

  /**
   * Tries to create a URI based on this {@link AFSocketAddress}.
   *
   * @param scheme The target scheme.
   * @param template An optional template to reuse certain parameters (e.g., the &quot;path&quot; component
   *          for an {@code http} request), or {@code null}.
   * @return The URI.
   * @throws IOException on error.
   */
  public URI toURI(String scheme, URI template) throws IOException {
<span class="nc" id="L812">    throw new IOException(&quot;Unsupported operation&quot;);</span>
  }

  /**
   * Returns a address string that can be used with {@code socat}'s {@code SOCKET-CONNECT},
   * {@code SOCKET-LISTEN}, {@code SOCKET-DATAGRAM}, etc., address types, or {@code null} if the
   * address type is not natively supported by this platform.
   *
   * This call is mostly suited for debugging purposes. The resulting string is specific to the
   * platform the code is executed on, and thus may be different among platforms.
   *
   * @param socketType The socket type, or {@code null} to omit from string.
   * @param socketProtocol The socket protocol, or {@code null} to omit from string.
   * @return The string (such as 1:0:x2f746d702f796f).
   * @throws IOException on error (a {@link SocketException} is thrown if the native address cannot
   *           be accessed).
   */
  public @Nullable @SuppressWarnings(&quot;PMD.NPathComplexity&quot;) String toSocatAddressString(
      AFSocketType socketType, AFSocketProtocol socketProtocol) throws IOException {

<span class="pc bpc" id="L832" title="2 of 4 branches missed.">    if (SOCKADDR_NATIVE_FAMILY_OFFSET == -1 || SOCKADDR_NATIVE_DATA_OFFSET == -1) {</span>
<span class="nc" id="L833">      return null;</span>
    }
<span class="fc bfc" id="L835" title="All 2 branches covered.">    if (nativeAddress == null) {</span>
<span class="fc" id="L836">      throw (SocketException) new SocketException(&quot;Cannot access native address&quot;).initCause(</span>
<span class="fc" id="L837">          NativeUnixSocket.unsupportedException());</span>
    }
<span class="pc bpc" id="L839" title="2 of 4 branches missed.">    if (socketProtocol != null &amp;&amp; socketProtocol.getId() != 0) {</span>
<span class="nc" id="L840">      throw new IOException(&quot;Protocol not (yet) supported&quot;); // FIXME support additional protocols</span>
    }

<span class="fc" id="L843">    int family = (nativeAddress.get(SOCKADDR_NATIVE_FAMILY_OFFSET) &amp; 0xFF);</span>
<span class="fc bfc" id="L844" title="All 2 branches covered.">    int type = socketType == null ? -1 : NativeUnixSocket.sockTypeToNative(socketType.getId());</span>
<span class="fc" id="L845">    StringBuilder sb = new StringBuilder();</span>
<span class="fc" id="L846">    sb.append(family);</span>
<span class="fc bfc" id="L847" title="All 2 branches covered.">    if (type != -1) {</span>
<span class="fc" id="L848">      sb.append(':');</span>
<span class="fc" id="L849">      sb.append(type);</span>
    }
<span class="pc bpc" id="L851" title="1 of 2 branches missed.">    if (socketProtocol != null) {</span>
<span class="fc" id="L852">      sb.append(':');</span>
<span class="fc" id="L853">      sb.append(socketProtocol.getId()); // FIXME needs native conversion</span>
    }
<span class="fc" id="L855">    sb.append(&quot;:x&quot;);</span>
<span class="fc" id="L856">    int n = nativeAddress.limit();</span>
<span class="pc bpc" id="L857" title="1 of 4 branches missed.">    while (n &gt; 1 &amp;&amp; nativeAddress.get(n - 1) == 0) {</span>
<span class="fc" id="L858">      n--;</span>
    }
<span class="fc bfc" id="L860" title="All 2 branches covered.">    for (int pos = SOCKADDR_NATIVE_DATA_OFFSET; pos &lt; n; pos++) {</span>
<span class="fc" id="L861">      byte b = nativeAddress.get(pos);</span>
<span class="fc" id="L862">      sb.append(String.format(Locale.ENGLISH, &quot;%02x&quot;, b));</span>
    }
<span class="fc" id="L864">    return sb.toString();</span>
  }

  /**
   * Checks if the given address could cover another address.
   *
   * By default, this is only true if both addresses are regarded equal using
   * {@link #equals(Object)}.
   *
   * However, implementations may support &quot;wildcard&quot; addresses, and this method would compare a
   * wildcard address against some non-wildcard address, for example.
   *
   * @param other The other address that could be covered by this address.
   * @return {@code true} if the other address could be covered.
   */
  public boolean covers(AFSocketAddress other) {
<span class="nc" id="L880">    return this.equals(other);</span>
  }

  /**
   * Custom serialization: Reference {@link AFAddressFamily} instance by identifier string.
   *
   * @param in The {@link ObjectInputStream}.
   * @throws ClassNotFoundException on error.
   * @throws IOException on error.
   */
  private void readObject(ObjectInputStream in) throws ClassNotFoundException, IOException {
<span class="fc" id="L891">    in.defaultReadObject();</span>

<span class="fc" id="L893">    String af = in.readUTF();</span>
<span class="fc bfc" id="L894" title="All 2 branches covered.">    if (&quot;undefined&quot;.equals(af)) {</span>
<span class="fc" id="L895">      this.addressFamily = null;</span>
    } else {
<span class="fc" id="L897">      this.addressFamily = Objects.requireNonNull(AFAddressFamily.getAddressFamily(af),</span>
          &quot;address family&quot;);
    }
<span class="fc" id="L900">  }</span>

  /**
   * Custom serialization: Reference {@link AFAddressFamily} instance by identifier string.
   *
   * @param out The {@link ObjectOutputStream}.
   * @throws IOException on error.
   */
  private void writeObject(ObjectOutputStream out) throws IOException {
<span class="fc" id="L909">    out.defaultWriteObject();</span>
<span class="pc bpc" id="L910" title="1 of 2 branches missed.">    out.writeUTF(addressFamily == null ? &quot;undefined&quot; : addressFamily.getJuxString());</span>
<span class="fc" id="L911">  }</span>

  /**
   * Returns a string representation of the argument as an unsigned decimal value.
   * &lt;p&gt;
   * Works like {@link Integer#toUnsignedString(int)}; added to allow execution on Java 1.7.
   *
   * @param i The value.
   * @return The string.
   */
  static String toUnsignedString(int i) {
<span class="fc" id="L922">    return Long.toString(toUnsignedLong(i));</span>
  }

  /**
   * Returns a string representation of the first argument as an unsigned integer value in the radix
   * specified by the second argument; added to allow execution on Java 1.7.
   *
   * @param i The value.
   * @param radix The radix.
   * @return The string.
   */
  static String toUnsignedString(int i, int radix) {
<span class="fc" id="L934">    return Long.toUnsignedString(toUnsignedLong(i), radix);</span>
  }

  private static long toUnsignedLong(long x) {
<span class="fc" id="L938">    return x &amp; 0xffffffffL;</span>
  }

  /**
   * Parses the string argument as an unsigned integer in the radix specified by the second
   * argument. Works like {@link Integer#parseUnsignedInt(String, int)}; added to allow execution on
   * Java 1.7.
   *
   * @param s The string.
   * @param radix The radix.
   * @return The integer.
   * @throws NumberFormatException on parse error.
   */
  protected static int parseUnsignedInt(String s, int radix) throws NumberFormatException {
<span class="pc bpc" id="L952" title="2 of 4 branches missed.">    if (s == null || s.isEmpty()) {</span>
<span class="nc" id="L953">      throw new NumberFormatException(&quot;Cannot parse null or empty string&quot;);</span>
    }

<span class="fc" id="L956">    int len = s.length();</span>
<span class="pc bpc" id="L957" title="1 of 2 branches missed.">    if (s.startsWith(&quot;-&quot;)) {</span>
<span class="nc" id="L958">      throw new NumberFormatException(&quot;Illegal leading minus sign on unsigned string &quot; + s);</span>
    }

<span class="fc bfc" id="L961" title="All 6 branches covered.">    if (len &lt;= 5 || (radix == 10 &amp;&amp; len &lt;= 9)) {</span>
<span class="fc" id="L962">      return Integer.parseInt(s, radix);</span>
    } else {
<span class="fc" id="L964">      long ell = Long.parseLong(s, radix);</span>
<span class="pc bpc" id="L965" title="1 of 2 branches missed.">      if ((ell &amp; 0xffff_ffff_0000_0000L) == 0) {</span>
<span class="fc" id="L966">        return (int) ell;</span>
      } else {
<span class="nc" id="L968">        throw new NumberFormatException(&quot;String value exceeds &quot; + &quot;range of unsigned int: &quot; + s);</span>
      }
    }
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.10.202304240956</span></div></body></html>