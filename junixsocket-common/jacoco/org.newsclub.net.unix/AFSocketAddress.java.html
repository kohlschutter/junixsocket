<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AFSocketAddress.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">junixsocket-common</a> &gt; <a href="index.source.html" class="el_package">org.newsclub.net.unix</a> &gt; <span class="el_source">AFSocketAddress.java</span></div><h1>AFSocketAddress.java</h1><pre class="source lang-java linenums">/*
 * junixsocket
 *
 * Copyright 2009-2023 Christian Kohlschütter
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.newsclub.net.unix;

import java.io.File;
import java.io.FileDescriptor;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.net.DatagramSocket;
import java.net.InetAddress;
import java.net.InetSocketAddress;
import java.net.ServerSocket;
import java.net.SocketAddress;
import java.net.SocketException;
import java.net.URI;
import java.nio.ByteBuffer;
import java.util.HashMap;
import java.util.Locale;
import java.util.Map;
import java.util.Objects;
import java.util.function.Supplier;

import org.eclipse.jdt.annotation.NonNull;
import org.eclipse.jdt.annotation.Nullable;

/**
 * Some {@link SocketAddress} that is supported by junixsocket, such as {@link AFUNIXSocketAddress}.
 *
 * @author Christian Kohlschütter
 */
@SuppressWarnings({&quot;PMD.CouplingBetweenObjects&quot;, &quot;PMD.CyclomaticComplexity&quot;})
public abstract class AFSocketAddress extends InetSocketAddress {
  private static final long serialVersionUID = 1L;

  /**
   * Just a marker for &quot;don't actually bind&quot; (checked with &quot;==&quot;). Used in combination with a
   * superclass' bind method, which should trigger &quot;setBound()&quot;, etc.
   */
<span class="fc" id="L56">  static final AFSocketAddress INTERNAL_DUMMY_BIND = new SentinelSocketAddress(0);</span>
<span class="fc" id="L57">  static final AFSocketAddress INTERNAL_DUMMY_CONNECT = new SentinelSocketAddress(1);</span>
<span class="fc" id="L58">  static final AFSocketAddress INTERNAL_DUMMY_DONT_CONNECT = new SentinelSocketAddress(2);</span>

<span class="pc bpc" id="L60" title="1 of 2 branches missed.">  private static final int SOCKADDR_NATIVE_FAMILY_OFFSET = NativeUnixSocket.isLoaded() //</span>
<span class="pc" id="L61">      ? NativeUnixSocket.sockAddrNativeFamilyOffset() : -1;</span>

<span class="pc bpc" id="L63" title="1 of 2 branches missed.">  private static final int SOCKADDR_NATIVE_DATA_OFFSET = NativeUnixSocket.isLoaded() //</span>
<span class="pc" id="L64">      ? NativeUnixSocket.sockAddrNativeDataOffset() : -1;</span>

<span class="pc bpc" id="L66" title="1 of 2 branches missed.">  private static final int SOCKADDR_MAX_LEN = NativeUnixSocket.isLoaded() //</span>
<span class="pc" id="L67">      ? NativeUnixSocket.sockAddrLength(0) : 256;</span>

<span class="fc" id="L69">  private static final Map&lt;AFAddressFamily&lt;?&gt;, Map&lt;Integer, Map&lt;ByteBuffer, AFSocketAddress&gt;&gt;&gt; ADDRESS_CACHE =</span>
      new HashMap&lt;&gt;();

<span class="fc" id="L72">  static final ThreadLocal&lt;ByteBuffer&gt; SOCKETADDRESS_BUFFER_TL = new ThreadLocal&lt;ByteBuffer&gt;() {</span>

    @Override
    protected ByteBuffer initialValue() {
<span class="fc" id="L76">      return AFSocketAddress.newSockAddrDirectBuffer(SOCKADDR_MAX_LEN);</span>
    }
  };

  /**
   * Some byte-level representation of this address, which can only be converted to a native
   * representation in combination with the domain ID.
   */
  private final byte[] bytes;

  /**
   * An {@link InetAddress}-wrapped representation of this address. Only created upon demand.
   */
<span class="fc" id="L89">  private InetAddress inetAddress = null;</span>

  /**
   * The system-native representation of this address, or {@code null}.
   */
  @SuppressWarnings(&quot;PMD.ImmutableField&quot;)
  private transient ByteBuffer nativeAddress;

  /**
   * The address family.
   */
  private transient AFAddressFamily&lt;?&gt; addressFamily;

  /**
   * Creates a new socket address.
   *
   * @param port The port.
   * @param socketAddress The socket address in junixsocket-specific byte-array representation.
   * @param nativeAddress The socket address in system-native representation.
   * @param af The address family.
   * @throws SocketException on error.
   */
  @SuppressWarnings({&quot;cast&quot;, &quot;this-escape&quot;})
  protected AFSocketAddress(int port, final byte[] socketAddress, ByteBuffer nativeAddress,
      AFAddressFamily&lt;?&gt; af) throws SocketException {
    /*
     * Initializing the superclass with an unresolved hostname helps us pass the #equals and
     * #hashCode checks, which unfortunately are declared final in InetSocketAddress.
     *
     * Using a resolved address (with the address bit initialized) would be ideal, but resolved
     * addresses can only be IPv4 or IPv6 (at least as of Java 16 and earlier).
     */
<span class="fc bfc" id="L121" title="All 4 branches covered.">    super(AFInetAddress.createUnresolvedHostname(socketAddress, af), port &gt;= 0 &amp;&amp; port &lt;= 0xffff</span>
<span class="fc" id="L122">        ? port : 0);</span>
<span class="pc bpc" id="L123" title="1 of 2 branches missed.">    if (socketAddress.length == 0) {</span>
<span class="nc" id="L124">      throw new SocketException(&quot;Illegal address length: &quot; + socketAddress.length);</span>
    }

<span class="fc bfc" id="L127" title="All 2 branches covered.">    this.nativeAddress = nativeAddress == null ? null : (ByteBuffer) (Object) nativeAddress</span>
<span class="fc" id="L128">        .duplicate().rewind();</span>
<span class="fc bfc" id="L129" title="All 2 branches covered.">    if (port &lt; -1) {</span>
<span class="fc" id="L130">      throw new IllegalArgumentException(&quot;port out of range&quot;);</span>
<span class="fc bfc" id="L131" title="All 2 branches covered.">    } else if (port &gt; 0xffff) {</span>
<span class="pc bpc" id="L132" title="1 of 2 branches missed.">      if (!NativeUnixSocket.isLoaded()) {</span>
<span class="nc" id="L133">        throw (SocketException) new SocketException(</span>
<span class="nc" id="L134">            &quot;Cannot set SocketAddress port - junixsocket JNI library is not available&quot;).initCause(</span>
<span class="nc" id="L135">                NativeUnixSocket.unsupportedException());</span>
      }
<span class="fc" id="L137">      NativeUnixSocket.setPort1(this, port);</span>
    }

<span class="fc" id="L140">    this.bytes = socketAddress.clone();</span>
<span class="fc" id="L141">    this.addressFamily = af;</span>
<span class="fc" id="L142">  }</span>

  /**
   * Only for {@link SentinelSocketAddress}.
   *
   * @param clazz The {@link SentinelSocketAddress} class.
   * @param port A sentinel port number.
   */
  @SuppressWarnings(&quot;PMD.UnusedFormalParameter&quot;)
  AFSocketAddress(Class&lt;SentinelSocketAddress&gt; clazz, int port) {
<span class="fc" id="L152">    super(InetAddress.getLoopbackAddress(), port);</span>
<span class="fc" id="L153">    this.nativeAddress = null;</span>
<span class="fc" id="L154">    this.bytes = new byte[0];</span>
<span class="fc" id="L155">    this.addressFamily = null;</span>
<span class="fc" id="L156">  }</span>

  /**
   * Checks if the address can be resolved to a {@link File}.
   *
   * @return {@code true} if the address has a filename.
   */
  public abstract boolean hasFilename();

  /**
   * Returns the {@link File} corresponding with this address, if possible.
   *
   * A {@link FileNotFoundException} is thrown if there is no filename associated with the address,
   * which applies to addresses in the abstract namespace, for example.
   *
   * @return The filename.
   * @throws FileNotFoundException if the address is not associated with a filename.
   */
  public abstract File getFile() throws FileNotFoundException;

  /**
   * Returns the corresponding {@link AFAddressFamily}.
   *
   * @return The address family instance.
   */
  public final AFAddressFamily&lt;?&gt; getAddressFamily() {
<span class="fc" id="L182">    return addressFamily;</span>
  }

  /**
   * Wraps the socket name/peer name of a file descriptor as an {@link InetAddress}.
   *
   * @param fdesc The file descriptor.
   * @param peerName If {@code true}, the remote peer name (instead of the local name) is retrieved.
   * @param af The address family.
   * @return The {@link InetAddress}.
   */
  protected static final InetAddress getInetAddress(FileDescriptor fdesc, boolean peerName,
      AFAddressFamily&lt;?&gt; af) {
<span class="pc bpc" id="L195" title="1 of 2 branches missed.">    if (!fdesc.valid()) {</span>
<span class="nc" id="L196">      return null;</span>
    }
<span class="fc" id="L198">    byte[] addr = NativeUnixSocket.sockname(af.getDomain(), fdesc, peerName);</span>
<span class="fc bfc" id="L199" title="All 2 branches covered.">    if (addr == null) {</span>
<span class="fc" id="L200">      return null;</span>
    }
<span class="fc" id="L202">    return AFInetAddress.wrapAddress(addr, af);</span>
  }

  /**
   * Gets the socket name/peer name of a file descriptor as an {@link AFSocketAddress}.
   *
   * @param &lt;A&gt; The corresponding address type.
   * @param fdesc The file descriptor.
   * @param peerName If {@code true}, the remote peer name (instead of the local name) is retrieved.
   * @param port The port.
   * @param af The address family.
   * @return The {@link InetAddress}.
   */
  protected static final &lt;A extends AFSocketAddress&gt; @Nullable A getSocketAddress(
      FileDescriptor fdesc, boolean peerName, int port, AFAddressFamily&lt;A&gt; af) {
<span class="pc bpc" id="L217" title="1 of 2 branches missed.">    if (!fdesc.valid()) {</span>
<span class="nc" id="L218">      return null;</span>
    }
<span class="fc" id="L220">    byte[] addr = NativeUnixSocket.sockname(af.getDomain(), fdesc, peerName);</span>
<span class="fc bfc" id="L221" title="All 2 branches covered.">    if (addr == null) {</span>
<span class="fc" id="L222">      return null;</span>
    }
    try {
      // FIXME we could infer the &quot;port&quot; from the path if the socket factory supports that
<span class="fc" id="L226">      return AFSocketAddress.unwrap(AFInetAddress.wrapAddress(addr, af), port, af);</span>
<span class="nc" id="L227">    } catch (SocketException e) {</span>
<span class="nc" id="L228">      throw new IllegalStateException(e);</span>
    }
  }

  static final AFSocketAddress preprocessSocketAddress(
      Class&lt;? extends AFSocketAddress&gt; supportedAddressClass, SocketAddress endpoint,
      AFSocketAddressFromHostname&lt;?&gt; afh) throws SocketException {
<span class="fc" id="L235">    Objects.requireNonNull(endpoint);</span>
<span class="fc bfc" id="L236" title="All 2 branches covered.">    if (endpoint instanceof SentinelSocketAddress) {</span>
<span class="fc" id="L237">      return (SentinelSocketAddress) endpoint;</span>
    }

<span class="fc bfc" id="L240" title="All 2 branches covered.">    if (!(endpoint instanceof AFSocketAddress)) {</span>
<span class="fc bfc" id="L241" title="All 2 branches covered.">      if (afh != null) {</span>
<span class="pc bpc" id="L242" title="1 of 2 branches missed.">        if (endpoint instanceof InetSocketAddress) {</span>
<span class="fc" id="L243">          InetSocketAddress isa = (InetSocketAddress) endpoint;</span>

<span class="fc" id="L245">          String hostname = isa.getHostString();</span>
<span class="fc bfc" id="L246" title="All 2 branches covered.">          if (afh.isHostnameSupported(hostname)) {</span>
            try {
<span class="fc" id="L248">              endpoint = afh.addressFromHost(hostname, isa.getPort());</span>
<span class="fc" id="L249">            } catch (SocketException e) {</span>
<span class="fc" id="L250">              throw e;</span>
<span class="fc" id="L251">            }</span>
          }
        }
      }
    }

<span class="fc" id="L257">    Objects.requireNonNull(endpoint);</span>

<span class="fc bfc" id="L259" title="All 2 branches covered.">    if (!supportedAddressClass.isAssignableFrom(endpoint.getClass())) {</span>
<span class="fc" id="L260">      throw new IllegalArgumentException(&quot;Can only connect to endpoints of type &quot;</span>
<span class="fc" id="L261">          + supportedAddressClass.getName() + &quot;, got: &quot; + endpoint.getClass() + &quot;: &quot; + endpoint);</span>
    }

<span class="fc" id="L264">    return (AFSocketAddress) endpoint;</span>
  }

  /**
   * Returns the (non-native) byte-level representation of this address.
   *
   * @return The byte array.
   */
  protected final byte[] getBytes() {
<span class="fc" id="L273">    return bytes; // NOPMD</span>
  }

  /**
   * Returns a &quot;special&quot; {@link InetAddress} that contains information about this
   * {@link AFSocketAddress}.
   *
   * IMPORTANT: This {@link InetAddress} does not properly compare (using
   * {@link InetAddress#equals(Object)} and {@link InetAddress#hashCode()}). It should be used
   * exclusively to circumvent existing APIs like {@link DatagramSocket} that only accept/return
   * {@link InetAddress} and not arbitrary {@link SocketAddress} types.
   *
   * @return The &quot;special&quot; {@link InetAddress}.
   */
  public final InetAddress wrapAddress() {
<span class="fc" id="L288">    return AFInetAddress.wrapAddress(bytes, getAddressFamily());</span>
  }

  /**
   * A reference to the constructor of an AFSocketAddress subclass.
   *
   * @param &lt;T&gt; The actual subclass.
   * @author Christian Kohlschütter
   */
  @FunctionalInterface
  protected interface AFSocketAddressConstructor&lt;T extends AFSocketAddress&gt; {
    /**
     * Constructs a new AFSocketAddress instance.
     *
     * @param port The port.
     * @param socketAddress The socket address in junixsocket-specific byte-array representation.
     * @param nativeAddress The socket address in system-native representation.
     * @return The instance.
     * @throws SocketException on error.
     */
    @NonNull
    T newAFSocketAddress(int port, byte[] socketAddress, ByteBuffer nativeAddress)
        throws SocketException;
  }

  /**
   * Resolves a junixsocket-specific byte-array representation of an {@link AFSocketAddress} to an
   * actual {@link AFSocketAddress} instance, possibly reusing a cached instance.
   *
   * @param &lt;A&gt; The concrete {@link AFSocketAddress} that is supported by this type.
   * @param socketAddress The socket address in junixsocket-specific byte-array representation.
   * @param port The port.
   * @param af The address family.
   * @return The instance.
   * @throws SocketException on error.
   */
  @SuppressWarnings({&quot;unchecked&quot;, &quot;null&quot;})
  protected static final &lt;A extends AFSocketAddress&gt; A resolveAddress(final byte[] socketAddress,
      int port, AFAddressFamily&lt;A&gt; af) throws SocketException {
<span class="fc bfc" id="L327" title="All 2 branches covered.">    if (socketAddress.length == 0) {</span>
<span class="fc" id="L328">      throw new SocketException(&quot;Address cannot be empty&quot;);</span>
    }

<span class="fc bfc" id="L331" title="All 2 branches covered.">    if (port == -1) {</span>
<span class="fc" id="L332">      port = 0;</span>
    }

<span class="fc" id="L335">    ByteBuffer direct = SOCKETADDRESS_BUFFER_TL.get();</span>
<span class="pc bpc" id="L336" title="1 of 2 branches missed.">    int limit = NativeUnixSocket.isLoaded() ? NativeUnixSocket.bytesToSockAddr(af.getDomain(),</span>
<span class="pc" id="L337">        direct, socketAddress) : -1;</span>
<span class="fc bfc" id="L338" title="All 2 branches covered.">    if (limit == -1) {</span>
      // not supported, but we can still create an address
<span class="fc" id="L340">      return af.getAddressConstructor().newAFSocketAddress(port, socketAddress, null);</span>
<span class="pc bpc" id="L341" title="1 of 2 branches missed.">    } else if (limit &gt; SOCKADDR_MAX_LEN) {</span>
<span class="nc" id="L342">      throw new IllegalStateException(&quot;Unexpected address length&quot;);</span>
    }
<span class="fc" id="L344">    direct.rewind();</span>
<span class="fc" id="L345">    direct.limit(limit);</span>

    A instance;
<span class="fc" id="L348">    synchronized (AFSocketAddress.class) {</span>
      Map&lt;ByteBuffer, AFSocketAddress&gt; map;
<span class="fc" id="L350">      Map&lt;Integer, Map&lt;ByteBuffer, AFSocketAddress&gt;&gt; mapPorts = ADDRESS_CACHE.get(af);</span>
<span class="fc bfc" id="L351" title="All 2 branches covered.">      if (mapPorts == null) {</span>
<span class="fc" id="L352">        instance = null;</span>
<span class="fc" id="L353">        mapPorts = new HashMap&lt;&gt;();</span>
<span class="fc" id="L354">        map = new HashMap&lt;&gt;();</span>
<span class="fc" id="L355">        mapPorts.put(port, map);</span>
<span class="fc" id="L356">        ADDRESS_CACHE.put(af, mapPorts);</span>
      } else {
<span class="fc" id="L358">        map = mapPorts.get(port);</span>
<span class="fc bfc" id="L359" title="All 2 branches covered.">        if (map == null) {</span>
<span class="fc" id="L360">          instance = null;</span>
<span class="fc" id="L361">          map = new HashMap&lt;&gt;();</span>
<span class="fc" id="L362">          mapPorts.put(port, map);</span>
        } else {
<span class="fc" id="L364">          instance = (A) map.get(direct);</span>
        }
      }

<span class="pc bpc" id="L368" title="1 of 2 branches missed.">      if (instance == null) {</span>
<span class="fc" id="L369">        ByteBuffer key = newSockAddrKeyBuffer(limit);</span>
<span class="fc" id="L370">        key.put(direct);</span>
<span class="fc" id="L371">        key = key.asReadOnlyBuffer();</span>

<span class="fc" id="L373">        instance = af.getAddressConstructor().newAFSocketAddress(port, socketAddress, key);</span>

<span class="fc" id="L375">        map.put(key, instance);</span>
      }
<span class="fc" id="L377">    }</span>

<span class="fc" id="L379">    return instance;</span>
  }

  @SuppressWarnings(&quot;null&quot;)
  static final &lt;A extends AFSocketAddress&gt; A ofInternal(ByteBuffer socketAddressBuffer,
      AFAddressFamily&lt;A&gt; af) throws SocketException {
<span class="fc" id="L385">    synchronized (AFSocketAddress.class) {</span>
<span class="fc" id="L386">      Map&lt;Integer, Map&lt;ByteBuffer, AFSocketAddress&gt;&gt; mapPorts = ADDRESS_CACHE.get(af);</span>
<span class="pc bpc" id="L387" title="1 of 2 branches missed.">      if (mapPorts != null) {</span>
<span class="fc" id="L388">        Map&lt;ByteBuffer, AFSocketAddress&gt; map = mapPorts.get(0); // FIXME get port, something like</span>
                                                                // sockAddrToPort
<span class="pc bpc" id="L390" title="1 of 2 branches missed.">        if (map != null) {</span>
          @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L392">          A address = (A) map.get(socketAddressBuffer.rewind());</span>
<span class="pc bpc" id="L393" title="1 of 2 branches missed.">          if (address != null) {</span>
<span class="nc" id="L394">            return address;</span>
          }
        }
      }

<span class="pc bpc" id="L399" title="1 of 2 branches missed.">      if (!socketAddressBuffer.isDirect()) {</span>
<span class="nc" id="L400">        ByteBuffer buf = getNativeAddressDirectBuffer(Math.min(socketAddressBuffer.limit(),</span>
            SOCKADDR_MAX_LEN));
<span class="nc" id="L402">        buf.put(socketAddressBuffer);</span>
<span class="nc" id="L403">        socketAddressBuffer = buf;</span>
      }
<span class="fc" id="L405">      byte[] sockAddrToBytes = NativeUnixSocket.sockAddrToBytes(af.getDomain(),</span>
          socketAddressBuffer);
<span class="pc bpc" id="L407" title="1 of 2 branches missed.">      if (sockAddrToBytes == null) {</span>
<span class="nc" id="L408">        return null;</span>
      } else {
<span class="fc" id="L410">        return AFSocketAddress.resolveAddress(sockAddrToBytes, 0, af);</span>
      }
    }
  }

  /**
   * Wraps an address as an {@link InetAddress}.
   *
   * @param af The address family.
   * @return The {@link InetAddress}.
   */
  protected final synchronized InetAddress getInetAddress(AFAddressFamily&lt;?&gt; af) {
<span class="pc bpc" id="L422" title="1 of 2 branches missed.">    if (inetAddress == null) {</span>
<span class="fc" id="L423">      inetAddress = AFInetAddress.wrapAddress(bytes, af);</span>
    }
<span class="fc" id="L425">    return inetAddress;</span>
  }

  /**
   * Wraps this address as an {@link InetAddress}.
   *
   * @return The {@link InetAddress}.
   */
  protected final InetAddress getInetAddress() {
<span class="fc" id="L434">    return getInetAddress(getAddressFamily());</span>
  }

  static final ByteBuffer newSockAddrDirectBuffer(int length) {
<span class="fc" id="L438">    return ByteBuffer.allocateDirect(length);</span>
  }

  static final ByteBuffer newSockAddrKeyBuffer(int length) {
<span class="fc" id="L442">    return ByteBuffer.allocate(length);</span>
  }

  /**
   * Returns an {@link AFSocketAddress} given a special {@link InetAddress} that encodes the byte
   * sequence of an AF_UNIX etc. socket address, like those returned by {@link #wrapAddress()}.
   *
   * @param &lt;A&gt; The corresponding address type.
   * @param address The &quot;special&quot; {@link InetAddress}.
   * @param port The port (use 0 for &quot;none&quot;).
   * @param af The address family.
   * @return The {@link AFSocketAddress} instance.
   * @throws SocketException if the operation fails, for example when an unsupported address is
   *           specified.
   */
  @SuppressWarnings(&quot;null&quot;)
  @NonNull
  protected static final &lt;A extends AFSocketAddress&gt; A unwrap(InetAddress address, int port,
      AFAddressFamily&lt;A&gt; af) throws SocketException {
<span class="fc" id="L461">    Objects.requireNonNull(address);</span>
<span class="fc" id="L462">    return resolveAddress(AFInetAddress.unwrapAddress(address, af), port, af);</span>
  }

  /**
   * Returns an {@link AFSocketAddress} given a special {@link InetAddress} hostname that encodes
   * the byte sequence of an AF_UNIX etc. socket address, like those returned by
   * {@link #wrapAddress()}.
   *
   * @param &lt;A&gt; The corresponding address type.
   * @param hostname The &quot;special&quot; hostname, as provided by {@link InetAddress#getHostName()}.
   * @param port The port (use 0 for &quot;none&quot;).
   * @param af The address family.
   * @return The {@link AFSocketAddress} instance.
   * @throws SocketException if the operation fails, for example when an unsupported address is
   *           specified.
   */
  @SuppressWarnings(&quot;null&quot;)
  @NonNull
  protected static final &lt;A extends AFSocketAddress&gt; A unwrap(String hostname, int port,
      AFAddressFamily&lt;A&gt; af) throws SocketException {
<span class="nc" id="L482">    Objects.requireNonNull(hostname);</span>
<span class="nc" id="L483">    return resolveAddress(AFInetAddress.unwrapAddress(hostname, af), port, af);</span>
  }

  static final int unwrapAddressDirectBufferInternal(ByteBuffer socketAddressBuffer,
      SocketAddress address) throws SocketException {
<span class="nc bnc" id="L488" title="All 2 branches missed.">    if (!NativeUnixSocket.isLoaded()) {</span>
<span class="nc" id="L489">      throw new SocketException(&quot;Unsupported operation; junixsocket native library is not loaded&quot;);</span>
    }
<span class="nc" id="L491">    Objects.requireNonNull(address);</span>

<span class="nc bnc" id="L493" title="All 2 branches missed.">    if (!(address instanceof AFSocketAddress)) {</span>
<span class="nc" id="L494">      Supplier&lt;? extends AFSocketAddress&gt; supp = AFUNIXSocketAddress.supportedAddressSupplier(</span>
          address);
<span class="nc bnc" id="L496" title="All 2 branches missed.">      address = supp == null ? null : supp.get();</span>
<span class="nc bnc" id="L497" title="All 2 branches missed.">      if (address == null) {</span>
<span class="nc" id="L498">        throw new SocketException(&quot;Unsupported address&quot;);</span>
      }
    }

<span class="nc" id="L502">    AFSocketAddress socketAddress = (AFSocketAddress) address;</span>

<span class="nc" id="L504">    byte[] addr = socketAddress.getBytes();</span>
<span class="nc" id="L505">    int domain = socketAddress.getAddressFamily().getDomain();</span>

<span class="nc" id="L507">    int len = NativeUnixSocket.bytesToSockAddr(domain, socketAddressBuffer, addr);</span>
<span class="nc bnc" id="L508" title="All 2 branches missed.">    if (len == -1) {</span>
<span class="nc" id="L509">      throw new SocketException(&quot;Unsupported domain&quot;);</span>
    }
<span class="nc" id="L511">    return len;</span>
  }

  /**
   * Returns a thread-local direct ByteBuffer containing the native socket address representation of
   * this {@link AFSocketAddress}.
   *
   * @return The direct {@link ByteBuffer}.
   */
  final ByteBuffer getNativeAddressDirectBuffer() throws SocketException {
<span class="fc" id="L521">    ByteBuffer address = nativeAddress;</span>
<span class="pc bpc" id="L522" title="1 of 2 branches missed.">    if (address == null) {</span>
<span class="nc" id="L523">      throw (SocketException) new SocketException(&quot;Cannot access native address&quot;).initCause(</span>
<span class="nc" id="L524">          NativeUnixSocket.unsupportedException());</span>
    }

<span class="fc" id="L527">    ByteBuffer direct = getNativeAddressDirectBuffer(address.limit());</span>
<span class="fc" id="L528">    address.position(0);</span>
<span class="fc" id="L529">    direct.put(address);</span>

<span class="fc" id="L531">    return direct;</span>
  }

  static final ByteBuffer getNativeAddressDirectBuffer(int limit) {
<span class="fc" id="L535">    ByteBuffer direct = SOCKETADDRESS_BUFFER_TL.get();</span>
<span class="fc" id="L536">    direct.position(0);</span>
<span class="fc" id="L537">    direct.limit(limit);</span>
<span class="fc" id="L538">    return direct;</span>
  }

  /**
   * Checks if the given address is supported by this address family.
   *
   * @param addr The address.
   * @param af The address family.
   * @return {@code true} if supported.
   */
  protected static final boolean isSupportedAddress(InetAddress addr, AFAddressFamily&lt;?&gt; af) {
<span class="nc" id="L549">    return AFInetAddress.isSupportedAddress(addr, af);</span>
  }

  /**
   * Writes the native (system-level) representation of this address to the given buffer.
   *
   * The position of the target buffer will be at the end (i.e., after) the written data.
   *
   * @param buf The target buffer.
   * @throws IOException on error.
   */
  public final void writeNativeAddressTo(ByteBuffer buf) throws IOException {
<span class="nc bnc" id="L561" title="All 2 branches missed.">    if (nativeAddress == null) {</span>
<span class="nc" id="L562">      throw (SocketException) new SocketException(&quot;Cannot access native address&quot;).initCause(</span>
<span class="nc" id="L563">          NativeUnixSocket.unsupportedException());</span>
    }
<span class="nc" id="L565">    buf.put(nativeAddress);</span>
<span class="nc" id="L566">  }</span>

  /**
   * Creates a new socket connected to this address.
   *
   * @return The socket instance.
   * @throws IOException on error.
   */
  public AFSocket&lt;?&gt; newConnectedSocket() throws IOException {
<span class="nc" id="L575">    AFSocket&lt;?&gt; socket = getAddressFamily().newSocket();</span>
<span class="nc" id="L576">    socket.connect(this);</span>
<span class="nc" id="L577">    return socket;</span>
  }

  /**
   * Creates a new server socket bound to this address.
   *
   * @return The server socket instance.
   * @throws IOException on error.
   */
  public AFServerSocket&lt;?&gt; newBoundServerSocket() throws IOException {
<span class="nc" id="L587">    AFServerSocket&lt;?&gt; serverSocket = getAddressFamily().newServerSocket();</span>
<span class="nc" id="L588">    serverSocket.bind(this);</span>
<span class="nc" id="L589">    return serverSocket;</span>
  }

  /**
   * Creates a new server socket force-bound to this address (i.e., any additional call to
   * {@link ServerSocket#bind(SocketAddress)} will ignore the passed address and use this one
   * instead.
   *
   * @return The server socket instance.
   * @throws IOException on error.
   */
  public AFServerSocket&lt;?&gt; newForceBoundServerSocket() throws IOException {
<span class="nc" id="L601">    AFServerSocket&lt;?&gt; serverSocket = getAddressFamily().newServerSocket();</span>
<span class="nc" id="L602">    serverSocket.forceBindAddress(this).bind(this);</span>
<span class="nc" id="L603">    return serverSocket;</span>
  }

  /**
   * Tries to parse the given URI and return a corresponding {@link AFSocketAddress} for it.
   *
   * NOTE: Only certain URI schemes are supported, such as {@code unix://} (for
   * {@link AFUNIXSocketAddress}) and {@code tipc://} for {@link AFTIPCSocketAddress}.
   *
   * @param u The URI.
   * @return The address.
   * @throws SocketException on error.
   * @see AFAddressFamily#uriSchemes()
   */
  @SuppressWarnings(&quot;PMD.ShortMethodName&quot;)
  public static AFSocketAddress of(URI u) throws SocketException {
<span class="fc" id="L619">    return of(u, -1);</span>
  }

  /**
   * Tries to parse the given URI and return a corresponding {@link AFSocketAddress} for it.
   *
   * NOTE: Only certain URI schemes are supported, such as {@code unix://} (for
   * {@link AFUNIXSocketAddress}) and {@code tipc://} for {@link AFTIPCSocketAddress}.
   *
   * @param u The URI.
   * @param overridePort The port to forcibly use, or {@code -1} for &quot;don't override&quot;.
   * @return The address.
   * @throws SocketException on error.
   * @see AFAddressFamily#uriSchemes()
   */
  @SuppressWarnings(&quot;PMD.ShortMethodName&quot;)
  public static AFSocketAddress of(URI u, int overridePort) throws SocketException {
<span class="fc" id="L636">    AFAddressFamily&lt;?&gt; af = AFAddressFamily.getAddressFamily(u);</span>
<span class="pc bpc" id="L637" title="1 of 2 branches missed.">    if (af == null) {</span>
<span class="nc" id="L638">      throw new SocketException(&quot;Cannot resolve AFSocketAddress from URI scheme: &quot; + u.getScheme());</span>
    }
<span class="fc" id="L640">    return af.parseURI(u, overridePort);</span>
  }

  /**
   * Tries to create a URI based on this {@link AFSocketAddress}.
   *
   * @param scheme The target scheme.
   * @param template An optional template to reuse certain parameters (e.g., the &quot;path&quot; component
   *          for an {@code http} request), or {@code null}.
   * @return The URI.
   * @throws IOException on error.
   */
  public URI toURI(String scheme, URI template) throws IOException {
<span class="nc" id="L653">    throw new IOException(&quot;Unsupported operation&quot;);</span>
  }

  /**
   * Returns a address string that can be used with {@code socat}'s {@code SOCKET-CONNECT},
   * {@code SOCKET-LISTEN}, {@code SOCKET-DATAGRAM}, etc., address types, or {@code null} if the
   * address type is not natively supported by this platform.
   *
   * This call is mostly suited for debugging purposes. The resulting string is specific to the
   * platform the code is executed on, and thus may be different among platforms.
   *
   * @param socketType The socket type, or {@code null} to omit from string.
   * @param socketProtocol The socket protocol, or {@code null} to omit from string.
   * @return The string (such as 1:0:x2f746d702f796f).
   * @throws IOException on error (a {@link SocketException} is thrown if the native address cannot
   *           be accessed).
   */
  public @Nullable @SuppressWarnings(&quot;PMD.NPathComplexity&quot;) String toSocatAddressString(
      AFSocketType socketType, AFSocketProtocol socketProtocol) throws IOException {

<span class="pc bpc" id="L673" title="2 of 4 branches missed.">    if (SOCKADDR_NATIVE_FAMILY_OFFSET == -1 || SOCKADDR_NATIVE_DATA_OFFSET == -1) {</span>
<span class="nc" id="L674">      return null;</span>
    }
<span class="fc bfc" id="L676" title="All 2 branches covered.">    if (nativeAddress == null) {</span>
<span class="fc" id="L677">      throw (SocketException) new SocketException(&quot;Cannot access native address&quot;).initCause(</span>
<span class="fc" id="L678">          NativeUnixSocket.unsupportedException());</span>
    }
<span class="pc bpc" id="L680" title="2 of 4 branches missed.">    if (socketProtocol != null &amp;&amp; socketProtocol.getId() != 0) {</span>
<span class="nc" id="L681">      throw new IOException(&quot;Protocol not (yet) supported&quot;); // FIXME support additional protocols</span>
    }

<span class="fc" id="L684">    int family = (nativeAddress.get(SOCKADDR_NATIVE_FAMILY_OFFSET) &amp; 0xFF);</span>
<span class="fc bfc" id="L685" title="All 2 branches covered.">    int type = socketType == null ? -1 : NativeUnixSocket.sockTypeToNative(socketType.getId());</span>
<span class="fc" id="L686">    StringBuilder sb = new StringBuilder();</span>
<span class="fc" id="L687">    sb.append(family);</span>
<span class="fc bfc" id="L688" title="All 2 branches covered.">    if (type != -1) {</span>
<span class="fc" id="L689">      sb.append(':');</span>
<span class="fc" id="L690">      sb.append(type);</span>
    }
<span class="pc bpc" id="L692" title="1 of 2 branches missed.">    if (socketProtocol != null) {</span>
<span class="fc" id="L693">      sb.append(':');</span>
<span class="fc" id="L694">      sb.append(socketProtocol.getId()); // FIXME needs native conversion</span>
    }
<span class="fc" id="L696">    sb.append(&quot;:x&quot;);</span>
<span class="fc" id="L697">    int n = nativeAddress.limit();</span>
<span class="pc bpc" id="L698" title="1 of 4 branches missed.">    while (n &gt; 1 &amp;&amp; nativeAddress.get(n - 1) == 0) {</span>
<span class="fc" id="L699">      n--;</span>
    }
<span class="fc bfc" id="L701" title="All 2 branches covered.">    for (int pos = SOCKADDR_NATIVE_DATA_OFFSET; pos &lt; n; pos++) {</span>
<span class="fc" id="L702">      byte b = nativeAddress.get(pos);</span>
<span class="fc" id="L703">      sb.append(String.format(Locale.ENGLISH, &quot;%02x&quot;, b));</span>
    }
<span class="fc" id="L705">    return sb.toString();</span>
  }

  /**
   * Checks if the given address could cover another address.
   *
   * By default, this is only true if both addresses are regarded equal using
   * {@link #equals(Object)}.
   *
   * However, implementations may support &quot;wildcard&quot; addresses, and this method would compare a
   * wildcard address against some non-wildcard address, for example.
   *
   * @param other The other address that could be covered by this address.
   * @return {@code true} if the other address could be covered.
   */
  public boolean covers(AFSocketAddress other) {
<span class="nc" id="L721">    return this.equals(other);</span>
  }

  /**
   * Custom serialization: Reference {@link AFAddressFamily} instance by identifier string.
   *
   * @param in The {@link ObjectInputStream}.
   * @throws ClassNotFoundException on error.
   * @throws IOException on error.
   */
  private void readObject(ObjectInputStream in) throws ClassNotFoundException, IOException {
<span class="fc" id="L732">    in.defaultReadObject();</span>
<span class="fc" id="L733">    this.addressFamily = Objects.requireNonNull(AFAddressFamily.getAddressFamily(in.readUTF()),</span>
        &quot;address family&quot;);
<span class="fc" id="L735">  }</span>

  /**
   * Custom serialization: Reference {@link AFAddressFamily} instance by identifier string.
   *
   * @param out The {@link ObjectOutputStream}.
   * @throws IOException on error.
   */
  private void writeObject(ObjectOutputStream out) throws IOException {
<span class="fc" id="L744">    out.defaultWriteObject();</span>
<span class="fc" id="L745">    out.writeUTF(addressFamily.getJuxString());</span>
<span class="fc" id="L746">  }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.10.202304240956</span></div></body></html>