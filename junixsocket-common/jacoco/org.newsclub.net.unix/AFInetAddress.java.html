<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AFInetAddress.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">junixsocket-common</a> &gt; <a href="index.source.html" class="el_package">org.newsclub.net.unix</a> &gt; <span class="el_source">AFInetAddress.java</span></div><h1>AFInetAddress.java</h1><pre class="source lang-java linenums">/*
 * junixsocket
 *
 * Copyright 2009-2024 Christian Kohlschütter
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.newsclub.net.unix;

import java.io.UnsupportedEncodingException;
import java.net.DatagramPacket;
import java.net.Inet4Address;
import java.net.InetAddress;
import java.net.InetSocketAddress;
import java.net.SocketAddress;
import java.net.SocketException;
import java.net.URLDecoder;
import java.net.URLEncoder;
import java.net.UnknownHostException;
import java.nio.charset.StandardCharsets;
import java.util.Locale;
import java.util.Objects;

/**
 * A workaround to create an {@link InetAddress} for an {@link AFSocketAddress}.
 *
 * {@link DatagramPacket} internally requires InetAddress compatibility. Even if it pretends to
 * accept {@link SocketAddress}es, it refuses anything other than {@link InetSocketAddress}
 * &lt;em&gt;and&lt;/em&gt; then even stores host and port separately.
 *
 * This implementation deserializes a specially crafted {@link InetAddress} with a hostname that
 * encodes the raw bytes of an {@link AFSocketAddress}. We do this because the deserialization code
 * path does not attempt DNS resolution (which would fail one way or another).
 *
 * The hostnames we use end with &quot;.junixsocket&quot;, to distinguish them from regular hostnames.
 *
 * @author Christian Kohlschütter
 */
<span class="nc" id="L49">class AFInetAddress {</span>
<span class="fc" id="L50">  private static final byte[] LOCAL_AF = {0x7f, 0, 0, (byte) 0xaf};</span>

  private static final char PREFIX = '[';
  private static final String MARKER_HEX_ENCODING = &quot;%%&quot;;
  static final String INETADDR_SUFFIX = &quot;.junixsocket&quot;;

  /**
   * Encodes a junixsocket socketAddress into a string that is (somewhat) guaranteed to not be
   * resolved by java.net code.
   *
   * Implementation detail: The &quot;[&quot; prefix (with the corresponding &quot;]&quot; suffix missing from the
   * input) should cause an early {@link UnknownHostException} be thrown, which is caught within
   * {@link InetSocketAddress#InetSocketAddress(String, int)}, causing the hostname be marked as
   * &quot;unresolved&quot; (without an address set).
   *
   * @param socketAddress The socket address.
   * @return A string, to be used when calling
   *         {@link InetSocketAddress#InetSocketAddress(String, int)}, etc.
   */
  static final String createUnresolvedHostname(byte[] socketAddress, AFAddressFamily&lt;?&gt; af) {
<span class="fc" id="L70">    StringBuilder sb = new StringBuilder(1 + socketAddress.length + INETADDR_SUFFIX.length() + 8);</span>
<span class="fc" id="L71">    sb.append(PREFIX);</span>
    try {
<span class="fc" id="L73">      sb.append(URLEncoder.encode(new String(socketAddress, StandardCharsets.ISO_8859_1),</span>
<span class="fc" id="L74">          StandardCharsets.ISO_8859_1.toString()));</span>
<span class="nc" id="L75">    } catch (UnsupportedEncodingException e) {</span>
<span class="nc" id="L76">      throw new IllegalStateException(e);</span>
<span class="fc" id="L77">    }</span>
<span class="fc" id="L78">    sb.append('.');</span>
<span class="fc" id="L79">    sb.append(af.getJuxString());</span>
<span class="fc" id="L80">    sb.append(INETADDR_SUFFIX);</span>

<span class="fc" id="L82">    String str = sb.toString();</span>

<span class="pc bpc" id="L84" title="1 of 4 branches missed.">    if (str.length() &lt; 64 || str.getBytes(StandardCharsets.UTF_8).length &lt;= 255) {</span>
<span class="fc" id="L85">      return str;</span>
    }

<span class="nc" id="L88">    sb.setLength(0);</span>
<span class="nc" id="L89">    sb.append(PREFIX);</span>
<span class="nc" id="L90">    sb.append(MARKER_HEX_ENCODING);</span>
<span class="nc bnc" id="L91" title="All 2 branches missed.">    for (int i = 0, n = socketAddress.length; i &lt; n; i++) {</span>
<span class="nc" id="L92">      sb.append(String.format(Locale.ENGLISH, &quot;%02x&quot;, socketAddress[i]));</span>
    }

<span class="nc" id="L95">    sb.append('.');</span>
<span class="nc" id="L96">    sb.append(af.getJuxString());</span>
<span class="nc" id="L97">    sb.append(INETADDR_SUFFIX);</span>
<span class="nc" id="L98">    return sb.toString();</span>
  }

  /**
   * Creates an InetAddress that is considered &quot;resolved&quot; internally (using a static loopback
   * address), without actually having to resolve the address via DNS, thus still carrying the
   * &quot;hostname&quot; field containing a hostname as returned by
   * {@link #createUnresolvedHostname(byte[],AFAddressFamily)}.
   *
   * @param socketAddress The socket address.
   * @return The {@link InetAddress}.
   */
  static final InetAddress wrapAddress(byte[] socketAddress, AFAddressFamily&lt;?&gt; af) {
<span class="fc" id="L111">    Objects.requireNonNull(af);</span>
<span class="pc bpc" id="L112" title="2 of 4 branches missed.">    if (socketAddress == null || socketAddress.length == 0) {</span>
<span class="nc" id="L113">      return null;</span>
    }

<span class="fc" id="L116">    String hostname = createUnresolvedHostname(socketAddress, af);</span>
<span class="fc" id="L117">    byte[] bytes = hostname.getBytes(StandardCharsets.UTF_8);</span>
<span class="pc bpc" id="L118" title="1 of 2 branches missed.">    if (bytes.length &gt; 255) {</span>
<span class="nc" id="L119">      throw new IllegalStateException(&quot;junixsocket address is too long to wrap as InetAddress&quot;);</span>
    }

    try {
<span class="fc" id="L123">      return InetAddress.getByAddress(hostname, LOCAL_AF);</span>
<span class="nc" id="L124">    } catch (UnknownHostException e) {</span>
<span class="nc" id="L125">      throw new IllegalStateException(e);</span>
    }
  }

  static final byte[] unwrapAddress(InetAddress addr, AFAddressFamily&lt;?&gt; af)
      throws SocketException {
<span class="fc" id="L131">    Objects.requireNonNull(addr);</span>

<span class="pc bpc" id="L133" title="1 of 2 branches missed.">    if (!isSupportedAddress(addr, af)) {</span>
<span class="nc" id="L134">      throw new SocketException(&quot;Unsupported address&quot;);</span>
    }

<span class="fc" id="L137">    String hostname = addr.getHostName();</span>
    try {
<span class="fc" id="L139">      return unwrapAddress(hostname, af);</span>
<span class="nc" id="L140">    } catch (IllegalArgumentException e) {</span>
<span class="nc" id="L141">      throw (SocketException) new SocketException(&quot;Unsupported address&quot;).initCause(e);</span>
    }
  }

  static final byte[] unwrapAddress(String hostname, AFAddressFamily&lt;?&gt; af) throws SocketException {
<span class="fc" id="L146">    Objects.requireNonNull(hostname);</span>
<span class="pc bpc" id="L147" title="1 of 2 branches missed.">    if (!hostname.endsWith(INETADDR_SUFFIX)) {</span>
<span class="nc" id="L148">      throw new SocketException(&quot;Unsupported address&quot;);</span>
    }

<span class="fc" id="L151">    final int end = hostname.length() - INETADDR_SUFFIX.length();</span>
    char c;
<span class="fc" id="L153">    int domDot = -1;</span>
<span class="pc bpc" id="L154" title="1 of 2 branches missed.">    for (int i = end - 1; i &gt;= 0; i--) {</span>
<span class="fc" id="L155">      c = hostname.charAt(i);</span>
<span class="fc bfc" id="L156" title="All 2 branches covered.">      if (c == '.') {</span>
<span class="fc" id="L157">        domDot = i;</span>
<span class="fc" id="L158">        break;</span>
      }
    }

<span class="fc" id="L162">    String juxString = hostname.substring(domDot + 1, end);</span>
<span class="pc bpc" id="L163" title="1 of 2 branches missed.">    if (AFAddressFamily.getAddressFamily(juxString) != af) { // NOPMD</span>
<span class="nc" id="L164">      throw new SocketException(&quot;Incompatible address&quot;);</span>
    }

<span class="fc" id="L167">    String encodedHostname = hostname.substring(1, domDot);</span>
<span class="pc bpc" id="L168" title="1 of 2 branches missed.">    if (encodedHostname.startsWith(MARKER_HEX_ENCODING)) {</span>
      // Hex-only encoding
<span class="nc" id="L170">      int len = encodedHostname.length();</span>
<span class="nc bnc" id="L171" title="All 2 branches missed.">      if ((len &amp; 1) == 1) {</span>
<span class="nc" id="L172">        throw new IllegalStateException(&quot;Length of hex-encoded wrapping must be even&quot;);</span>
      }
<span class="nc" id="L174">      byte[] unwrapped = new byte[(len - 2) / 2];</span>
<span class="nc bnc" id="L175" title="All 2 branches missed.">      for (int i = 2, n = encodedHostname.length(), o = 0; i &lt; n; i += 2, o++) {</span>
<span class="nc" id="L176">        int v = Integer.parseInt(encodedHostname.substring(i, i + 2), 16);</span>
<span class="nc" id="L177">        unwrapped[o] = (byte) (v &amp; 0xFF);</span>
      }
<span class="nc" id="L179">      return unwrapped;</span>
    } else {
      // URL-encoding
      try {
<span class="fc" id="L183">        return URLDecoder.decode(encodedHostname, StandardCharsets.ISO_8859_1.toString()).getBytes(</span>
            StandardCharsets.ISO_8859_1);
<span class="nc" id="L185">      } catch (UnsupportedEncodingException e) {</span>
<span class="nc" id="L186">        throw new IllegalStateException(e);</span>
      }
    }
  }

  static boolean isSupportedAddress(InetAddress addr, AFAddressFamily&lt;?&gt; af) {
<span class="pc bpc" id="L192" title="1 of 4 branches missed.">    if (addr instanceof Inet4Address &amp;&amp; addr.isLoopbackAddress()) {</span>
<span class="fc" id="L193">      String hostname = addr.getHostName();</span>
<span class="fc" id="L194">      return hostname.endsWith(af.getJuxInetAddressSuffix());</span>
    }
<span class="fc" id="L196">    return false;</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>