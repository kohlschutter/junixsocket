<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AFSocket.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">junixsocket-common</a> &gt; <a href="index.source.html" class="el_package">org.newsclub.net.unix</a> &gt; <span class="el_source">AFSocket.java</span></div><h1>AFSocket.java</h1><pre class="source lang-java linenums">/*
 * junixsocket
 *
 * Copyright 2009-2024 Christian Kohlschütter
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.newsclub.net.unix;

import java.io.Closeable;
import java.io.FileDescriptor;
import java.io.IOException;
import java.net.Socket;
import java.net.SocketAddress;
import java.net.SocketException;
import java.net.SocketImpl;
import java.util.concurrent.atomic.AtomicBoolean;

import org.eclipse.jdt.annotation.NonNull;
import org.eclipse.jdt.annotation.Nullable;

import com.kohlschutter.annotations.compiletime.SuppressFBWarnings;

/**
 * junixsocket's base implementation of a {@link Socket}.
 *
 * @param &lt;A&gt; The concrete {@link AFSocketAddress} that is supported by this type.
 * @author Christian Kohlschütter
 */
@SuppressWarnings({&quot;PMD.CouplingBetweenObjects&quot;, &quot;PMD.CyclomaticComplexity&quot;})
public abstract class AFSocket&lt;A extends AFSocketAddress&gt; extends Socket implements AFSomeSocket,
    AFSocketExtensions {
  static final String PROP_LIBRARY_DISABLE_CAPABILITY_PREFIX =
      &quot;org.newsclub.net.unix.library.disable.&quot;;

<span class="fc" id="L46">  private static final byte[] ZERO_BYTES = new byte[0];</span>

  @SuppressWarnings(&quot;PMD.MutableStaticState&quot;)
  static String loadedLibrary; // set by NativeLibraryLoader

<span class="fc" id="L51">  private static Integer capabilitiesValue = null;</span>

  private final AFSocketImpl&lt;A&gt; impl;

  private final AFSocketAddressFromHostname&lt;A&gt; afh;
<span class="fc" id="L56">  private final Closeables closeables = new Closeables();</span>
<span class="fc" id="L57">  private final AtomicBoolean created = new AtomicBoolean(false);</span>

<span class="fc" id="L59">  @SuppressWarnings(&quot;this-escape&quot;)</span>
<span class="fc" id="L60">  private final AFSocketChannel&lt;A&gt; channel = newChannel();</span>

  private @Nullable SocketAddressFilter connectFilter;

  /**
   * Creates a new {@link AFSocket} instance.
   *
   * @param impl The corresponding {@link SocketImpl} class.
   * @param afh The conversion helper to get a socket address from an encoded hostname.
   * @throws SocketException on error.
   */
  @SuppressFBWarnings(&quot;CT_CONSTRUCTOR_THROW&quot;)
  protected AFSocket(final AFSocketImpl&lt;A&gt; impl, AFSocketAddressFromHostname&lt;A&gt; afh)
      throws SocketException {
<span class="fc" id="L74">    super(impl);</span>
<span class="fc" id="L75">    this.afh = afh;</span>
<span class="fc" id="L76">    this.impl = impl;</span>
<span class="fc" id="L77">  }</span>

  /**
   * Returns the {@link AFSocketAddress} type supported by this socket.
   *
   * @return The supported {@link AFSocketAddress}.
   */
  protected final Class&lt;? extends AFSocketAddress&gt; socketAddressClass() {
<span class="fc" id="L85">    return getAFImpl(false).getAddressFamily().getSocketAddressClass();</span>
  }

  /**
   * Creates a new {@link AFSocketChannel} for this socket.
   *
   * @return The new instance.
   */
  protected abstract AFSocketChannel&lt;A&gt; newChannel();

  /**
   * The reference to the constructor of an {@link AFSocket} subclass.
   *
   * @param &lt;A&gt; The concrete {@link AFSocketAddress} that is supported by this type.
   */
  @FunctionalInterface
  public interface Constructor&lt;A extends AFSocketAddress&gt; {
    /**
     * Constructs a new {@link AFSocket} subclass instance.
     *
     * @param fdObj The file descriptor.
     * @param factory The socket factory instance.
     * @return The instance.
     * @throws SocketException on error.
     */
    @NonNull
    AFSocket&lt;A&gt; newInstance(FileDescriptor fdObj, AFSocketFactory&lt;A&gt; factory)
        throws SocketException;
  }

  static &lt;A extends AFSocketAddress&gt; AFSocket&lt;A&gt; newInstance(Constructor&lt;A&gt; constr,
      AFSocketFactory&lt;A&gt; sf, FileDescriptor fdObj, int localPort, int remotePort)
      throws IOException {
<span class="pc bpc" id="L118" title="1 of 2 branches missed.">    if (!fdObj.valid()) {</span>
<span class="nc" id="L119">      throw new SocketException(&quot;Invalid file descriptor&quot;);</span>
    }
<span class="fc" id="L121">    int status = NativeUnixSocket.socketStatus(fdObj);</span>
<span class="pc bpc" id="L122" title="1 of 2 branches missed.">    if (status == NativeUnixSocket.SOCKETSTATUS_INVALID) {</span>
<span class="nc" id="L123">      throw new SocketException(&quot;Not a valid socket&quot;);</span>
    }

<span class="fc" id="L126">    AFSocket&lt;A&gt; socket = newInstance0(constr, fdObj, sf);</span>
<span class="fc" id="L127">    socket.getAFImpl().updatePorts(localPort, remotePort);</span>

<span class="pc bpc" id="L129" title="2 of 4 branches missed.">    switch (status) {</span>
      case NativeUnixSocket.SOCKETSTATUS_CONNECTED:
<span class="fc" id="L131">        socket.internalDummyConnect();</span>
<span class="fc" id="L132">        break;</span>
      case NativeUnixSocket.SOCKETSTATUS_BOUND:
<span class="fc" id="L134">        socket.internalDummyBind();</span>
<span class="fc" id="L135">        break;</span>
      case NativeUnixSocket.SOCKETSTATUS_UNKNOWN:
<span class="nc" id="L137">        break;</span>
      default:
<span class="nc" id="L139">        throw new IllegalStateException(&quot;Invalid socketStatus response: &quot; + status);</span>
    }
<span class="fc" id="L141">    socket.getAFImpl().setSocketAddress(socket.getLocalSocketAddress());</span>

<span class="fc" id="L143">    return socket;</span>
  }

  /**
   * Creates a new, unbound {@link AFSocket}.
   *
   * This &quot;default&quot; implementation is a bit &quot;lenient&quot; with respect to the specification.
   *
   * In particular, we may ignore calls to {@link Socket#getTcpNoDelay()} and
   * {@link Socket#setTcpNoDelay(boolean)}.
   *
   * @param &lt;A&gt; The corresponding address type.
   * @param constr The implementation's {@link AFSocket} constructor
   * @param factory The corresponding socket factory, or {@code null}.
   * @return A new, unbound socket.
   * @throws SocketException if the operation fails.
   */
  protected static final &lt;A extends AFSocketAddress&gt; AFSocket&lt;A&gt; newInstance(Constructor&lt;A&gt; constr,
      AFSocketFactory&lt;A&gt; factory) throws SocketException {
<span class="fc" id="L162">    return newInstance0(constr, null, factory);</span>
  }

  private static &lt;A extends AFSocketAddress&gt; @NonNull AFSocket&lt;A&gt; newInstance0(
      Constructor&lt;A&gt; constr, FileDescriptor fdObj, AFSocketFactory&lt;A&gt; factory)
      throws SocketException {
<span class="fc" id="L168">    return constr.newInstance(fdObj, factory);</span>
  }

  /**
   * Creates a new {@link AFSocket} and connects it to the given {@link AFSocketAddress}.
   *
   * @param &lt;A&gt; The corresponding address type.
   * @param constr The implementation's {@link AFSocket} constructor
   * @param addr The address to connect to.
   * @return A new, connected socket.
   * @throws IOException if the operation fails.
   */
  protected static final &lt;A extends AFSocketAddress&gt; @NonNull AFSocket&lt;A&gt; connectTo(
      Constructor&lt;A&gt; constr, A addr) throws IOException {
<span class="fc" id="L182">    AFSocket&lt;A&gt; socket = constr.newInstance(null, null);</span>
<span class="fc" id="L183">    socket.connect(addr);</span>
<span class="fc" id="L184">    return socket;</span>
  }

  /**
   * Creates a new {@link AFSocket} and connects it to the given {@link AFSocketAddress} using the
   * default implementation suited for that address type.
   *
   * @param &lt;A&gt; The corresponding address type.
   * @param addr The address to connect to.
   * @return A new, connected socket.
   * @throws IOException if the operation fails.
   */
  public static final &lt;A extends AFSocketAddress&gt; AFSocket&lt;?&gt; connectTo(@NonNull A addr)
      throws IOException {
<span class="nc" id="L198">    AFSocket&lt;?&gt; socket = addr.getAddressFamily().getSocketConstructor().newInstance(null, null);</span>
<span class="nc" id="L199">    socket.connect(addr);</span>
<span class="nc" id="L200">    return socket;</span>
  }

  /**
   * Not supported, since it's not necessary for client sockets.
   *
   * @see AFServerSocket
   */
  @Override
  public final void bind(SocketAddress bindpoint) throws IOException {
<span class="pc bpc" id="L210" title="1 of 2 branches missed.">    if (bindpoint == null) {</span>
<span class="fc" id="L211">      throw new IllegalArgumentException();</span>
    }
<span class="nc bnc" id="L213" title="All 2 branches missed.">    if (isClosed()) {</span>
<span class="nc" id="L214">      throw new SocketException(&quot;Socket is closed&quot;);</span>
    }
<span class="nc bnc" id="L216" title="All 2 branches missed.">    if (isBound()) {</span>
<span class="nc" id="L217">      throw new SocketException(&quot;Already bound&quot;);</span>
    }
<span class="nc" id="L219">    preprocessSocketAddress(bindpoint);</span>
<span class="nc" id="L220">    throw new SocketException(&quot;Use AF*ServerSocket#bind or #bindOn&quot;);</span>
  }

  @Override
  public final boolean isBound() {
<span class="fc bfc" id="L225" title="All 6 branches covered.">    return impl.getFD().valid() &amp;&amp; (super.isBound() || impl.isBound());</span>
  }

  @Override
  public final boolean isConnected() {
<span class="pc bpc" id="L230" title="1 of 6 branches missed.">    return impl.getFD().valid() &amp;&amp; (super.isConnected() || impl.isConnected());</span>
  }

  @Override
  public final void connect(SocketAddress endpoint) throws IOException {
<span class="fc" id="L235">    connect(endpoint, 0);</span>
<span class="fc" id="L236">  }</span>

  @Override
  public final void connect(SocketAddress endpoint, int timeout) throws IOException {
<span class="fc" id="L240">    connect0(endpoint, timeout);</span>
<span class="fc" id="L241">  }</span>

  private AFSocketAddress preprocessSocketAddress(SocketAddress endpoint) throws SocketException {
<span class="fc bfc" id="L244" title="All 2 branches covered.">    if (endpoint == null) {</span>
<span class="fc" id="L245">      throw new IllegalArgumentException(&quot;endpoint is null&quot;);</span>
<span class="fc bfc" id="L246" title="All 2 branches covered.">    } else if (endpoint instanceof SentinelSocketAddress) {</span>
<span class="fc" id="L247">      return (AFSocketAddress) endpoint;</span>
    } else {
<span class="fc" id="L249">      return AFSocketAddress.preprocessSocketAddress(socketAddressClass(), endpoint, afh);</span>
    }
  }

  final boolean connect0(SocketAddress endpoint, int timeout) throws IOException {
<span class="fc bfc" id="L254" title="All 2 branches covered.">    if (timeout &lt; 0) {</span>
<span class="fc" id="L255">      throw new IllegalArgumentException(&quot;connect: timeout can't be negative&quot;);</span>
    }
<span class="pc bpc" id="L257" title="1 of 2 branches missed.">    if (isClosed()) {</span>
<span class="nc" id="L258">      throw new SocketException(&quot;Socket is closed&quot;);</span>
    }

<span class="pc bpc" id="L261" title="1 of 2 branches missed.">    if (connectFilter != null) {</span>
<span class="nc" id="L262">      endpoint = connectFilter.apply(endpoint);</span>
    }

<span class="fc" id="L265">    AFSocketAddress address = preprocessSocketAddress(endpoint);</span>

<span class="fc bfc" id="L267" title="All 2 branches covered.">    if (!isBound()) {</span>
<span class="fc" id="L268">      internalDummyBind();</span>
    }

<span class="fc" id="L271">    boolean success = getAFImpl().connect0(address, timeout);</span>
<span class="pc bpc" id="L272" title="1 of 2 branches missed.">    if (success) {</span>
<span class="fc" id="L273">      int port = address.getPort();</span>
<span class="fc bfc" id="L274" title="All 2 branches covered.">      if (port &gt; 0) {</span>
<span class="fc" id="L275">        getAFImpl().updatePorts(getLocalPort(), port);</span>
      }
    }
<span class="fc" id="L278">    internalDummyConnect();</span>
<span class="fc" id="L279">    return success;</span>
  }

  final void internalDummyConnect() throws IOException {
<span class="pc bpc" id="L283" title="1 of 2 branches missed.">    if (!isConnected()) {</span>
<span class="nc" id="L284">      super.connect(AFSocketAddress.INTERNAL_DUMMY_CONNECT, 0);</span>
    }
<span class="fc" id="L286">  }</span>

  final void internalDummyBind() throws IOException {
<span class="fc bfc" id="L289" title="All 2 branches covered.">    if (!isBound()) {</span>
<span class="fc" id="L290">      super.bind(AFSocketAddress.INTERNAL_DUMMY_BIND);</span>
    }
<span class="fc" id="L292">  }</span>

  @Override
  public final String toString() {
<span class="fc" id="L296">    return getClass().getName() + &quot;@&quot; + Integer.toHexString(hashCode()) + toStringSuffix();</span>
  }

  final String toStringSuffix() {
<span class="pc bpc" id="L300" title="1 of 2 branches missed.">    if (impl.getFD().valid()) {</span>
<span class="nc" id="L301">      return &quot;[local=&quot; + getLocalSocketAddress() + &quot;;remote=&quot; + getRemoteSocketAddress() + &quot;]&quot;;</span>
    } else {
<span class="fc" id="L303">      return &quot;[invalid]&quot;;</span>
    }
  }

  /**
   * Returns &lt;code&gt;true&lt;/code&gt; iff {@link AFSocket}s are supported by the current Java VM.
   *
   * To support {@link AFSocket}s, a custom JNI library must be loaded that is supplied with
   * &lt;em&gt;junixsocket&lt;/em&gt;.
   *
   * @return {@code true} iff supported.
   */
  public static boolean isSupported() {
<span class="fc" id="L316">    return NativeUnixSocket.isLoaded();</span>
  }

  /**
   * Checks if {@link AFSocket}s are supported by the current Java VM.
   *
   * If not, an {@link UnsupportedOperationException} is thrown.
   *
   * @throws UnsupportedOperationException if not supported.
   */
  public static void ensureSupported() throws UnsupportedOperationException {
<span class="nc" id="L327">    NativeUnixSocket.ensureSupported();</span>
<span class="nc" id="L328">  }</span>

  /**
   * Returns the version of the junixsocket library, as a string, for debugging purposes.
   *
   * NOTE: Do not rely on the format of the version identifier, use socket capabilities instead.
   *
   * @return String The version identifier, or {@code null} if it could not be determined.
   * @see #supports(AFSocketCapability)
   */
  public static final String getVersion() {
<span class="fc" id="L339">    String v = BuildProperties.getBuildProperties().get(&quot;git.build.version&quot;);</span>
<span class="pc bpc" id="L340" title="2 of 4 branches missed.">    if (v != null &amp;&amp; !v.startsWith(&quot;$&quot;)) {</span>
<span class="fc" id="L341">      return v;</span>
    }

    try {
<span class="nc" id="L345">      return NativeLibraryLoader.getJunixsocketVersion();</span>
<span class="nc" id="L346">    } catch (IOException e) {</span>
<span class="nc" id="L347">      return null;</span>
    }
  }

  /**
   * Returns an identifier of the loaded native library, or {@code null} if the library hasn't been
   * loaded yet.
   *
   * The identifier is useful mainly for debugging purposes.
   *
   * @return The identifier of the loaded junixsocket-native library, or {@code null}.
   */
  public static final String getLoadedLibrary() {
<span class="fc" id="L360">    return loadedLibrary;</span>
  }

  @Override
  public final boolean isClosed() {
<span class="pc bpc" id="L365" title="3 of 8 branches missed.">    return super.isClosed() || (isConnected() &amp;&amp; !impl.getFD().valid()) || impl.isClosed();</span>
  }

  @Override
  public final int getAncillaryReceiveBufferSize() {
<span class="fc" id="L370">    return impl.getAncillaryReceiveBufferSize();</span>
  }

  @Override
  public final void setAncillaryReceiveBufferSize(int size) {
<span class="fc" id="L375">    impl.setAncillaryReceiveBufferSize(size);</span>
<span class="fc" id="L376">  }</span>

  @Override
  public final void ensureAncillaryReceiveBufferSize(int minSize) {
<span class="nc" id="L380">    impl.ensureAncillaryReceiveBufferSize(minSize);</span>
<span class="nc" id="L381">  }</span>

  private static boolean isCapDisabled(AFSocketCapability cap) {
<span class="fc" id="L384">    return Boolean.parseBoolean(System.getProperty(PROP_LIBRARY_DISABLE_CAPABILITY_PREFIX + cap</span>
<span class="fc" id="L385">        .name(), &quot;false&quot;));</span>
  }

  private static int initCapabilities() {
<span class="pc bpc" id="L389" title="1 of 2 branches missed.">    if (!isSupported()) {</span>
<span class="nc" id="L390">      return 0;</span>
    } else {
<span class="fc" id="L392">      int v = NativeUnixSocket.capabilities();</span>

<span class="pc bpc" id="L394" title="1 of 2 branches missed.">      if (System.getProperty(&quot;osv.version&quot;) != null) {</span>
        // no fork, no redirect...
<span class="nc" id="L396">        v &amp;= ~(AFSocketCapability.CAPABILITY_FD_AS_REDIRECT.getBitmask());</span>
      }

<span class="fc bfc" id="L399" title="All 2 branches covered.">      for (AFSocketCapability cap : AFSocketCapability.values()) {</span>
<span class="pc bpc" id="L400" title="1 of 2 branches missed.">        if (isCapDisabled(cap)) {</span>
<span class="nc" id="L401">          v &amp;= ~(cap.getBitmask());</span>
        }
      }

<span class="fc" id="L405">      return v;</span>
    }
  }

  private static synchronized int capabilities() {
<span class="fc bfc" id="L410" title="All 2 branches covered.">    if (capabilitiesValue == null) {</span>
<span class="fc" id="L411">      capabilitiesValue = initCapabilities();</span>
    }
<span class="fc" id="L413">    return capabilitiesValue;</span>
  }

  /**
   * Checks if the current environment (system platform, native library, etc.) supports a given
   * junixsocket capability.
   *
   * Deprecated. Please use {@link #supports(AFSocketCapability)} instead.
   *
   * NOTE: The result may or may not be cached from a previous call or from a check upon
   * initialization.
   *
   * @param capability The capability.
   * @return true if supported.
   * @see #supports(AFSocketCapability)
   */
  @Deprecated
  public static final boolean supports(AFUNIXSocketCapability capability) {
<span class="nc bnc" id="L431" title="All 2 branches missed.">    return (capabilities() &amp; capability.getBitmask()) != 0;</span>
  }

  /**
   * Checks if the current environment (system platform, native library, etc.) supports a given
   * junixsocket capability.
   *
   * NOTE: The result may or may not be cached from a previous call or from a check upon
   * initialization.
   *
   * @param capability The capability.
   * @return true if supported.
   */
  public static final boolean supports(AFSocketCapability capability) {
<span class="fc bfc" id="L445" title="All 2 branches covered.">    return (capabilities() &amp; capability.getBitmask()) != 0;</span>
  }

  /**
   * Checks if the current environment (system platform, native library, etc.) supports &quot;unsafe&quot;
   * operations (as controlled via the {@link AFSocketCapability#CAPABILITY_UNSAFE} capability).
   *
   * If supported, the method returns normally. If not supported, an {@link IOException} is thrown.
   *
   * @throws IOException if &quot;unsafe&quot; operations are not supported.
   * @see Unsafe
   */
  public static final void ensureUnsafeSupported() throws IOException {
<span class="pc bpc" id="L458" title="1 of 2 branches missed.">    if (!AFSocket.supports(AFSocketCapability.CAPABILITY_UNSAFE)) {</span>
<span class="nc" id="L459">      throw new IOException(&quot;Unsafe operations are not supported in this environment&quot;);</span>
    }
<span class="fc" id="L461">  }</span>

  @Override
  public final synchronized void close() throws IOException {
<span class="fc" id="L465">    IOException superException = null;</span>
    try {
<span class="fc" id="L467">      super.close();</span>
<span class="nc" id="L468">    } catch (IOException e) {</span>
<span class="nc" id="L469">      superException = e;</span>
<span class="fc" id="L470">    }</span>
<span class="fc" id="L471">    closeables.close(superException);</span>
<span class="fc" id="L472">  }</span>

  /**
   * Registers a {@link Closeable} that should be closed when this socket is closed.
   *
   * @param closeable The closeable.
   */
  public final void addCloseable(Closeable closeable) {
<span class="fc" id="L480">    closeables.add(closeable);</span>
<span class="fc" id="L481">  }</span>

  /**
   * Unregisters a previously registered {@link Closeable}.
   *
   * @param closeable The closeable.
   */
  public final void removeCloseable(Closeable closeable) {
<span class="fc" id="L489">    closeables.remove(closeable);</span>
<span class="fc" id="L490">  }</span>

  final AFSocketImpl&lt;A&gt; getAFImpl() {
<span class="fc" id="L493">    return getAFImpl(true);</span>
  }

  final AFSocketImpl&lt;A&gt; getAFImpl(boolean createSocket) {
<span class="fc bfc" id="L497" title="All 4 branches covered.">    if (createSocket &amp;&amp; created.compareAndSet(false, true)) {</span>
      try {
<span class="fc" id="L499">        getSoTimeout(); // trigger create via java.net.Socket</span>
<span class="nc" id="L500">      } catch (SocketException e) {</span>
        // ignore
<span class="fc" id="L502">      }</span>
    }
<span class="fc" id="L504">    return impl;</span>
  }

  @SuppressFBWarnings(&quot;EI_EXPOSE_REP&quot;)
  @Override
  public AFSocketChannel&lt;A&gt; getChannel() {
<span class="fc" id="L510">    return channel;</span>
  }

  @SuppressWarnings(&quot;null&quot;)
  @Override
  public final synchronized A getRemoteSocketAddress() {
<span class="fc bfc" id="L516" title="All 2 branches covered.">    if (!isConnected()) {</span>
<span class="fc" id="L517">      return null;</span>
    }
<span class="fc" id="L519">    return impl.getRemoteSocketAddress();</span>
  }

  @SuppressWarnings(&quot;null&quot;)
  @Override
  public final A getLocalSocketAddress() {
<span class="pc bpc" id="L525" title="1 of 2 branches missed.">    if (isClosed()) {</span>
<span class="nc" id="L526">      return null;</span>
    }
<span class="fc" id="L528">    return impl.getLocalSocketAddress();</span>
  }

  @Override
  public final FileDescriptor getFileDescriptor() throws IOException {
<span class="fc" id="L533">    return impl.getFileDescriptor();</span>
  }

  @Override
  public final AFInputStream getInputStream() throws IOException {
<span class="fc" id="L538">    return getAFImpl().getInputStream();</span>
  }

  @Override
  public final AFOutputStream getOutputStream() throws IOException {
<span class="fc" id="L543">    return getAFImpl().getOutputStream();</span>
  }

  /**
   * Returns the internal helper instance for address-specific extensions.
   *
   * @return The helper instance.
   * @throws UnsupportedOperationException if such extensions are not supported for this address
   *           type.
   */
  protected final AFSocketImplExtensions&lt;A&gt; getImplExtensions() {
<span class="nc" id="L554">    return getAFImpl(false).getImplExtensions();</span>
  }

  /**
   * Forces the address to be used for any subsequent call to {@link #connect(SocketAddress)} to be
   * the given one, regardless of what'll be passed there.
   *
   * @param endpoint The forced endpoint address.
   * @return This instance.
   */
  public final AFSocket&lt;A&gt; forceConnectAddress(SocketAddress endpoint) {
<span class="nc" id="L565">    return connectHook((SocketAddress orig) -&gt; {</span>
<span class="nc bnc" id="L566" title="All 2 branches missed.">      return orig == null ? null : endpoint;</span>
    });
  }

  /**
   * Sets the hook for any subsequent call to {@link #connect(SocketAddress)} or
   * {@link #connect(SocketAddress, int)} to be the given function.
   *
   * The function can monitor events or even alter the target address.
   *
   * @param hook The function that gets called for each connect call.
   * @return This instance.
   */
  public final AFSocket&lt;A&gt; connectHook(SocketAddressFilter hook) {
<span class="nc" id="L580">    this.connectFilter = hook;</span>
<span class="nc" id="L581">    return this;</span>
  }

  /**
   * Probes the status of the socket connection.
   *
   * This usually involves checking for {@link #isConnected()}, and if assumed connected, also
   * sending a zero-length message to the remote.
   *
   * @return {@code true} if the connection is known to be closed, {@code false} if the connection
   *         is open/not closed or the condition is unknown.
   * @throws IOException on an unexpected error.
   */
  public boolean checkConnectionClosed() throws IOException {
<span class="pc bpc" id="L595" title="1 of 2 branches missed.">    if (!isConnected()) {</span>
<span class="nc" id="L596">      return true;</span>
    }
    try {
<span class="pc bpc" id="L599" title="1 of 2 branches missed.">      if (!AFSocket.supports(AFSocketCapability.CAPABILITY_ZERO_LENGTH_SEND)) {</span>
<span class="nc" id="L600">        return false;</span>
      }
<span class="fc" id="L602">      getOutputStream().write(ZERO_BYTES);</span>
<span class="fc" id="L603">      return false;</span>
<span class="nc" id="L604">    } catch (SocketClosedException e) {</span>
<span class="nc" id="L605">      return true;</span>
<span class="nc" id="L606">    } catch (IOException e) {</span>
<span class="nc bnc" id="L607" title="All 2 branches missed.">      if (!isConnected()) {</span>
<span class="nc" id="L608">        return true;</span>
      } else {
<span class="nc" id="L610">        throw e;</span>
      }
    }
  }

  /**
   * Checks if we're running on Android (as far as junixsocket is concerned).
   *
   * @return {@code true} if running on Android.
   */
  public static boolean isRunningOnAndroid() {
<span class="nc" id="L621">    return NativeLibraryLoader.isAndroid();</span>
  }

  @Override
  public void setShutdownOnClose(boolean enabled) {
<span class="nc" id="L626">    getAFImpl().getCore().setShutdownOnClose(enabled);</span>
<span class="nc" id="L627">  }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>