<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AFSocketServerConnector.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">junixsocket-jetty</a> &gt; <a href="index.source.html" class="el_package">org.newsclub.net.unix.jetty</a> &gt; <span class="el_source">AFSocketServerConnector.java</span></div><h1>AFSocketServerConnector.java</h1><pre class="source lang-java linenums">/*
 * junixsocket
 *
 * Copyright 2009-2022 Christian Kohlsch√ºtter
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
//
// based upon jetty-unixdomain-server
// original copyright message from jetty's UnixDomainServerConnector:
//
// ========================================================================
// Copyright (c) 1995-2022 Mort Bay Consulting Pty Ltd and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// https://www.eclipse.org/legal/epl-2.0, or the Apache License, Version 2.0
// which is available at https://www.apache.org/licenses/LICENSE-2.0.
//
// SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
// ========================================================================
//

package org.newsclub.net.unix.jetty;

import java.io.Closeable;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.net.SocketException;
import java.net.StandardSocketOptions;
import java.nio.channels.Channel;
import java.nio.channels.ClosedByInterruptException;
import java.nio.channels.SelectableChannel;
import java.nio.channels.SelectionKey;
import java.nio.channels.Selector;
import java.nio.channels.ServerSocketChannel;
import java.nio.channels.SocketChannel;
import java.nio.channels.spi.SelectorProvider;
import java.nio.file.Path;
import java.util.EventListener;
import java.util.Locale;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.Executor;
import java.util.concurrent.atomic.AtomicReference;

import org.eclipse.jetty.io.ByteBufferPool;
import org.eclipse.jetty.io.Connection;
import org.eclipse.jetty.io.EndPoint;
import org.eclipse.jetty.io.ManagedSelector;
import org.eclipse.jetty.io.SelectorManager;
import org.eclipse.jetty.io.SocketChannelEndPoint;
import org.eclipse.jetty.server.AbstractConnector;
import org.eclipse.jetty.server.ConnectionFactory;
import org.eclipse.jetty.server.Connector;
import org.eclipse.jetty.server.HttpConnectionFactory;
import org.eclipse.jetty.server.Server;
import org.eclipse.jetty.util.IO;
import org.eclipse.jetty.util.annotation.ManagedAttribute;
import org.eclipse.jetty.util.annotation.ManagedObject;
import org.eclipse.jetty.util.thread.ScheduledExecutorScheduler;
import org.eclipse.jetty.util.thread.Scheduler;
import org.newsclub.net.unix.AFServerSocketChannel;
import org.newsclub.net.unix.AFSocketAddress;
import org.newsclub.net.unix.AFUNIXSocketAddress;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.kohlschutter.annotations.compiletime.SuppressFBWarnings;

/**
 * A {@link Connector} implementation for junixsocket server socket channels (Unix domains etc.)
 *
 * Based upon jetty's UnixDomainServerConnector.
 *
 * This implementation should work with jetty version 9.4.12 or newer.
 */
@ManagedObject
public class AFSocketServerConnector extends AbstractConnector {
<span class="fc" id="L89">  private static final Logger LOG = LoggerFactory.getLogger(AbstractConnector.class);</span>

<span class="fc" id="L91">  private final AtomicReference&lt;Closeable&gt; acceptor = new AtomicReference&lt;&gt;();</span>
  private final SelectorManager selectorManager;
  private ServerSocketChannel serverChannel;
  private AFSocketAddress listenSocketAddress;
  private boolean inheritChannel;
  private int acceptQueueSize;
  private int acceptedReceiveBufferSize;
  private int acceptedSendBufferSize;

<span class="fc" id="L100">  private boolean mayStopServer = false;</span>
<span class="fc" id="L101">  private boolean mayStopServerForce = false;</span>
  private final Class&lt;? extends EventListener&gt; selectorManagerListenerClass;
  private final Server server;

  /**
   * Creates a new {@link AFSocketServerConnector}.
   *
   * @param server The server this connector will be added to. Must not be null.
   * @param factories The Connection Factories to use.
   */
  public AFSocketServerConnector(Server server, ConnectionFactory... factories) {
<span class="fc" id="L112">    this(server, null, null, null, -1, -1, factories);</span>
<span class="fc" id="L113">  }</span>

  /**
   * Creates a new {@link AFSocketServerConnector}.
   *
   * @param server The server this connector will be added to. Must not be null.
   * @param acceptors the number of acceptor threads to use, or -1 for a default value. If 0, then
   *          no acceptor threads will be launched and some other mechanism will need to be used to
   *          accept new connections.
   * @param selectors The number of selectors to use, or -1 for a default derived
   * @param factories The Connection Factories to use.
   */
  public AFSocketServerConnector(Server server, int acceptors, int selectors,
      ConnectionFactory... factories) {
<span class="fc" id="L127">    this(server, null, null, null, acceptors, selectors, factories);</span>
<span class="fc" id="L128">  }</span>

  /**
   * Creates a new {@link AFSocketServerConnector}.
   *
   * @param server The server this connector will be added to. Must not be null.
   * @param executor An executor for this connector or null to use the servers executor
   * @param scheduler A scheduler for this connector or null to either a {@link Scheduler} set as a
   *          server bean or if none set, then a new {@link ScheduledExecutorScheduler} instance.
   * @param pool A buffer pool for this connector or null to either a {@link ByteBufferPool} set as
   *          a server bean or none set, the new {code ArrayByteBufferPool} instance.
   * @param acceptors the number of acceptor threads to use, or -1 for a default value. If 0, then
   *          no acceptor threads will be launched and some other mechanism will need to be used to
   *          accept new connections.
   * @param selectors The number of selectors to use, or -1 for a default derived
   * @param factories The Connection Factories to use.
   */
  @SuppressFBWarnings(&quot;EI_EXPOSE_REP2&quot;)
  public AFSocketServerConnector(Server server, Executor executor, Scheduler scheduler,
      ByteBufferPool pool, int acceptors, int selectors, ConnectionFactory... factories) {
<span class="pc bpc" id="L148" title="1 of 2 branches missed.">    super(server, executor, scheduler, pool, acceptors, factories.length &gt; 0 ? factories</span>
<span class="nc" id="L149">        : new ConnectionFactory[] {new HttpConnectionFactory()});</span>
<span class="fc" id="L150">    this.server = server;</span>
<span class="fc" id="L151">    this.selectorManager = newSelectorManager(getExecutor(), getScheduler(), selectors);</span>
<span class="fc" id="L152">    addBean(selectorManager, true);</span>

<span class="fc" id="L154">    this.selectorManagerListenerClass = findSelectorManagerListenerClass();</span>
<span class="fc" id="L155">  }</span>

  @SuppressWarnings(&quot;unchecked&quot;)
  private static Class&lt;? extends EventListener&gt; findSelectorManagerListenerClass() {
    try {
<span class="fc" id="L160">      return (Class&lt;? extends EventListener&gt;) Class.forName(</span>
          &quot;org.eclipse.jetty.io.SelectorManager$SelectorManagerListener&quot;);
<span class="nc" id="L162">    } catch (ClassNotFoundException e) {</span>
<span class="nc" id="L163">      return null;</span>
    }
  }

  private SelectorManager newSelectorManager(Executor executor, Scheduler scheduler,
      int selectors) {
<span class="fc" id="L169">    return new AFSocketSelectorManager(executor, scheduler, selectors);</span>
  }

  /**
   * Returns the Unix-Domain path this connector listens to.
   *
   * Added for compatibility with jetty's {@code UnixDomainServerConnector}.
   *
   * @return The Unix-Domain path this connector listens to.
   * @deprecated Use {@link #getListenSocketAddress()} instead.
   * @see #getListenSocketAddress()
   */
  @ManagedAttribute(&quot;The Unix-Domain path this connector listens to&quot;)
  public Path getUnixDomainPath() {
<span class="nc bnc" id="L183" title="All 2 branches missed.">    if (listenSocketAddress instanceof AFUNIXSocketAddress) {</span>
<span class="nc" id="L184">      AFUNIXSocketAddress addr = (AFUNIXSocketAddress) listenSocketAddress;</span>
<span class="nc bnc" id="L185" title="All 2 branches missed.">      if (addr.hasFilename()) {</span>
        try {
<span class="nc" id="L187">          return addr.getFile().toPath();</span>
<span class="nc" id="L188">        } catch (FileNotFoundException e) {</span>
<span class="nc" id="L189">          return null;</span>
        }
      }
    }
<span class="nc" id="L193">    return null;</span>
  }

  /**
   * Sets the Unix-Domain path this connector listens to.
   *
   * Added for compatibility with jetty's {@code UnixDomainServerConnector}.
   *
   * @param unixDomainPath The path.
   * @deprecated Use {@link #setListenSocketAddress(AFSocketAddress)} instead.
   * @see #setListenSocketAddress(AFSocketAddress)
   */
  public void setUnixDomainPath(Path unixDomainPath) {
    try {
<span class="nc" id="L207">      this.listenSocketAddress = AFUNIXSocketAddress.of(unixDomainPath);</span>
<span class="nc" id="L208">    } catch (SocketException e) {</span>
<span class="nc" id="L209">      throw new IllegalStateException(e);</span>
<span class="nc" id="L210">    }</span>
<span class="nc" id="L211">  }</span>

  /**
   * Returns the socket address this connector listens to.
   *
   * @return The socket address, or {@code null} if none set.
   */
  @ManagedAttribute(&quot;The socket address this connector listens to&quot;)
  @SuppressFBWarnings(&quot;EI_EXPOSE_REP&quot;)
  public AFSocketAddress getListenSocketAddress() {
<span class="nc" id="L221">    return listenSocketAddress;</span>
  }

  /**
   * Sets the socket address this connector listens to.
   *
   * @param addr The socket address, or {@code null}.
   */
  @SuppressFBWarnings(&quot;EI_EXPOSE_REP2&quot;)
  public void setListenSocketAddress(AFSocketAddress addr) {
<span class="fc" id="L231">    this.listenSocketAddress = addr;</span>
<span class="fc" id="L232">  }</span>

  /**
   * Checks whether this connector uses a server channel inherited from the JVM.
   *
   * @return {@code true} if so.
   */
  @ManagedAttribute(&quot;Whether this connector uses a server channel inherited from the JVM&quot;)
  public boolean isInheritChannel() {
<span class="fc" id="L241">    return inheritChannel;</span>
  }

  /**
   * Sets whether this connector uses a server channel inherited from the JVM.
   *
   * @param inheritChannel {@code true} if so.
   */
  public void setInheritChannel(boolean inheritChannel) {
<span class="nc" id="L250">    this.inheritChannel = inheritChannel;</span>
<span class="nc" id="L251">  }</span>

  /**
   * Returns the accept queue size (backlog) for the server socket.
   *
   * @return The backlog.
   */
  @ManagedAttribute(&quot;The accept queue size (backlog) for the server socket&quot;)
  public int getAcceptQueueSize() {
<span class="fc" id="L260">    return acceptQueueSize;</span>
  }

  /**
   * Sets the accept queue size (backlog) for the server socket.
   *
   * @param acceptQueueSize The backlog.
   */
  public void setAcceptQueueSize(int acceptQueueSize) {
<span class="fc" id="L269">    this.acceptQueueSize = acceptQueueSize;</span>
<span class="fc" id="L270">  }</span>

  /**
   * Returns the SO_RCVBUF size for accepted sockets.
   *
   * @return The buffer size.
   */
  @ManagedAttribute(&quot;The SO_RCVBUF option for accepted sockets&quot;)
  public int getAcceptedReceiveBufferSize() {
<span class="fc" id="L279">    return acceptedReceiveBufferSize;</span>
  }

  /**
   * Sets the SO_RCVBUF size for accepted sockets.
   *
   * @param acceptedReceiveBufferSize The buffer size.
   */
  public void setAcceptedReceiveBufferSize(int acceptedReceiveBufferSize) {
<span class="nc" id="L288">    this.acceptedReceiveBufferSize = acceptedReceiveBufferSize;</span>
<span class="nc" id="L289">  }</span>

  /**
   * Returns the SO_SNDBUF size for accepted sockets.
   *
   * @return The buffer size.
   */
  @ManagedAttribute(&quot;The SO_SNDBUF option for accepted sockets&quot;)
  public int getAcceptedSendBufferSize() {
<span class="fc" id="L298">    return acceptedSendBufferSize;</span>
  }

  /**
   * Sets the SO_SNDBUF size for accepted sockets.
   *
   * @param acceptedSendBufferSize The buffer size.
   */
  public void setAcceptedSendBufferSize(int acceptedSendBufferSize) {
<span class="nc" id="L307">    this.acceptedSendBufferSize = acceptedSendBufferSize;</span>
<span class="nc" id="L308">  }</span>

  @Override
  protected void doStart() throws Exception {
<span class="pc bpc" id="L312" title="1 of 2 branches missed.">    if (selectorManagerListenerClass != null) {</span>
<span class="fc" id="L313">      getBeans(selectorManagerListenerClass).forEach(selectorManager::addEventListener);</span>
    }
<span class="fc" id="L315">    serverChannel = open();</span>
<span class="fc" id="L316">    addBean(serverChannel);</span>
<span class="fc" id="L317">    super.doStart();</span>
<span class="fc" id="L318">  }</span>

  @Override
  protected void doStop() throws Exception {
<span class="fc" id="L322">    super.doStop();</span>
<span class="fc" id="L323">    removeBean(serverChannel);</span>
<span class="fc" id="L324">    close();</span>
<span class="pc bpc" id="L325" title="1 of 2 branches missed.">    if (selectorManagerListenerClass != null) {</span>
<span class="fc" id="L326">      getBeans(selectorManagerListenerClass).forEach(selectorManager::removeEventListener);</span>
    }
<span class="fc" id="L328">  }</span>

  @Override
  @SuppressWarnings(&quot;PMD.CognitiveComplexity&quot;)
  protected void accept(int acceptorID) throws IOException {
<span class="fc" id="L333">    ServerSocketChannel sc = this.serverChannel;</span>
<span class="pc bpc" id="L334" title="1 of 2 branches missed.">    if (sc != null) {</span>
      try {
<span class="fc" id="L336">        SocketChannel channel = sc.accept();</span>
<span class="fc" id="L337">        accepted(channel);</span>
<span class="fc" id="L338">      } catch (SocketException e) {</span>
<span class="pc bpc" id="L339" title="1 of 4 branches missed.">        boolean takenOver = !sc.isOpen() || sc.getLocalAddress() == null;</span>
<span class="pc bpc" id="L340" title="1 of 4 branches missed.">        if (!takenOver &amp;&amp; sc instanceof AFServerSocketChannel&lt;?&gt;) {</span>
<span class="pc bpc" id="L341" title="1 of 2 branches missed.">          takenOver = !((AFServerSocketChannel&lt;?&gt;) sc).isLocalSocketAddressValid();</span>
        }

<span class="pc bpc" id="L344" title="1 of 4 branches missed.">        if (takenOver &amp;&amp; isMayStopServer()) {</span>
<span class="fc" id="L345">          LOG.warn(&quot;Another server has taken over our address&quot;);</span>
<span class="fc" id="L346">          CompletableFuture.runAsync(this::checkServerStop);</span>
        }
<span class="fc" id="L348">        throw (ClosedByInterruptException) new ClosedByInterruptException().initCause(e);</span>
<span class="fc" id="L349">      }</span>
    }
<span class="fc" id="L351">  }</span>

  private void checkServerStop() {
<span class="fc" id="L354">    Connector[] connectors = server.getConnectors();</span>

<span class="pc bpc" id="L356" title="2 of 4 branches missed.">    if (connectors != null &amp;&amp; !isMayStopServerForce()) {</span>
<span class="fc bfc" id="L357" title="All 2 branches covered.">      for (Connector conn : connectors) {</span>
<span class="pc bpc" id="L358" title="3 of 4 branches missed.">        if (conn != AFSocketServerConnector.this &amp;&amp; conn.isRunning()) { // NOPMD.CompareObjectsWithEquals</span>
<span class="nc" id="L359">          return; // don't stop</span>
        }
      }
    }

<span class="fc" id="L364">    LOG.warn(&quot;Server has no other connectors; shutting down: &quot; + server); // NOPMD</span>

    try {
<span class="fc" id="L367">      server.stop();</span>
<span class="nc" id="L368">    } catch (Exception e1) {</span>
<span class="nc" id="L369">      LOG.warn(&quot;Exception upon stopping &quot; + server, e1); // NOPMD</span>
<span class="fc" id="L370">    }</span>
<span class="fc" id="L371">  }</span>

  private void accepted(SocketChannel channel) throws IOException {
<span class="fc" id="L374">    channel.configureBlocking(false);</span>
<span class="fc" id="L375">    configure(channel);</span>
<span class="fc" id="L376">    selectorManager.accept(channel);</span>
<span class="fc" id="L377">  }</span>

  /**
   * Configures an incoming {@link SocketChannel}, setting socket options such as receive and send
   * buffer sizes.
   *
   * @param channel The socket channel to configure.
   * @throws IOException on error.
   */
  protected void configure(SocketChannel channel) throws IOException {
<span class="fc" id="L387">    channel.setOption(StandardSocketOptions.SO_REUSEADDR, true);</span>
<span class="fc" id="L388">    int rcvBufSize = getAcceptedReceiveBufferSize();</span>
<span class="pc bpc" id="L389" title="1 of 2 branches missed.">    if (rcvBufSize &gt; 0) {</span>
<span class="nc" id="L390">      channel.setOption(StandardSocketOptions.SO_RCVBUF, rcvBufSize);</span>
    }
<span class="fc" id="L392">    int sndBufSize = getAcceptedSendBufferSize();</span>
<span class="pc bpc" id="L393" title="1 of 2 branches missed.">    if (sndBufSize &gt; 0) {</span>
<span class="nc" id="L394">      channel.setOption(StandardSocketOptions.SO_SNDBUF, sndBufSize);</span>
    }
<span class="fc" id="L396">  }</span>

  @Override
  @SuppressFBWarnings(&quot;EI_EXPOSE_REP&quot;)
  public Object getTransport() {
<span class="nc" id="L401">    return serverChannel;</span>
  }

  private ServerSocketChannel open() throws IOException {
<span class="fc" id="L405">    ServerSocketChannel sc = openServerSocketChannel();</span>
<span class="pc bpc" id="L406" title="1 of 2 branches missed.">    if (getAcceptors() == 0) {</span>
<span class="nc" id="L407">      sc.configureBlocking(false);</span>
<span class="nc" id="L408">      acceptor.set(selectorManager.acceptor(sc));</span>
    }
<span class="fc" id="L410">    return sc;</span>
  }

  private void close() throws IOException {
<span class="fc" id="L414">    ServerSocketChannel sc = this.serverChannel;</span>
<span class="fc" id="L415">    this.serverChannel = null;</span>
<span class="fc" id="L416">    IO.close(sc);</span>
<span class="fc" id="L417">  }</span>

  private ServerSocketChannel openServerSocketChannel() throws IOException {
<span class="fc" id="L420">    ServerSocketChannel sc = null;</span>
<span class="pc bpc" id="L421" title="1 of 2 branches missed.">    if (isInheritChannel()) {</span>
<span class="nc" id="L422">      Channel channel = System.inheritedChannel();</span>
<span class="nc bnc" id="L423" title="All 2 branches missed.">      if (channel instanceof ServerSocketChannel) {</span>
<span class="nc" id="L424">        sc = (ServerSocketChannel) channel;</span>
      } else {
<span class="nc" id="L426">        LOG.warn( // NOPMD.GuardLogStatement</span>
            &quot;Unable to use System.inheritedChannel() {}. Trying a new ServerSocketChannel at {}&quot;,
<span class="nc" id="L428">            channel, getListenSocketAddress());</span>
      }
    }
<span class="pc bpc" id="L431" title="1 of 2 branches missed.">    if (sc == null) {</span>
<span class="fc" id="L432">      sc = bindServerSocketChannel();</span>
    }
<span class="fc" id="L434">    return sc;</span>
  }

  private ServerSocketChannel bindServerSocketChannel() throws IOException {
<span class="fc" id="L438">    AFSocketAddress socketAddress = listenSocketAddress;</span>
<span class="fc" id="L439">    AFServerSocketChannel&lt;?&gt; sc = socketAddress.getAddressFamily().newServerSocketChannel();</span>

    try {
<span class="fc" id="L442">      sc.bind(socketAddress, getAcceptQueueSize());</span>
<span class="fc" id="L443">      return sc;</span>
<span class="fc" id="L444">    } catch (IOException x) {</span>
<span class="fc" id="L445">      String message = String.format(Locale.ENGLISH, &quot;Could not bind %s to %s&quot;,</span>
<span class="fc" id="L446">          AFSocketServerConnector.class.getSimpleName(), listenSocketAddress);</span>
<span class="fc" id="L447">      throw new IOException(message, x);</span>
    }
  }

  @Override
  public void setAccepting(boolean accepting) {
<span class="nc" id="L453">    super.setAccepting(accepting);</span>
<span class="nc bnc" id="L454" title="All 2 branches missed.">    if (getAcceptors() == 0) {</span>
<span class="nc" id="L455">      return;</span>
    }
<span class="nc bnc" id="L457" title="All 2 branches missed.">    if (accepting) {</span>
<span class="nc bnc" id="L458" title="All 2 branches missed.">      if (acceptor.get() == null) {</span>
<span class="nc" id="L459">        Closeable cl = selectorManager.acceptor(serverChannel);</span>
<span class="nc bnc" id="L460" title="All 2 branches missed.">        if (!this.acceptor.compareAndSet(null, cl)) {</span>
<span class="nc" id="L461">          IO.close(cl);</span>
        }
<span class="nc" id="L463">      }</span>
    } else {
<span class="nc" id="L465">      Closeable cl = this.acceptor.get();</span>
<span class="nc bnc" id="L466" title="All 4 branches missed.">      if (cl != null &amp;&amp; this.acceptor.compareAndSet(cl, null)) {</span>
<span class="nc" id="L467">        IO.close(cl);</span>
      }
    }
<span class="nc" id="L470">  }</span>

  @Override
  public String toString() {
<span class="fc" id="L474">    return String.format(Locale.ENGLISH, &quot;%s@%h[%s]&quot;, getClass().getSimpleName(), hashCode(),</span>
        listenSocketAddress);
  }

  private final class AFSocketSelectorManager extends SelectorManager {
<span class="fc" id="L479">    public AFSocketSelectorManager(Executor executor, Scheduler scheduler, int selectors) {</span>
<span class="fc" id="L480">      super(executor, scheduler, selectors);</span>
<span class="fc" id="L481">    }</span>

    @Override
    protected Selector newSelector() throws IOException {
<span class="fc" id="L485">      SelectorProvider provider = listenSocketAddress.getAddressFamily().getSelectorProvider();</span>
<span class="fc" id="L486">      return provider.openSelector();</span>
    }

    @Override
    protected void accepted(SelectableChannel channel) throws IOException {
<span class="nc" id="L491">      AFSocketServerConnector.this.accepted((SocketChannel) channel);</span>
<span class="nc" id="L492">    }</span>

    @Override
    protected EndPoint newEndPoint(SelectableChannel channel, ManagedSelector selector,
        SelectionKey selectionKey) {
<span class="fc" id="L497">      SocketChannelEndPoint endPoint = new SocketChannelEndPoint((SocketChannel) channel, selector,</span>
<span class="fc" id="L498">          selectionKey, getScheduler());</span>
<span class="fc" id="L499">      endPoint.setIdleTimeout(getIdleTimeout());</span>
<span class="fc" id="L500">      return endPoint;</span>
    }

    @Override
    public Connection newConnection(SelectableChannel channel, EndPoint endpoint,
        Object attachment) {
<span class="fc" id="L506">      return getDefaultConnectionFactory().newConnection(AFSocketServerConnector.this, endpoint);</span>
    }

    @Override
    protected void endPointOpened(EndPoint endpoint) {
<span class="fc" id="L511">      super.endPointOpened(endpoint);</span>
<span class="fc" id="L512">      onEndPointOpened(endpoint);</span>
<span class="fc" id="L513">    }</span>

    @Override
    protected void endPointClosed(EndPoint endpoint) {
<span class="fc" id="L517">      onEndPointClosed(endpoint);</span>
<span class="fc" id="L518">      super.endPointClosed(endpoint);</span>
<span class="fc" id="L519">    }</span>
  }

  /**
   * Checks if this connector may stop the server when it's no longer able to serve and no other
   * connectors are available.
   *
   * @return {@code true} if so.
   */
  @ManagedAttribute(&quot;Whether this connector may stop the server when it's no longer able to&quot;
      + &quot; serve and no other connectors are available&quot;)
  public boolean isMayStopServer() {
<span class="fc" id="L531">    return mayStopServer;</span>
  }

  /**
   * Sets if this connector may stop the server when it's no longer able to serve and no other
   * connectors are available.
   *
   * @param mayStopServer {@code true} if so.
   */
  public void setMayStopServer(boolean mayStopServer) {
<span class="fc" id="L541">    this.mayStopServer = mayStopServer;</span>
<span class="fc" id="L542">  }</span>

  /**
   * Checks if this connector may stop the server when it's no longer able to serve, even if other
   * connectors are available.
   *
   * @return {@code true} if so.
   */
  @ManagedAttribute(&quot;Whether this connector may stop the server when it's no longer able to&quot;
      + &quot; serve, even if other connectors are available&quot;)
  public boolean isMayStopServerForce() {
<span class="fc" id="L553">    return mayStopServerForce;</span>
  }

  /**
   * Sets if this connector may stop the server when it's no longer able to serve and no other
   * connectors are available.
   *
   * @param b {@code true} if so (which then also implies {@code setMayStopServer(true)}
   */
  public void setMayStopServerForce(boolean b) {
<span class="nc bnc" id="L563" title="All 2 branches missed.">    if (b) {</span>
<span class="nc" id="L564">      setMayStopServer(true);</span>
    }
<span class="nc" id="L566">    this.mayStopServerForce = b;</span>
<span class="nc" id="L567">  }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>