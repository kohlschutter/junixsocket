<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>RemotePeerInfo.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">junixsocket-rmi</a> &gt; <a href="index.source.html" class="el_package">org.newsclub.net.unix.rmi</a> &gt; <span class="el_source">RemotePeerInfo.java</span></div><h1>RemotePeerInfo.java</h1><pre class="source lang-java linenums">/*
 * junixsocket
 *
 * Copyright 2009-2024 Christian Kohlschütter
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.newsclub.net.unix.rmi;

import java.io.IOException;
import java.io.ObjectOutput;
import java.lang.reflect.Proxy;
import java.rmi.Remote;
import java.rmi.server.RMISocketFactory;
import java.rmi.server.RemoteObject;
import java.rmi.server.RemoteObjectInvocationHandler;

import org.newsclub.net.unix.AFUNIXSocketCredentials;

import com.kohlschutter.annotations.compiletime.SuppressFBWarnings;

/**
 * Information about the remote connection.
 *
 * @author Christian Kohlschütter
 */
public final class RemotePeerInfo {
  private RMISocketFactory socketFactory;
  String host;
  int port;
  private AFUNIXSocketCredentials peerCredentials;

<span class="fc" id="L43">  RemotePeerInfo() {</span>
<span class="fc" id="L44">  }</span>

  /**
   * The socket factory used to establish connections.
   *
   * @return The socket factory.
   */
  public RMISocketFactory getSocketFactory() {
<span class="fc" id="L52">    return socketFactory;</span>
  }

  /**
   * The hostname.
   *
   * @return The hostname
   */
  public String getHost() {
<span class="nc" id="L61">    return host;</span>
  }

  /**
   * The port.
   *
   * @return The port
   */
  public int getPort() {
<span class="nc" id="L70">    return port;</span>
  }

  /**
   * The remote socket credentials, or {@code null} if they could not be retrieved.
   *
   * @return The peer credentials, or {@code null}.
   */
  @SuppressFBWarnings(&quot;EI_EXPOSE_REP&quot;)
  public AFUNIXSocketCredentials getPeerCredentials() {
<span class="fc" id="L80">    return peerCredentials;</span>
  }

  /**
   * Returns the {@link AFUNIXSocketCredentials} for the currently active remote session
   * (RemoteServer session during a remote method invocation), or {@code null} if it was not
   * possible to retrieve these credentials.
   *
   * @return The credentials, or {@code null} if unable to retrieve.
   */
  public static AFUNIXSocketCredentials remotePeerCredentials() {
<span class="fc" id="L91">    return AFUNIXSocketCredentials.remotePeerCredentials();</span>
  }

  /**
   * Returns the {@link AFUNIXSocketCredentials} for the peer (server) of the given {@link Remote}
   * instance, or {@code null} if it was not possible to retrieve these credentials.
   *
   * @param obj The remote object.
   * @return The credentials, or {@code null} if unable to retrieve.
   * @throws IOException if an exception occurs.
   */
  public static AFUNIXSocketCredentials remotePeerCredentials(Remote obj) throws IOException {
<span class="fc" id="L103">    return getConnectionInfo(obj).getPeerCredentials();</span>
  }

  /**
   * Returns the connection information ({@link RMISocketFactory}, hostname and port) used for the
   * given {@link Remote} object, or {@code null} if no custom {@link RMISocketFactory} was
   * specified.
   *
   * An {@link IOException} may be thrown if we couldn't determine the socket factory.
   *
   * @param obj The remote object.
   * @return The factory, or {@code null}
   * @throws IOException if the operation fails.
   */
  public static RemotePeerInfo getConnectionInfo(Remote obj) throws IOException {
<span class="fc" id="L118">    try (RemotePeerInfo.ExtractingObjectOutput eoo = new RemotePeerInfo.ExtractingObjectOutput()) {</span>
<span class="fc" id="L119">      RemoteObjectInvocationHandler roih = (RemoteObjectInvocationHandler) Proxy</span>
<span class="fc" id="L120">          .getInvocationHandler(RemoteObject.toStub(obj));</span>

<span class="fc" id="L122">      roih.getRef().writeExternal(eoo);</span>
<span class="pc bpc" id="L123" title="1 of 2 branches missed.">      if (!eoo.validate()) {</span>
<span class="nc" id="L124">        throw new IOException(&quot;Unexpected data format for &quot; + obj.getClass());</span>
      }

<span class="fc" id="L127">      RemotePeerInfo data = eoo.data;</span>
<span class="pc bpc" id="L128" title="1 of 2 branches missed.">      if ((data.socketFactory) instanceof AFUNIXRMISocketFactory) {</span>
<span class="fc" id="L129">        AFUNIXRMISocketFactory sf = ((AFUNIXRMISocketFactory) (data.socketFactory));</span>
<span class="fc" id="L130">        data.peerCredentials = sf.peerCredentialsFor(data);</span>

<span class="pc bpc" id="L132" title="1 of 2 branches missed.">        if (data.peerCredentials == null) {</span>
<span class="pc bpc" id="L133" title="1 of 2 branches missed.">          if (sf.isLocalServer(data.port)) {</span>
<span class="fc" id="L134">            data.peerCredentials = AFUNIXSocketCredentials.SAME_PROCESS;</span>
          }
        }
<span class="fc" id="L137">      } else {</span>
<span class="nc" id="L138">        data.peerCredentials = null;</span>
      }

<span class="fc" id="L141">      return data;</span>
    }
  }

  /**
   * Mimics a Serializer for RemoteRef.writeExternal, so we can extract the information we need
   * about the remote reference without having to break-open internal Java classes.
   *
   * NOTE: The format for the data we extract is assumed to be stable across JVM implementations,
   * otherwise RMI would probably not work.
   *
   * @author Christian Kohlschütter
   */
  static final class ExtractingObjectOutput implements ObjectOutput {
<span class="fc" id="L155">    private int callId = 0;</span>
<span class="fc" id="L156">    private boolean done = false;</span>
<span class="fc" id="L157">    private boolean invalid = false;</span>
<span class="fc" id="L158">    private int format = -1;</span>

<span class="fc" id="L160">    final RemotePeerInfo data = new RemotePeerInfo();</span>

<span class="fc" id="L162">    public ExtractingObjectOutput() {</span>
<span class="fc" id="L163">    }</span>

    private void setInvalid() {
<span class="nc" id="L166">      invalid = done = true;</span>
<span class="nc" id="L167">    }</span>

    private void call(int id, Object v) {
<span class="fc bfc" id="L170" title="All 5 branches covered.">      switch (id) {</span>
        case 1:
<span class="pc bpc" id="L172" title="1 of 2 branches missed.">          if (v instanceof Integer) {</span>
            // see sun.rmi.transport.tcp.TCPEndpoint
<span class="pc bpc" id="L174" title="2 of 3 branches missed.">            switch ((int) v) {</span>
              case 0:
                // FORMAT_HOST_PORT (= no socket factory)
<span class="nc" id="L177">                format = 0;</span>
<span class="nc" id="L178">                return;</span>
              case 1:
                // FORMAT_HOST_PORT_FACTORY
<span class="fc" id="L181">                format = 1;</span>
<span class="pc" id="L182">                return;</span>
              default:
            }
          }
          break;
        case 2:
<span class="pc bpc" id="L188" title="1 of 2 branches missed.">          if (v instanceof String) {</span>
<span class="fc" id="L189">            this.data.host = (String) v;</span>
<span class="fc" id="L190">            return;</span>
          }
          break;
        case 3:
<span class="pc bpc" id="L194" title="1 of 2 branches missed.">          if (format == 0) {</span>
<span class="nc" id="L195">            done = true;</span>
          }
<span class="pc bpc" id="L197" title="1 of 2 branches missed.">          if (v instanceof Integer) {</span>
<span class="fc" id="L198">            this.data.port = (int) v;</span>
<span class="pc bpc" id="L199" title="1 of 2 branches missed.">            if (this.data.port &lt;= 0) {</span>
<span class="nc" id="L200">              setInvalid();</span>
            }
<span class="fc" id="L202">            return;</span>
          }
          break;
        case 4:
<span class="pc bpc" id="L206" title="2 of 4 branches missed.">          if (v instanceof RMISocketFactory &amp;&amp; format == 1) {</span>
<span class="fc" id="L207">            this.data.socketFactory = (RMISocketFactory) v;</span>
<span class="fc" id="L208">            return;</span>
          }
          break;
        default:
          // no need to read any further
<span class="fc" id="L213">          done = true;</span>
<span class="fc" id="L214">          return;</span>
      }

      // otherwise:
<span class="nc" id="L218">      setInvalid();</span>
<span class="nc" id="L219">    }</span>

    @Override
    public void writeBoolean(boolean v) {
<span class="pc bpc" id="L223" title="1 of 2 branches missed.">      if (done) {</span>
<span class="fc" id="L224">        return;</span>
      }
<span class="nc" id="L226">      call(++callId, v);</span>
<span class="nc" id="L227">    }</span>

    @Override
    public void writeByte(int v) {
<span class="pc bpc" id="L231" title="1 of 2 branches missed.">      if (done) {</span>
<span class="nc" id="L232">        return;</span>
      }
<span class="fc" id="L234">      call(++callId, v);</span>
<span class="fc" id="L235">    }</span>

    @Override
    public void writeShort(int v) {
<span class="pc bpc" id="L239" title="1 of 2 branches missed.">      if (done) {</span>
<span class="fc" id="L240">        return;</span>
      }
<span class="nc" id="L242">      call(++callId, v);</span>
<span class="nc" id="L243">    }</span>

    @Override
    public void writeChar(int v) {
<span class="nc bnc" id="L247" title="All 2 branches missed.">      if (done) {</span>
<span class="nc" id="L248">        return;</span>
      }
<span class="nc" id="L250">      call(++callId, v);</span>
<span class="nc" id="L251">    }</span>

    @Override
    public void writeInt(int v) {
<span class="fc bfc" id="L255" title="All 2 branches covered.">      if (done) {</span>
<span class="fc" id="L256">        return;</span>
      }
<span class="fc" id="L258">      call(++callId, v);</span>
<span class="fc" id="L259">    }</span>

    @Override
    public void writeLong(long v) {
<span class="fc bfc" id="L263" title="All 2 branches covered.">      if (done) {</span>
<span class="fc" id="L264">        return;</span>
      }
<span class="fc" id="L266">      call(++callId, v);</span>
<span class="fc" id="L267">    }</span>

    @Override
    public void writeFloat(float v) {
<span class="nc bnc" id="L271" title="All 2 branches missed.">      if (done) {</span>
<span class="nc" id="L272">        return;</span>
      }
<span class="nc" id="L274">      call(++callId, v);</span>
<span class="nc" id="L275">    }</span>

    @Override
    public void writeDouble(double v) {
<span class="nc bnc" id="L279" title="All 2 branches missed.">      if (done) {</span>
<span class="nc" id="L280">        return;</span>
      }
<span class="nc" id="L282">      call(++callId, v);</span>
<span class="nc" id="L283">    }</span>

    @Override
    public void writeBytes(String s) {
<span class="nc bnc" id="L287" title="All 2 branches missed.">      if (done) {</span>
<span class="nc" id="L288">        return;</span>
      }
<span class="nc" id="L290">      call(++callId, s);</span>
<span class="nc" id="L291">    }</span>

    @Override
    public void writeChars(String s) {
<span class="nc bnc" id="L295" title="All 2 branches missed.">      if (done) {</span>
<span class="nc" id="L296">        return;</span>
      }
<span class="nc" id="L298">      call(++callId, s);</span>
<span class="nc" id="L299">    }</span>

    @Override
    public void writeUTF(String s) {
<span class="pc bpc" id="L303" title="1 of 2 branches missed.">      if (done) {</span>
<span class="nc" id="L304">        return;</span>
      }
<span class="fc" id="L306">      call(++callId, s);</span>
<span class="fc" id="L307">    }</span>

    @Override
    public void writeObject(Object obj) {
<span class="pc bpc" id="L311" title="1 of 2 branches missed.">      if (done) {</span>
<span class="nc" id="L312">        return;</span>
      }
<span class="fc" id="L314">      call(++callId, obj);</span>
<span class="fc" id="L315">    }</span>

    @Override
    public void write(int b) {
<span class="nc bnc" id="L319" title="All 2 branches missed.">      if (done) {</span>
<span class="nc" id="L320">        return;</span>
      }
<span class="nc" id="L322">      call(++callId, b);</span>
<span class="nc" id="L323">    }</span>

    @Override
    public void write(byte[] b) {
<span class="nc bnc" id="L327" title="All 2 branches missed.">      if (done) {</span>
<span class="nc" id="L328">        return;</span>
      }
<span class="nc" id="L330">      call(++callId, b);</span>
<span class="nc" id="L331">    }</span>

    @Override
    public void write(byte[] b, int off, int len) {
<span class="nc bnc" id="L335" title="All 2 branches missed.">      if (done) {</span>
<span class="nc" id="L336">        return;</span>
      }
<span class="nc" id="L338">      setInvalid();</span>
      // NOTE: not yet needed
      // byte[] copy = Arrays.copyOfRange(b, off, off + len);
      // call(++callId, copy);
<span class="nc" id="L342">    }</span>

    @Override
    public void flush() {
<span class="nc" id="L346">    }</span>

    public boolean validate() {
<span class="fc" id="L349">      this.done = true;</span>
<span class="pc bpc" id="L350" title="1 of 2 branches missed.">      if (callId &lt; 3) {</span>
<span class="nc" id="L351">        setInvalid();</span>
      }
<span class="pc bpc" id="L353" title="1 of 2 branches missed.">      return !invalid;</span>
    }

    @Override
    public void close() {
<span class="fc" id="L358">    }</span>
  }

  @Override
  public String toString() {
<span class="nc" id="L363">    return getClass().getName() + &quot;[&quot; + host + &quot;:&quot; + port + &quot;;socketFactory=&quot; + socketFactory</span>
        + &quot;;peerCredentials=&quot; + peerCredentials + &quot;]&quot;;
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>