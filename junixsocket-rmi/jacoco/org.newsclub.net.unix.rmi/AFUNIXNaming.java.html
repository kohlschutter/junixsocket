<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AFUNIXNaming.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">junixsocket-rmi</a> &gt; <a href="index.source.html" class="el_package">org.newsclub.net.unix.rmi</a> &gt; <span class="el_source">AFUNIXNaming.java</span></div><h1>AFUNIXNaming.java</h1><pre class="source lang-java linenums">/*
 * junixsocket
 *
 * Copyright 2009-2022 Christian Kohlschütter
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.newsclub.net.unix.rmi;

import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.rmi.Naming;
import java.rmi.RemoteException;
import java.rmi.ServerException;
import java.rmi.registry.Registry;
import java.rmi.server.RMIClientSocketFactory;
import java.rmi.server.RMIServerSocketFactory;
import java.rmi.server.UnicastRemoteObject;
import java.util.Objects;
import java.util.concurrent.TimeUnit;

import org.newsclub.net.unix.AFUNIXSocket;

/**
 * The {@link AFUNIXSocket}-compatible equivalent of {@link Naming}. Use this class for accessing
 * RMI registries that are reachable by {@link AFUNIXSocket}s.
 * 
 * @author Christian Kohlschütter
 */
public final class AFUNIXNaming extends AFNaming {
  private static final String PROP_RMI_SOCKET_DIR = &quot;org.newsclub.net.unix.rmi.socketdir&quot;;
<span class="fc" id="L43">  private static final File DEFAULT_SOCKET_DIRECTORY = new File(System.getProperty(</span>
      PROP_RMI_SOCKET_DIR, &quot;/tmp&quot;));

<span class="fc" id="L46">  private boolean deleteRegistrySocketDir = false;</span>
  private final File registrySocketDir;

  private final RMIClientSocketFactory defaultClientSocketFactory;
  private final RMIServerSocketFactory defaultServerSocketFactory;

  private final String socketPrefix;
  private final String socketSuffix;

  private AFUNIXNaming(File socketDir, int registryPort, String socketPrefix, String socketSuffix)
      throws IOException {
<span class="fc" id="L57">    super(registryPort, RMIPorts.RMI_SERVICE_PORT);</span>
<span class="fc" id="L58">    Objects.requireNonNull(socketDir);</span>
<span class="fc" id="L59">    this.registrySocketDir = socketDir;</span>
<span class="fc" id="L60">    this.socketPrefix = socketPrefix;</span>
<span class="fc" id="L61">    this.socketSuffix = socketSuffix;</span>

<span class="fc" id="L63">    this.defaultClientSocketFactory = null; // DefaultRMIClientSocketFactory.getInstance();</span>
<span class="fc" id="L64">    this.defaultServerSocketFactory = null; // DefaultRMIServerSocketFactory.getInstance();</span>
<span class="fc" id="L65">  }</span>

  /**
   * Returns the directory where RMI sockets are stored by default.
   * 
   * You can configure this location by setting the System property
   * {@code org.newsclub.net.unix.rmi.socketdir} upon start.
   * 
   * @return The directory.
   */
  public static File getDefaultSocketDirectory() {
<span class="fc" id="L76">    return DEFAULT_SOCKET_DIRECTORY;</span>
  }

  /**
   * Returns a new private instance that resides in a custom location, to avoid any collisions with
   * existing instances.
   * 
   * @return The private {@link AFNaming} instance.
   * @throws IOException if the operation fails.
   */
  public static AFUNIXNaming newPrivateInstance() throws IOException {
<span class="fc" id="L87">    File tmpDir = Files.createTempDirectory(&quot;junixsocket-&quot;).toFile();</span>
<span class="pc bpc" id="L88" title="1 of 2 branches missed.">    if (!tmpDir.canWrite()) {</span>
<span class="nc" id="L89">      throw new IOException(&quot;Could not create temporary directory: &quot; + tmpDir);</span>
    }
<span class="fc" id="L91">    AFUNIXNaming instance = getInstance(tmpDir, RMIPorts.DEFAULT_REGISTRY_PORT);</span>
<span class="fc" id="L92">    synchronized (instance) {</span>
<span class="fc" id="L93">      instance.deleteRegistrySocketDir = true;</span>
<span class="fc" id="L94">    }</span>
<span class="fc" id="L95">    return instance;</span>
  }

  /**
   * Returns the default instance of {@link AFUNIXNaming}. Sockets are stored in
   * &lt;code&gt;java.io.tmpdir&lt;/code&gt;.
   * 
   * @return The default instance.
   * @throws IOException if the operation fails.
   */
  public static AFUNIXNaming getInstance() throws IOException {
<span class="fc" id="L106">    return getInstance(DEFAULT_SOCKET_DIRECTORY, RMIPorts.DEFAULT_REGISTRY_PORT);</span>
  }

  /**
   * Returns a {@link AFUNIXNaming} instance which support several socket files that can be stored
   * under the same, given directory.
   * 
   * @param socketDir The directory to store sockets in.
   * @return The instance.
   * @throws RemoteException if the operation fails.
   */
  public static AFUNIXNaming getInstance(final File socketDir) throws RemoteException {
<span class="fc" id="L118">    return getInstance(socketDir, RMIPorts.DEFAULT_REGISTRY_PORT);</span>
  }

  /**
   * Returns a {@link AFUNIXNaming} instance which support several socket files that can be stored
   * under the same, given directory.
   * 
   * A custom &quot;registry port&quot; can be specified. Typically, AF-UNIX specific ports should be above
   * {@code 100000}.
   * 
   * @param socketDir The directory to store sockets in.
   * @param registryPort The registry port. Should be above {@code 100000}.
   * @return The instance.
   * @throws RemoteException if the operation fails.
   */
  public static AFUNIXNaming getInstance(File socketDir, final int registryPort)
      throws RemoteException {
<span class="fc" id="L135">    return getInstance(socketDir, registryPort, null, null);</span>
  }

  /**
   * Returns a {@link AFUNIXNaming} instance which support several socket files that can be stored
   * under the same, given directory.
   * 
   * A custom &quot;registry port&quot; can be specified. Typically, AF-UNIX specific ports should be above
   * {@code 100000}.
   * 
   * @param socketDir The directory to store sockets in.
   * @param registryPort The registry port. Should be above {@code 100000}.
   * @param socketPrefix A string to be inserted at the beginning of each socket filename, or
   *          {@code null}.
   * @param socketSuffix A string to be added at the end of each socket filename, or {@code null}.
   * @return The instance.
   * @throws RemoteException if the operation fails.
   */
  public static AFUNIXNaming getInstance(File socketDir, final int registryPort,
      String socketPrefix, String socketSuffix) throws RemoteException {
<span class="fc" id="L155">    return AFNaming.getInstance(registryPort, new AFUNIXNamingProvider(socketDir, socketPrefix,</span>
        socketSuffix));
  }

  private static final class AFUNIXNamingProvider implements AFNamingProvider&lt;AFUNIXNaming&gt; {
    private final File socketDir;
    private final String socketPrefix;
    private final String socketSuffix;

    public AFUNIXNamingProvider(File socketDir, String socketPrefix, String socketSuffix)
<span class="fc" id="L165">        throws RemoteException {</span>
      try {
<span class="fc" id="L167">        this.socketDir = socketDir.getCanonicalFile();</span>
<span class="nc" id="L168">      } catch (IOException e) {</span>
<span class="nc" id="L169">        throw new RemoteException(e.getMessage(), e);</span>
<span class="fc" id="L170">      }</span>
<span class="pc bpc" id="L171" title="1 of 2 branches missed.">      this.socketPrefix = socketPrefix == null ? AFUNIXRMISocketFactory.DEFAULT_SOCKET_FILE_PREFIX</span>
<span class="pc" id="L172">          : socketPrefix;</span>
<span class="pc bpc" id="L173" title="1 of 2 branches missed.">      this.socketSuffix = socketSuffix == null ? AFUNIXRMISocketFactory.DEFAULT_SOCKET_FILE_SUFFIX</span>
<span class="pc" id="L174">          : socketSuffix;</span>
<span class="fc" id="L175">    }</span>

    @Override
    public AFUNIXNaming newInstance(int port) throws IOException {
<span class="fc" id="L179">      return new AFUNIXNaming(socketDir, port, socketPrefix, socketSuffix); // NOPMD</span>
    }
  }

  /**
   * Returns an {@link AFUNIXNaming} instance which only supports one file. (Probably only useful
   * when you want/can access the exported {@link UnicastRemoteObject} directly)
   * 
   * @param socketFile The socket file.
   * @return The instance.
   * @throws IOException if the operation fails.
   */
  public static AFNaming getSingleFileInstance(final File socketFile) throws IOException {
<span class="nc" id="L192">    return getInstance(socketFile, RMIPorts.PLAIN_FILE_SOCKET);</span>
  }

  @Override
  public AFUNIXRMISocketFactory getSocketFactory() {
<span class="fc" id="L197">    return (AFUNIXRMISocketFactory) super.getSocketFactory();</span>
  }

  @Override
  public AFRegistry getRegistry() throws RemoteException {
<span class="fc" id="L202">    return getRegistry(0, TimeUnit.SECONDS);</span>
  }

  @Override
  public AFUNIXRegistry getRegistry(long timeout, TimeUnit unit) throws RemoteException {
<span class="fc" id="L207">    return (AFUNIXRegistry) super.getRegistry(timeout, unit);</span>
  }

  @Override
  public AFUNIXRegistry getRegistry(boolean create) throws RemoteException {
<span class="fc" id="L212">    return (AFUNIXRegistry) super.getRegistry(create);</span>
  }

  @Override
  public AFUNIXRegistry createRegistry() throws RemoteException {
<span class="fc" id="L217">    return (AFUNIXRegistry) super.createRegistry();</span>
  }

  /**
   * Returns the socket file which is used to control the RMI registry.
   *
   * The file is usually in the directory returned by {@link #getRegistrySocketDir()}.
   * 
   * @return The directory.
   */
  public File getRegistrySocketFile() {
<span class="fc" id="L228">    return getSocketFactory().getFile(getRegistryPort());</span>
  }

  @Override
  protected AFUNIXRMISocketFactory initSocketFactory() throws IOException {
<span class="fc" id="L233">    return new AFUNIXRMISocketFactory(this, registrySocketDir, defaultClientSocketFactory,</span>
        defaultServerSocketFactory, socketPrefix, socketSuffix);
  }

  @Override
  protected AFUNIXRegistry newAFRegistry(Registry impl) throws RemoteException {
<span class="fc" id="L239">    return new AFUNIXRegistry(this, impl);</span>
  }

  @Override
  protected AFRegistry openRegistry(long timeout, TimeUnit unit) throws RemoteException {
<span class="fc" id="L244">    File socketFile = getRegistrySocketFile();</span>
<span class="pc bpc" id="L245" title="1 of 2 branches missed.">    if (!socketFile.exists()) {</span>
<span class="fc bfc" id="L246" title="All 2 branches covered.">      if (waitUntilFileExists(socketFile, timeout, unit)) {</span>
<span class="fc" id="L247">        AFRegistry reg = getRegistry(false);</span>
<span class="pc bpc" id="L248" title="1 of 2 branches missed.">        if (reg != null) {</span>
<span class="fc" id="L249">          return reg;</span>
        }
      }
    }
<span class="fc" id="L253">    throw new ShutdownException(&quot;Could not find registry at &quot; + getRegistrySocketFile());</span>
  }

  private boolean waitUntilFileExists(File f, long timeout, TimeUnit unit) {
<span class="fc" id="L257">    long timeWait = unit.toMillis(timeout);</span>

    try {
<span class="fc bfc" id="L260" title="All 4 branches covered.">      while (timeWait &gt; 0 &amp;&amp; !f.exists()) {</span>
<span class="fc" id="L261">        Thread.sleep(Math.min(50, timeWait));</span>
<span class="fc" id="L262">        timeWait -= 50;</span>
      }
<span class="nc" id="L264">    } catch (InterruptedException e) {</span>
      // ignored
<span class="fc" id="L266">    }</span>

<span class="fc" id="L268">    return f.exists();</span>
  }

  private synchronized void deleteSocketDir() {
<span class="pc bpc" id="L272" title="2 of 4 branches missed.">    if (deleteRegistrySocketDir &amp;&amp; registrySocketDir != null) {</span>
      try {
<span class="fc" id="L274">        Files.delete(registrySocketDir.toPath());</span>
<span class="nc" id="L275">      } catch (IOException e) {</span>
        // ignore
<span class="fc" id="L277">      }</span>
    }
<span class="fc" id="L279">  }</span>

  @Override
  protected void shutdownRegistryFinishingTouches() {
<span class="fc" id="L283">    deleteSocketDir();</span>
<span class="fc" id="L284">  }</span>

  /**
   * Returns the directory in which sockets used by this registry are located.
   * 
   * @return The directory.
   */
  public File getRegistrySocketDir() {
<span class="fc" id="L292">    return registrySocketDir;</span>
  }

  @Override
  protected void initRegistryPrerequisites() throws ServerException {
<span class="pc bpc" id="L297" title="1 of 4 branches missed.">    if (registrySocketDir != null &amp;&amp; !registrySocketDir.mkdirs() &amp;&amp; !registrySocketDir</span>
<span class="pc bpc" id="L298" title="1 of 2 branches missed.">        .isDirectory()) {</span>
<span class="nc" id="L299">      throw new ServerException(&quot;Cannot create socket directory:&quot; + registrySocketDir);</span>
    }
<span class="fc" id="L301">  }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>