<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AFNaming.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">junixsocket-rmi</a> &gt; <a href="index.source.html" class="el_package">org.newsclub.net.unix.rmi</a> &gt; <span class="el_source">AFNaming.java</span></div><h1>AFNaming.java</h1><pre class="source lang-java linenums">/*
 * junixsocket
 *
 * Copyright 2009-2024 Christian Kohlschütter
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.newsclub.net.unix.rmi;

import java.io.Closeable;
import java.io.IOException;
import java.net.MalformedURLException;
import java.rmi.AccessException;
import java.rmi.AlreadyBoundException;
import java.rmi.ConnectIOException;
import java.rmi.Naming;
import java.rmi.NoSuchObjectException;
import java.rmi.NotBoundException;
import java.rmi.Remote;
import java.rmi.RemoteException;
import java.rmi.ServerException;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;
import java.rmi.server.RMISocketFactory;
import java.rmi.server.UnicastRemoteObject;
import java.util.HashMap;
import java.util.Map;
import java.util.Objects;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;

import org.eclipse.jdt.annotation.NonNull;
import org.newsclub.net.unix.AFSocket;
import org.newsclub.net.unix.rmi.ShutdownHookSupport.ShutdownHook;

import com.kohlschutter.annotations.compiletime.SuppressFBWarnings;

/**
 * The {@link AFSocket}-compatible equivalent of {@link Naming}. Use this class for accessing RMI
 * registries that are reachable by {@link AFSocket}s.
 *
 * @author Christian Kohlschütter
 */
public abstract class AFNaming extends AFRegistryAccess {
<span class="fc" id="L55">  private static final String RMI_SERVICE_NAME = AFRMIService.class.getName();</span>

<span class="fc" id="L57">  private static final Map&lt;AFNamingRef, AFNaming&gt; INSTANCES = new HashMap&lt;&gt;();</span>

<span class="fc" id="L59">  private AFRegistry registry = null;</span>
<span class="fc" id="L60">  private AFRMIService rmiService = null;</span>
  private final int registryPort;
  private final int servicePort;
  AFRMISocketFactory socketFactory;
<span class="fc" id="L64">  private final AtomicBoolean remoteShutdownAllowed = new AtomicBoolean(true);</span>
<span class="fc" id="L65">  private final AtomicBoolean shutdownInProgress = new AtomicBoolean(false);</span>
<span class="fc" id="L66">  private final AtomicBoolean addedShutdownHook = new AtomicBoolean(false);</span>

  /**
   * Creates a new naming instance with the given ports.
   *
   * @param registryPort The registry port.
   * @param servicePort The port for AFRMIService.
   */
  protected AFNaming(final int registryPort, final int servicePort) {
<span class="fc" id="L75">    super();</span>
<span class="fc" id="L76">    this.registryPort = registryPort;</span>
<span class="fc" id="L77">    this.servicePort = servicePort;</span>
<span class="fc" id="L78">  }</span>

  /**
   * Creates a new {@link AFRegistry} given a {@link Registry} implementation.
   *
   * @param impl The implementation.
   * @return The new {@link AFRegistry} instance.
   * @throws RemoteException on error.
   */
  protected abstract AFRegistry newAFRegistry(Registry impl) throws RemoteException;

  /**
   * Creates or returns the {@link AFRMISocketFactory} to be used with this instance.
   *
   * @return The socket factory.
   * @throws IOException on error.
   */
  protected abstract AFRMISocketFactory initSocketFactory() throws IOException;

  @SuppressWarnings(&quot;unchecked&quot;)
  static &lt;T extends AFNaming&gt; T getInstance(final int registryPort,
      @NonNull AFNamingProvider&lt;T&gt; provider) throws RemoteException {
<span class="fc" id="L100">    Objects.requireNonNull(provider);</span>
<span class="fc" id="L101">    final AFNamingRef sap = new AFNamingRef(provider, registryPort);</span>
    T instance;
<span class="fc" id="L103">    synchronized (AFNaming.class) {</span>
<span class="fc" id="L104">      instance = (T) INSTANCES.get(sap);</span>
<span class="pc bpc" id="L105" title="1 of 2 branches missed.">      if (instance == null) {</span>
        try {
<span class="fc" id="L107">          instance = provider.newInstance(registryPort);</span>
<span class="fc" id="L108">          Objects.requireNonNull(instance);</span>
<span class="fc" id="L109">          synchronized (instance) {</span>
<span class="fc" id="L110">            instance.socketFactory = instance.initSocketFactory();</span>
<span class="fc" id="L111">          }</span>
<span class="nc" id="L112">        } catch (RemoteException e) {</span>
<span class="nc" id="L113">          throw e;</span>
<span class="nc" id="L114">        } catch (IOException e) {</span>
<span class="nc" id="L115">          throw new RemoteException(e.getMessage(), e);</span>
<span class="fc" id="L116">        }</span>
<span class="fc" id="L117">        INSTANCES.put(sap, instance);</span>
      }
<span class="fc" id="L119">    }</span>
<span class="fc" id="L120">    return instance;</span>
  }

  /**
   * Returns the {@link AFRMISocketFactory} associated with this instance.
   *
   * @return The {@link AFRMISocketFactory}.
   */
  @SuppressFBWarnings(&quot;EI_EXPOSE_REP&quot;)
  public synchronized AFRMISocketFactory getSocketFactory() {
<span class="fc" id="L130">    return socketFactory;</span>
  }

  /**
   * Returns the registry port.
   *
   * @return The port.
   */
  public final int getRegistryPort() {
<span class="fc" id="L139">    return registryPort;</span>
  }

  AFRMIService getRMIService() throws RemoteException, NotBoundException {
<span class="fc" id="L143">    return getRMIService(getRegistry());</span>
  }

  synchronized AFRMIService getRMIService(AFRegistry reg) throws RemoteException,
      NotBoundException {
<span class="fc bfc" id="L148" title="All 2 branches covered.">    if (rmiService == null) {</span>
<span class="fc" id="L149">      this.rmiService = getRMIServiceFromRegistry(reg);</span>
    }
<span class="fc" id="L151">    return rmiService;</span>
  }

  AFRMIService getRMIServiceFromRegistry(AFRegistry reg) throws RemoteException, NotBoundException {
    AFRMIService service;
<span class="fc" id="L156">    service = (AFRMIService) reg.lookup(RMI_SERVICE_NAME, 5, TimeUnit.SECONDS);</span>
<span class="fc" id="L157">    this.remoteShutdownAllowed.set(service.isShutdownAllowed());</span>
<span class="fc" id="L158">    return service;</span>
  }

  private void closeUponRuntimeShutdown() {
<span class="fc bfc" id="L162" title="All 2 branches covered.">    if (addedShutdownHook.compareAndSet(false, true)) {</span>
<span class="fc" id="L163">      ShutdownHookSupport.addWeakShutdownHook(new ShutdownHook() {</span>

        @Override
        @SuppressWarnings(&quot;LockOnNonEnclosingClassLiteral&quot; /* errorprone */)
        public synchronized void onRuntimeShutdown(Thread thread) throws IOException {
<span class="pc bpc" id="L168" title="3 of 4 branches missed.">          if (registry != null &amp;&amp; registry.isLocal()) {</span>
<span class="nc" id="L169">            shutdownRegistry();</span>
          }
<span class="fc" id="L171">        }</span>
      });
    }
<span class="fc" id="L174">  }</span>

  private synchronized void rebindRMIService(final AFRMIService assigner) throws RemoteException {
<span class="fc" id="L177">    rmiService = assigner;</span>
<span class="fc" id="L178">    getRegistry().rebind(RMI_SERVICE_NAME, assigner);</span>
<span class="fc" id="L179">  }</span>

  @Override
  public AFRegistry getRegistry() throws RemoteException {
<span class="nc" id="L183">    return getRegistry(0, TimeUnit.SECONDS);</span>
  }

  /**
   * Returns a reference to the existing RMI registry.
   *
   * If there's no registry running at this port after waiting for up to the given time, an
   * exception is thrown.
   *
   * @param timeout The timeout value.
   * @param unit The timeout unit.
   * @return The registry.
   * @throws RemoteException If there was a problem.
   */
  public AFRegistry getRegistry(long timeout, TimeUnit unit) throws RemoteException {
<span class="pc bpc" id="L198" title="1 of 2 branches missed.">    if (shutdownInProgress.get()) {</span>
<span class="nc" id="L199">      throw new ShutdownException();</span>
    }
<span class="fc" id="L201">    synchronized (this) {</span>
<span class="fc" id="L202">      AFRegistry reg = getRegistry(false);</span>
<span class="fc bfc" id="L203" title="All 2 branches covered.">      if (reg == null) {</span>
<span class="fc" id="L204">        reg = openRegistry(timeout, unit);</span>
      }
<span class="fc" id="L206">      return reg;</span>
    }
  }

  /**
   * Tries to access the registry, waiting some time if necessary.
   *
   * @param timeout The timeout.
   * @param unit The unit for the timeout.
   * @return The registry instance.
   * @throws RemoteException on error.
   */
  protected abstract AFRegistry openRegistry(long timeout, TimeUnit unit) throws RemoteException;

  /**
   * Returns a reference to the RMI registry, or {@code null}.
   *
   * If there's no registry running at this port, and {@code create} is set to {@code true}, a new
   * one is created; when {@code create} is set to {@code false}, {@code null} is returned.
   *
   * @param create {@code true} if a new register may be created if necessary.
   * @return The registry, or {@code null}
   * @throws RemoteException If there was a problem.
   */
  public AFRegistry getRegistry(boolean create) throws RemoteException {
<span class="pc bpc" id="L231" title="1 of 2 branches missed.">    if (shutdownInProgress.get()) {</span>
<span class="nc" id="L232">      throw new ShutdownException();</span>
    }
<span class="fc" id="L234">    synchronized (this) {</span>
<span class="fc bfc" id="L235" title="All 2 branches covered.">      if (registry != null) {</span>
<span class="fc" id="L236">        return registry;</span>
<span class="fc bfc" id="L237" title="All 2 branches covered.">      } else if (!socketFactory.hasRegisteredPort(registryPort)) {</span>
<span class="pc bpc" id="L238" title="1 of 2 branches missed.">        return create ? createRegistry() : null;</span>
      }

<span class="fc" id="L241">      AFRegistry reg = locateRegistry();</span>
<span class="fc" id="L242">      setRegistry(reg);</span>

      try {
<span class="fc" id="L245">        getRMIService(reg);</span>
<span class="nc" id="L246">      } catch (NotBoundException | NoSuchObjectException | ConnectIOException e) {</span>
<span class="nc bnc" id="L247" title="All 2 branches missed.">        if (create) {</span>
<span class="nc" id="L248">          setRegistry(null);</span>
<span class="nc" id="L249">          return createRegistry();</span>
        } else {
<span class="nc" id="L251">          throw new ServerException(&quot;Could not access &quot; + AFRMIService.class.getName(), e);</span>
        }
<span class="fc" id="L253">      }</span>

<span class="fc" id="L255">      return registry;</span>
    }
  }

  private AFRegistry locateRegistry() throws RemoteException {
<span class="fc" id="L260">    Registry regImpl = LocateRegistry.getRegistry(null, registryPort, socketFactory);</span>
<span class="pc bpc" id="L261" title="1 of 2 branches missed.">    return regImpl == null ? null : newAFRegistry(regImpl);</span>
  }

  /**
   * Shuts this RMI Registry down.
   *
   * @throws RemoteException if the operation fails.
   */
  public void shutdownRegistry() throws RemoteException {
<span class="fc" id="L270">    synchronized (this) {</span>
<span class="pc bpc" id="L271" title="1 of 2 branches missed.">      if (registry == null) {</span>
<span class="nc" id="L272">        return;</span>
      }

<span class="fc" id="L275">      AFRegistry registryToBeClosed = registry;</span>
<span class="fc" id="L276">      AFRMIService rmiServiceToBeClosed = rmiService;</span>

<span class="fc bfc" id="L278" title="All 2 branches covered.">      if (!registryToBeClosed.isLocal()) {</span>
<span class="fc bfc" id="L279" title="All 2 branches covered.">        if (!isRemoteShutdownAllowed()) {</span>
<span class="fc" id="L280">          throw new ServerException(&quot;The server refuses to be shutdown remotely&quot;);</span>
        }
<span class="fc" id="L282">        setRegistry(null);</span>

        try {
<span class="fc" id="L285">          shutdownViaRMIService(registryToBeClosed, rmiServiceToBeClosed);</span>
<span class="nc" id="L286">        } catch (Exception e) {</span>
          // ignore
<span class="fc" id="L288">        }</span>
<span class="fc" id="L289">        return;</span>
      }

<span class="fc" id="L292">      setRegistry(null);</span>

<span class="pc bpc" id="L294" title="1 of 2 branches missed.">      if (!shutdownInProgress.compareAndSet(false, true)) {</span>
<span class="nc" id="L295">        return;</span>
      }
      try {
<span class="fc" id="L298">        unexportRMIService(registryToBeClosed, (AFRMIServiceImpl) rmiServiceToBeClosed);</span>
<span class="fc" id="L299">        forceUnexportBound(registryToBeClosed);</span>
<span class="fc" id="L300">        closeSocketFactory();</span>
<span class="fc" id="L301">        shutdownRegistryFinishingTouches();</span>
      } finally {
<span class="fc" id="L303">        shutdownInProgress.set(false);</span>
      }
<span class="fc" id="L305">    }</span>
<span class="fc" id="L306">  }</span>

  /**
   * Called by {@link #shutdownRegistry()} as the final step.
   */
  protected abstract void shutdownRegistryFinishingTouches();

  private synchronized void unexportRMIService(AFRegistry reg, AFRMIServiceImpl serv)
      throws AccessException, RemoteException {
<span class="pc bpc" id="L315" title="1 of 2 branches missed.">    if (serv != null) {</span>
<span class="fc" id="L316">      serv.shutdownRegisteredCloseables();</span>
    }

    try {
<span class="pc bpc" id="L320" title="1 of 2 branches missed.">      if (serv != null) {</span>
<span class="fc" id="L321">        unexportObject(serv);</span>
      }
<span class="fc" id="L323">      reg.unbind(RMI_SERVICE_NAME);</span>
<span class="nc" id="L324">    } catch (ShutdownException | NotBoundException e) {</span>
      // ignore
<span class="fc" id="L326">    }</span>
<span class="fc" id="L327">    this.rmiService = null;</span>
<span class="fc" id="L328">  }</span>

  private void forceUnexportBound(AFRegistry reg) {
    try {
<span class="fc" id="L332">      reg.forceUnexportBound();</span>
<span class="nc" id="L333">    } catch (Exception e) {</span>
      // ignore
<span class="fc" id="L335">    }</span>
<span class="fc" id="L336">  }</span>

  private void closeSocketFactory() {
<span class="pc bpc" id="L339" title="1 of 2 branches missed.">    if (socketFactory != null) {</span>
      try {
<span class="fc" id="L341">        socketFactory.close();</span>
<span class="nc" id="L342">      } catch (IOException e) {</span>
        // ignore
<span class="fc" id="L344">      }</span>
    }
<span class="fc" id="L346">  }</span>

  private void shutdownViaRMIService(AFRegistry reg, AFRMIService serv) throws RemoteException {
    try {
<span class="pc bpc" id="L350" title="1 of 2 branches missed.">      if (serv == null) {</span>
<span class="nc" id="L351">        serv = getRMIService(reg);</span>
      }
<span class="pc bpc" id="L353" title="1 of 2 branches missed.">      if (serv.isShutdownAllowed()) {</span>
<span class="fc" id="L354">        serv.shutdown();</span>
      }
<span class="nc" id="L356">    } catch (ServerException | ConnectIOException | NotBoundException e) {</span>
      // ignore
<span class="fc" id="L358">    }</span>
<span class="fc" id="L359">  }</span>

  /**
   * Creates a new RMI {@link Registry}.
   *
   * If there already was a registry created previously, it is shut down and replaced by the current
   * one.
   *
   * Use {@link #getRegistry()} to try to reuse an existing registry.
   *
   * @return The registry
   * @throws RemoteException if the operation fails.
   * @see #getRegistry()
   */
  public synchronized AFRegistry createRegistry() throws RemoteException {
<span class="fc" id="L374">    AFRegistry existingRegistry = registry;</span>
<span class="fc bfc" id="L375" title="All 2 branches covered.">    if (existingRegistry == null) {</span>
      try {
<span class="fc" id="L377">        existingRegistry = getRegistry(false);</span>
<span class="nc" id="L378">      } catch (ServerException e) {</span>
<span class="nc" id="L379">        Throwable cause = e.getCause();</span>
<span class="nc bnc" id="L380" title="All 4 branches missed.">        if (cause instanceof NotBoundException || cause instanceof ConnectIOException) {</span>
<span class="nc" id="L381">          existingRegistry = null;</span>
        } else {
<span class="nc" id="L383">          throw e;</span>
        }
<span class="fc" id="L385">      }</span>
    }
<span class="fc bfc" id="L387" title="All 2 branches covered.">    if (existingRegistry != null) {</span>
<span class="pc bpc" id="L388" title="1 of 2 branches missed.">      if (!isRemoteShutdownAllowed()) {</span>
<span class="nc" id="L389">        throw new ServerException(&quot;The server refuses to be shutdown remotely&quot;);</span>
      }
<span class="fc" id="L391">      shutdownRegistry();</span>
    }

<span class="fc" id="L394">    initRegistryPrerequisites();</span>
<span class="fc" id="L395">    AFRegistry newAFRegistry = newAFRegistry(LocateRegistry.createRegistry(registryPort,</span>
        socketFactory, socketFactory));
<span class="fc" id="L397">    setRegistry(newAFRegistry);</span>

<span class="fc" id="L399">    final AFRMIService service = new AFRMIServiceImpl(this);</span>
<span class="fc" id="L400">    UnicastRemoteObject.exportObject(service, servicePort, socketFactory, socketFactory);</span>

<span class="fc" id="L402">    rebindRMIService(service);</span>

<span class="fc" id="L404">    return registry;</span>
  }

  /**
   * Called by {@link #createRegistry()} right before creating/setting the registry.
   *
   * @throws ServerException on error.
   */
  protected abstract void initRegistryPrerequisites() throws ServerException;

  /**
   * Checks if this {@link AFNaming} instance can be shut down remotely.
   *
   * @return {@code true} if remote shutdown is allowed.
   */
  public boolean isRemoteShutdownAllowed() {
<span class="fc" id="L420">    return remoteShutdownAllowed.get();</span>
  }

  /**
   * Controls whether this {@link AFNaming} instance can be shut down remotely.
   *
   * @param remoteShutdownAllowed {@code true} if remote shutdown is allowed.
   */
  public void setRemoteShutdownAllowed(boolean remoteShutdownAllowed) {
<span class="nc" id="L429">    this.remoteShutdownAllowed.set(remoteShutdownAllowed);</span>
<span class="nc" id="L430">  }</span>

  /**
   * Exports and binds the given Remote object to the given name, using the given {@link AFNaming}
   * setup.
   *
   * @param name The name to use to bind the object in the registry.
   * @param obj The object to export and bind.
   * @throws RemoteException if the operation fails.
   * @throws AlreadyBoundException if there already was something bound at that name
   */
  public void exportAndBind(String name, Remote obj) throws RemoteException, AlreadyBoundException {
<span class="fc" id="L442">    exportObject(obj, getSocketFactory());</span>

<span class="fc" id="L444">    getRegistry().bind(name, obj);</span>
<span class="fc" id="L445">  }</span>

  /**
   * Exports and re-binds the given Remote object to the given name, using the given
   * {@link AFNaming} setup.
   *
   * @param name The name to use to bind the object in the registry.
   * @param obj The object to export and bind.
   * @throws RemoteException if the operation fails.
   */
  public void exportAndRebind(String name, Remote obj) throws RemoteException {
<span class="fc" id="L456">    exportObject(obj, getSocketFactory());</span>

<span class="fc" id="L458">    getRegistry().rebind(name, obj);</span>
<span class="fc" id="L459">  }</span>

  /**
   * Forcibly un-exports the given object, if it exists, and unbinds the object from the registry
   * (otherwise returns without an error).
   *
   * @param name The name used to bind the object.
   * @param obj The object to un-export.
   * @throws RemoteException if the operation fails.
   */
  public void unexportAndUnbind(String name, Remote obj) throws RemoteException {
<span class="fc" id="L470">    unexportObject(obj);</span>
    try {
<span class="fc" id="L472">      unbind(name);</span>
<span class="nc" id="L473">    } catch (MalformedURLException | NotBoundException e) {</span>
      // ignore
<span class="fc" id="L475">    }</span>
<span class="fc" id="L476">  }</span>

  /**
   * Exports the given Remote object, using the given socket factory and a randomly assigned port.
   *
   * NOTE: This helper function can also be used for regular RMI servers.
   *
   * @param obj The object to export.
   * @param socketFactory The socket factory to use.
   * @return The remote stub.
   * @throws RemoteException if the operation fails.
   */
  public static Remote exportObject(Remote obj, RMISocketFactory socketFactory)
      throws RemoteException {
<span class="fc" id="L490">    return UnicastRemoteObject.exportObject(obj, 0, socketFactory, socketFactory);</span>
  }

  /**
   * Forcibly un-exports the given object, if it exists (otherwise returns without an error). This
   * should be called upon closing a {@link Closeable} {@link Remote} object.
   *
   * NOTE: This helper function can also be used for regular RMI servers.
   *
   * @param obj The object to un-export.
   */
  public static void unexportObject(Remote obj) {
    try {
<span class="fc" id="L503">      UnicastRemoteObject.unexportObject(obj, true);</span>
<span class="fc" id="L504">    } catch (NoSuchObjectException e) {</span>
      // ignore
<span class="fc" id="L506">    }</span>
<span class="fc" id="L507">  }</span>

  private synchronized void setRegistry(AFRegistry registry) {
<span class="fc" id="L510">    this.registry = registry;</span>
<span class="fc bfc" id="L511" title="All 2 branches covered.">    if (registry == null) {</span>
<span class="fc" id="L512">      rmiService = null;</span>
<span class="fc bfc" id="L513" title="All 2 branches covered.">    } else if (registry.isLocal()) {</span>
<span class="fc" id="L514">      closeUponRuntimeShutdown();</span>
    }
<span class="fc" id="L516">  }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>