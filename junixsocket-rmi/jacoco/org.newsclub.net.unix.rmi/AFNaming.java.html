<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AFNaming.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">junixsocket-rmi</a> &gt; <a href="index.source.html" class="el_package">org.newsclub.net.unix.rmi</a> &gt; <span class="el_source">AFNaming.java</span></div><h1>AFNaming.java</h1><pre class="source lang-java linenums">/*
 * junixsocket
 *
 * Copyright 2009-2023 Christian Kohlschütter
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.newsclub.net.unix.rmi;

import java.io.Closeable;
import java.io.IOException;
import java.net.MalformedURLException;
import java.rmi.AccessException;
import java.rmi.AlreadyBoundException;
import java.rmi.ConnectIOException;
import java.rmi.Naming;
import java.rmi.NoSuchObjectException;
import java.rmi.NotBoundException;
import java.rmi.Remote;
import java.rmi.RemoteException;
import java.rmi.ServerException;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;
import java.rmi.server.RMISocketFactory;
import java.rmi.server.UnicastRemoteObject;
import java.util.HashMap;
import java.util.Map;
import java.util.Objects;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;

import org.eclipse.jdt.annotation.NonNull;
import org.newsclub.net.unix.AFSocket;
import org.newsclub.net.unix.rmi.ShutdownHookSupport.ShutdownHook;

import com.kohlschutter.annotations.compiletime.SuppressFBWarnings;

/**
 * The {@link AFSocket}-compatible equivalent of {@link Naming}. Use this class for accessing RMI
 * registries that are reachable by {@link AFSocket}s.
 *
 * @author Christian Kohlschütter
 */
public abstract class AFNaming extends AFRegistryAccess {
<span class="fc" id="L55">  private static final String RMI_SERVICE_NAME = AFRMIService.class.getName();</span>

<span class="fc" id="L57">  private static final Map&lt;AFNamingRef, AFNaming&gt; INSTANCES = new HashMap&lt;&gt;();</span>

<span class="fc" id="L59">  private AFRegistry registry = null;</span>
<span class="fc" id="L60">  private AFRMIService rmiService = null;</span>
  private final int registryPort;
  private final int servicePort;
  AFRMISocketFactory socketFactory;
<span class="fc" id="L64">  private final AtomicBoolean remoteShutdownAllowed = new AtomicBoolean(true);</span>
<span class="fc" id="L65">  private final AtomicBoolean shutdownInProgress = new AtomicBoolean(false);</span>
<span class="fc" id="L66">  private final AtomicBoolean addedShutdownHook = new AtomicBoolean(false);</span>

  /**
   * Creates a new naming instance with the given ports.
   *
   * @param registryPort The registry port.
   * @param servicePort The port for AFRMIService.
   * @throws IOException on error.
   */
  protected AFNaming(final int registryPort, final int servicePort) throws IOException {
<span class="fc" id="L76">    super();</span>
<span class="fc" id="L77">    this.registryPort = registryPort;</span>
<span class="fc" id="L78">    this.servicePort = servicePort;</span>
<span class="fc" id="L79">  }</span>

  /**
   * Creates a new {@link AFRegistry} given a {@link Registry} implementation.
   *
   * @param impl The implementation.
   * @return The new {@link AFRegistry} instance.
   * @throws RemoteException on error.
   */
  protected abstract AFRegistry newAFRegistry(Registry impl) throws RemoteException;

  /**
   * Creates or returns the {@link AFRMISocketFactory} to be used with this instance.
   *
   * @return The socket factory.
   * @throws IOException on error.
   */
  protected abstract AFRMISocketFactory initSocketFactory() throws IOException;

  @SuppressWarnings(&quot;unchecked&quot;)
  static &lt;T extends AFNaming&gt; T getInstance(final int registryPort,
      @NonNull AFNamingProvider&lt;T&gt; provider) throws RemoteException {
<span class="fc" id="L101">    Objects.requireNonNull(provider);</span>
<span class="fc" id="L102">    final AFNamingRef sap = new AFNamingRef(provider, registryPort);</span>
    T instance;
<span class="fc" id="L104">    synchronized (AFNaming.class) {</span>
<span class="fc" id="L105">      instance = (T) INSTANCES.get(sap);</span>
<span class="pc bpc" id="L106" title="1 of 2 branches missed.">      if (instance == null) {</span>
        try {
<span class="fc" id="L108">          instance = provider.newInstance(registryPort);</span>
<span class="fc" id="L109">          Objects.requireNonNull(instance);</span>
<span class="fc" id="L110">          synchronized (instance) {</span>
<span class="fc" id="L111">            instance.socketFactory = instance.initSocketFactory();</span>
<span class="fc" id="L112">          }</span>
<span class="nc" id="L113">        } catch (RemoteException e) {</span>
<span class="nc" id="L114">          throw e;</span>
<span class="nc" id="L115">        } catch (IOException e) {</span>
<span class="nc" id="L116">          throw new RemoteException(e.getMessage(), e);</span>
<span class="fc" id="L117">        }</span>
<span class="fc" id="L118">        INSTANCES.put(sap, instance);</span>
      }
<span class="fc" id="L120">    }</span>
<span class="fc" id="L121">    return instance;</span>
  }

  /**
   * Returns the {@link AFRMISocketFactory} associated with this instance.
   *
   * @return The {@link AFRMISocketFactory}.
   */
  @SuppressFBWarnings(&quot;EI_EXPOSE_REP&quot;)
  public synchronized AFRMISocketFactory getSocketFactory() {
<span class="fc" id="L131">    return socketFactory;</span>
  }

  /**
   * Returns the registry port.
   *
   * @return The port.
   */
  public final int getRegistryPort() {
<span class="fc" id="L140">    return registryPort;</span>
  }

  AFRMIService getRMIService() throws RemoteException, NotBoundException {
<span class="fc" id="L144">    return getRMIService(getRegistry());</span>
  }

  synchronized AFRMIService getRMIService(AFRegistry reg) throws RemoteException,
      NotBoundException {
<span class="fc bfc" id="L149" title="All 2 branches covered.">    if (rmiService == null) {</span>
<span class="fc" id="L150">      this.rmiService = getRMIServiceFromRegistry(reg);</span>
    }
<span class="fc" id="L152">    return rmiService;</span>
  }

  AFRMIService getRMIServiceFromRegistry(AFRegistry reg) throws RemoteException, NotBoundException {
    AFRMIService service;
<span class="fc" id="L157">    service = (AFRMIService) reg.lookup(RMI_SERVICE_NAME, 5, TimeUnit.SECONDS);</span>
<span class="fc" id="L158">    this.remoteShutdownAllowed.set(service.isShutdownAllowed());</span>
<span class="fc" id="L159">    return service;</span>
  }

  private void closeUponRuntimeShutdown() {
<span class="fc bfc" id="L163" title="All 2 branches covered.">    if (addedShutdownHook.compareAndSet(false, true)) {</span>
<span class="fc" id="L164">      ShutdownHookSupport.addWeakShutdownHook(new ShutdownHook() {</span>

        @Override
        @SuppressWarnings(&quot;LockOnNonEnclosingClassLiteral&quot; /* errorprone */)
        public synchronized void onRuntimeShutdown(Thread thread) throws IOException {
<span class="pc bpc" id="L169" title="3 of 4 branches missed.">          if (registry != null &amp;&amp; registry.isLocal()) {</span>
<span class="nc" id="L170">            shutdownRegistry();</span>
          }
<span class="fc" id="L172">        }</span>
      });
    }
<span class="fc" id="L175">  }</span>

  private synchronized void rebindRMIService(final AFRMIService assigner) throws RemoteException {
<span class="fc" id="L178">    rmiService = assigner;</span>
<span class="fc" id="L179">    getRegistry().rebind(RMI_SERVICE_NAME, assigner);</span>
<span class="fc" id="L180">  }</span>

  @Override
  public AFRegistry getRegistry() throws RemoteException {
<span class="nc" id="L184">    return getRegistry(0, TimeUnit.SECONDS);</span>
  }

  /**
   * Returns a reference to the existing RMI registry.
   *
   * If there's no registry running at this port after waiting for up to the given time, an
   * exception is thrown.
   *
   * @param timeout The timeout value.
   * @param unit The timeout unit.
   * @return The registry.
   * @throws RemoteException If there was a problem.
   */
  public AFRegistry getRegistry(long timeout, TimeUnit unit) throws RemoteException {
<span class="pc bpc" id="L199" title="1 of 2 branches missed.">    if (shutdownInProgress.get()) {</span>
<span class="nc" id="L200">      throw new ShutdownException();</span>
    }
<span class="fc" id="L202">    synchronized (this) {</span>
<span class="fc" id="L203">      AFRegistry reg = getRegistry(false);</span>
<span class="fc bfc" id="L204" title="All 2 branches covered.">      if (reg == null) {</span>
<span class="fc" id="L205">        reg = openRegistry(timeout, unit);</span>
      }
<span class="fc" id="L207">      return reg;</span>
    }
  }

  /**
   * Tries to access the registry, waiting some time if necessary.
   *
   * @param timeout The timeout.
   * @param unit The unit for the timeout.
   * @return The registry instance.
   * @throws RemoteException on error.
   */
  protected abstract AFRegistry openRegistry(long timeout, TimeUnit unit) throws RemoteException;

  /**
   * Returns a reference to the RMI registry, or {@code null}.
   *
   * If there's no registry running at this port, and {@code create} is set to {@code true}, a new
   * one is created; when {@code create} is set to {@code false}, {@code null} is returned.
   *
   * @param create {@code true} if a new register may be created if necessary.
   * @return The registry, or {@code null}
   * @throws RemoteException If there was a problem.
   */
  public AFRegistry getRegistry(boolean create) throws RemoteException {
<span class="pc bpc" id="L232" title="1 of 2 branches missed.">    if (shutdownInProgress.get()) {</span>
<span class="nc" id="L233">      throw new ShutdownException();</span>
    }
<span class="fc" id="L235">    synchronized (this) {</span>
<span class="fc bfc" id="L236" title="All 2 branches covered.">      if (registry != null) {</span>
<span class="fc" id="L237">        return registry;</span>
<span class="fc bfc" id="L238" title="All 2 branches covered.">      } else if (!socketFactory.hasRegisteredPort(registryPort)) {</span>
<span class="pc bpc" id="L239" title="1 of 2 branches missed.">        return create ? createRegistry() : null;</span>
      }

<span class="fc" id="L242">      AFRegistry reg = locateRegistry();</span>
<span class="fc" id="L243">      setRegistry(reg);</span>

      try {
<span class="fc" id="L246">        getRMIService(reg);</span>
<span class="nc" id="L247">      } catch (NotBoundException | NoSuchObjectException | ConnectIOException e) {</span>
<span class="nc bnc" id="L248" title="All 2 branches missed.">        if (create) {</span>
<span class="nc" id="L249">          setRegistry(null);</span>
<span class="nc" id="L250">          return createRegistry();</span>
        } else {
<span class="nc" id="L252">          throw new ServerException(&quot;Could not access &quot; + AFRMIService.class.getName(), e);</span>
        }
<span class="fc" id="L254">      }</span>

<span class="fc" id="L256">      return registry;</span>
    }
  }

  private AFRegistry locateRegistry() throws RemoteException {
<span class="fc" id="L261">    Registry regImpl = LocateRegistry.getRegistry(null, registryPort, socketFactory);</span>
<span class="pc bpc" id="L262" title="1 of 2 branches missed.">    return regImpl == null ? null : newAFRegistry(regImpl);</span>
  }

  /**
   * Shuts this RMI Registry down.
   *
   * @throws RemoteException if the operation fails.
   */
  public void shutdownRegistry() throws RemoteException {
<span class="fc" id="L271">    synchronized (this) {</span>
<span class="pc bpc" id="L272" title="1 of 2 branches missed.">      if (registry == null) {</span>
<span class="nc" id="L273">        return;</span>
      }

<span class="fc" id="L276">      AFRegistry registryToBeClosed = registry;</span>
<span class="fc" id="L277">      AFRMIService rmiServiceToBeClosed = rmiService;</span>

<span class="fc bfc" id="L279" title="All 2 branches covered.">      if (!registryToBeClosed.isLocal()) {</span>
<span class="fc bfc" id="L280" title="All 2 branches covered.">        if (!isRemoteShutdownAllowed()) {</span>
<span class="fc" id="L281">          throw new ServerException(&quot;The server refuses to be shutdown remotely&quot;);</span>
        }
<span class="fc" id="L283">        setRegistry(null);</span>

        try {
<span class="fc" id="L286">          shutdownViaRMIService(registryToBeClosed, rmiServiceToBeClosed);</span>
<span class="nc" id="L287">        } catch (Exception e) {</span>
          // ignore
<span class="fc" id="L289">        }</span>
<span class="fc" id="L290">        return;</span>
      }

<span class="fc" id="L293">      setRegistry(null);</span>

<span class="pc bpc" id="L295" title="1 of 2 branches missed.">      if (!shutdownInProgress.compareAndSet(false, true)) {</span>
<span class="nc" id="L296">        return;</span>
      }
      try {
<span class="fc" id="L299">        unexportRMIService(registryToBeClosed, (AFRMIServiceImpl) rmiServiceToBeClosed);</span>
<span class="fc" id="L300">        forceUnexportBound(registryToBeClosed);</span>
<span class="fc" id="L301">        closeSocketFactory();</span>
<span class="fc" id="L302">        shutdownRegistryFinishingTouches();</span>
      } finally {
<span class="fc" id="L304">        shutdownInProgress.set(false);</span>
      }
<span class="fc" id="L306">    }</span>
<span class="fc" id="L307">  }</span>

  /**
   * Called by {@link #shutdownRegistry()} as the final step.
   */
  protected abstract void shutdownRegistryFinishingTouches();

  private synchronized void unexportRMIService(AFRegistry reg, AFRMIServiceImpl serv)
      throws AccessException, RemoteException {
<span class="pc bpc" id="L316" title="1 of 2 branches missed.">    if (serv != null) {</span>
<span class="fc" id="L317">      serv.shutdownRegisteredCloseables();</span>
    }

    try {
<span class="pc bpc" id="L321" title="1 of 2 branches missed.">      if (serv != null) {</span>
<span class="fc" id="L322">        unexportObject(serv);</span>
      }
<span class="fc" id="L324">      reg.unbind(RMI_SERVICE_NAME);</span>
<span class="nc" id="L325">    } catch (ShutdownException | NotBoundException e) {</span>
      // ignore
<span class="fc" id="L327">    }</span>
<span class="fc" id="L328">    this.rmiService = null;</span>
<span class="fc" id="L329">  }</span>

  private void forceUnexportBound(AFRegistry reg) {
    try {
<span class="fc" id="L333">      reg.forceUnexportBound();</span>
<span class="nc" id="L334">    } catch (Exception e) {</span>
      // ignore
<span class="fc" id="L336">    }</span>
<span class="fc" id="L337">  }</span>

  private void closeSocketFactory() {
<span class="pc bpc" id="L340" title="1 of 2 branches missed.">    if (socketFactory != null) {</span>
      try {
<span class="fc" id="L342">        socketFactory.close();</span>
<span class="nc" id="L343">      } catch (IOException e) {</span>
        // ignore
<span class="fc" id="L345">      }</span>
    }
<span class="fc" id="L347">  }</span>

  private void shutdownViaRMIService(AFRegistry reg, AFRMIService serv) throws RemoteException {
    try {
<span class="pc bpc" id="L351" title="1 of 2 branches missed.">      if (serv == null) {</span>
<span class="nc" id="L352">        serv = getRMIService(reg);</span>
      }
<span class="pc bpc" id="L354" title="1 of 2 branches missed.">      if (serv.isShutdownAllowed()) {</span>
<span class="fc" id="L355">        serv.shutdown();</span>
      }
<span class="nc" id="L357">    } catch (ServerException | ConnectIOException | NotBoundException e) {</span>
      // ignore
<span class="fc" id="L359">    }</span>
<span class="fc" id="L360">  }</span>

  /**
   * Creates a new RMI {@link Registry}.
   *
   * If there already was a registry created previously, it is shut down and replaced by the current
   * one.
   *
   * Use {@link #getRegistry()} to try to reuse an existing registry.
   *
   * @return The registry
   * @throws RemoteException if the operation fails.
   * @see #getRegistry()
   */
  public synchronized AFRegistry createRegistry() throws RemoteException {
<span class="fc" id="L375">    AFRegistry existingRegistry = registry;</span>
<span class="fc bfc" id="L376" title="All 2 branches covered.">    if (existingRegistry == null) {</span>
      try {
<span class="fc" id="L378">        existingRegistry = getRegistry(false);</span>
<span class="nc" id="L379">      } catch (ServerException e) {</span>
<span class="nc" id="L380">        Throwable cause = e.getCause();</span>
<span class="nc bnc" id="L381" title="All 4 branches missed.">        if (cause instanceof NotBoundException || cause instanceof ConnectIOException) {</span>
<span class="nc" id="L382">          existingRegistry = null;</span>
        } else {
<span class="nc" id="L384">          throw e;</span>
        }
<span class="fc" id="L386">      }</span>
    }
<span class="fc bfc" id="L388" title="All 2 branches covered.">    if (existingRegistry != null) {</span>
<span class="pc bpc" id="L389" title="1 of 2 branches missed.">      if (!isRemoteShutdownAllowed()) {</span>
<span class="nc" id="L390">        throw new ServerException(&quot;The server refuses to be shutdown remotely&quot;);</span>
      }
<span class="fc" id="L392">      shutdownRegistry();</span>
    }

<span class="fc" id="L395">    initRegistryPrerequisites();</span>
<span class="fc" id="L396">    AFRegistry newAFRegistry = newAFRegistry(LocateRegistry.createRegistry(registryPort,</span>
        socketFactory, socketFactory));
<span class="fc" id="L398">    setRegistry(newAFRegistry);</span>

<span class="fc" id="L400">    final AFRMIService service = new AFRMIServiceImpl(this);</span>
<span class="fc" id="L401">    UnicastRemoteObject.exportObject(service, servicePort, socketFactory, socketFactory);</span>

<span class="fc" id="L403">    rebindRMIService(service);</span>

<span class="fc" id="L405">    return registry;</span>
  }

  /**
   * Called by {@link #createRegistry()} right before creating/setting the registry.
   *
   * @throws ServerException on error.
   */
  protected abstract void initRegistryPrerequisites() throws ServerException;

  /**
   * Checks if this {@link AFNaming} instance can be shut down remotely.
   *
   * @return {@code true} if remote shutdown is allowed.
   */
  public boolean isRemoteShutdownAllowed() {
<span class="fc" id="L421">    return remoteShutdownAllowed.get();</span>
  }

  /**
   * Controls whether this {@link AFNaming} instance can be shut down remotely.
   *
   * @param remoteShutdownAllowed {@code true} if remote shutdown is allowed.
   */
  public void setRemoteShutdownAllowed(boolean remoteShutdownAllowed) {
<span class="nc" id="L430">    this.remoteShutdownAllowed.set(remoteShutdownAllowed);</span>
<span class="nc" id="L431">  }</span>

  /**
   * Exports and binds the given Remote object to the given name, using the given {@link AFNaming}
   * setup.
   *
   * @param name The name to use to bind the object in the registry.
   * @param obj The object to export and bind.
   * @throws RemoteException if the operation fails.
   * @throws AlreadyBoundException if there already was something bound at that name
   */
  public void exportAndBind(String name, Remote obj) throws RemoteException, AlreadyBoundException {
<span class="fc" id="L443">    exportObject(obj, getSocketFactory());</span>

<span class="fc" id="L445">    getRegistry().bind(name, obj);</span>
<span class="fc" id="L446">  }</span>

  /**
   * Exports and re-binds the given Remote object to the given name, using the given
   * {@link AFNaming} setup.
   *
   * @param name The name to use to bind the object in the registry.
   * @param obj The object to export and bind.
   * @throws RemoteException if the operation fails.
   */
  public void exportAndRebind(String name, Remote obj) throws RemoteException {
<span class="fc" id="L457">    exportObject(obj, getSocketFactory());</span>

<span class="fc" id="L459">    getRegistry().rebind(name, obj);</span>
<span class="fc" id="L460">  }</span>

  /**
   * Forcibly un-exports the given object, if it exists, and unbinds the object from the registry
   * (otherwise returns without an error).
   *
   * @param name The name used to bind the object.
   * @param obj The object to un-export.
   * @throws RemoteException if the operation fails.
   */
  public void unexportAndUnbind(String name, Remote obj) throws RemoteException {
<span class="fc" id="L471">    unexportObject(obj);</span>
    try {
<span class="fc" id="L473">      unbind(name);</span>
<span class="nc" id="L474">    } catch (MalformedURLException | NotBoundException e) {</span>
      // ignore
<span class="fc" id="L476">    }</span>
<span class="fc" id="L477">  }</span>

  /**
   * Exports the given Remote object, using the given socket factory and a randomly assigned port.
   *
   * NOTE: This helper function can also be used for regular RMI servers.
   *
   * @param obj The object to export.
   * @param socketFactory The socket factory to use.
   * @return The remote stub.
   * @throws RemoteException if the operation fails.
   */
  public static Remote exportObject(Remote obj, RMISocketFactory socketFactory)
      throws RemoteException {
<span class="fc" id="L491">    return UnicastRemoteObject.exportObject(obj, 0, socketFactory, socketFactory);</span>
  }

  /**
   * Forcibly un-exports the given object, if it exists (otherwise returns without an error). This
   * should be called upon closing a {@link Closeable} {@link Remote} object.
   *
   * NOTE: This helper function can also be used for regular RMI servers.
   *
   * @param obj The object to un-export.
   */
  public static void unexportObject(Remote obj) {
    try {
<span class="fc" id="L504">      UnicastRemoteObject.unexportObject(obj, true);</span>
<span class="fc" id="L505">    } catch (NoSuchObjectException e) {</span>
      // ignore
<span class="fc" id="L507">    }</span>
<span class="fc" id="L508">  }</span>

  private synchronized void setRegistry(AFRegistry registry) {
<span class="fc" id="L511">    this.registry = registry;</span>
<span class="fc bfc" id="L512" title="All 2 branches covered.">    if (registry == null) {</span>
<span class="fc" id="L513">      rmiService = null;</span>
<span class="fc bfc" id="L514" title="All 2 branches covered.">    } else if (registry.isLocal()) {</span>
<span class="fc" id="L515">      closeUponRuntimeShutdown();</span>
    }
<span class="fc" id="L517">  }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.10.202304240956</span></div></body></html>