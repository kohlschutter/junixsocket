<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>AFNaming.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">junixsocket-codecoverage</a> &gt; <a href="../index.html" class="el_bundle">junixsocket-rmi</a> &gt; <a href="index.source.html" class="el_package">org.newsclub.net.unix.rmi</a> &gt; <span class="el_source">AFNaming.java</span></div><h1>AFNaming.java</h1><pre class="source lang-java linenums">/*
 * junixsocket
 *
 * Copyright 2009-2022 Christian Kohlschütter
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.newsclub.net.unix.rmi;

import java.io.Closeable;
import java.io.IOException;
import java.net.MalformedURLException;
import java.rmi.AccessException;
import java.rmi.AlreadyBoundException;
import java.rmi.ConnectIOException;
import java.rmi.Naming;
import java.rmi.NoSuchObjectException;
import java.rmi.NotBoundException;
import java.rmi.Remote;
import java.rmi.RemoteException;
import java.rmi.ServerException;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;
import java.rmi.server.RMISocketFactory;
import java.rmi.server.UnicastRemoteObject;
import java.util.HashMap;
import java.util.Map;
import java.util.Objects;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;

import org.eclipse.jdt.annotation.NonNull;
import org.newsclub.net.unix.AFSocket;
import org.newsclub.net.unix.rmi.ShutdownHookSupport.ShutdownHook;

import com.kohlschutter.annotations.compiletime.SuppressFBWarnings;

/**
 * The {@link AFSocket}-compatible equivalent of {@link Naming}. Use this class for accessing RMI
 * registries that are reachable by {@link AFSocket}s.
 *
 * @author Christian Kohlschütter
 */
public abstract class AFNaming extends AFRegistryAccess {
<span class="fc" id="L55">  private static final String RMI_SERVICE_NAME = AFRMIService.class.getName();</span>

<span class="fc" id="L57">  private static final Map&lt;AFNamingRef, AFNaming&gt; INSTANCES = new HashMap&lt;&gt;();</span>

<span class="fc" id="L59">  private AFRegistry registry = null;</span>
<span class="fc" id="L60">  private AFRMIService rmiService = null;</span>
  private final int registryPort;
  private final int servicePort;
  AFRMISocketFactory socketFactory;
<span class="fc" id="L64">  private boolean remoteShutdownAllowed = true;</span>
<span class="fc" id="L65">  private final AtomicBoolean shutdownInProgress = new AtomicBoolean(false);</span>
<span class="fc" id="L66">  private final AtomicBoolean addedShutdownHook = new AtomicBoolean(false);</span>

  /**
   * Creates a new naming instance with the given ports.
   *
   * @param registryPort The registry port.
   * @param servicePort The port for AFRMIService.
   * @throws IOException on error.
   */
  protected AFNaming(final int registryPort, final int servicePort) throws IOException {
<span class="fc" id="L76">    super();</span>
<span class="fc" id="L77">    this.registryPort = registryPort;</span>
<span class="fc" id="L78">    this.servicePort = servicePort;</span>
<span class="fc" id="L79">  }</span>

  /**
   * Creates a new {@link AFRegistry} given a {@link Registry} implementation.
   *
   * @param impl The implementation.
   * @return The new {@link AFRegistry} instance.
   * @throws RemoteException on error.
   */
  protected abstract AFRegistry newAFRegistry(Registry impl) throws RemoteException;

  /**
   * Creates or returns the {@link AFRMISocketFactory} to be used with this instance.
   *
   * @return The socket factory.
   * @throws IOException on error.
   */
  protected abstract AFRMISocketFactory initSocketFactory() throws IOException;

  @SuppressWarnings(&quot;unchecked&quot;)
  static &lt;T extends AFNaming&gt; T getInstance(final int registryPort,
      @NonNull AFNamingProvider&lt;T&gt; provider) throws RemoteException {
<span class="fc" id="L101">    Objects.requireNonNull(provider);</span>
<span class="fc" id="L102">    final AFNamingRef sap = new AFNamingRef(provider, registryPort);</span>
    T instance;
<span class="fc" id="L104">    synchronized (AFNaming.class) {</span>
<span class="fc" id="L105">      instance = (T) INSTANCES.get(sap);</span>
<span class="pc bpc" id="L106" title="1 of 2 branches missed.">      if (instance == null) {</span>
        try {
<span class="fc" id="L108">          instance = provider.newInstance(registryPort);</span>
<span class="fc" id="L109">          Objects.requireNonNull(instance);</span>
<span class="fc" id="L110">          instance.socketFactory = instance.initSocketFactory();</span>
<span class="nc" id="L111">        } catch (RemoteException e) {</span>
<span class="nc" id="L112">          throw e;</span>
<span class="nc" id="L113">        } catch (IOException e) {</span>
<span class="nc" id="L114">          throw new RemoteException(e.getMessage(), e);</span>
<span class="fc" id="L115">        }</span>
<span class="fc" id="L116">        INSTANCES.put(sap, instance);</span>
      }
<span class="fc" id="L118">    }</span>
<span class="fc" id="L119">    return instance;</span>
  }

  /**
   * Returns the {@link AFRMISocketFactory} associated with this instance.
   *
   * @return The {@link AFRMISocketFactory}.
   */
  @SuppressFBWarnings(&quot;EI_EXPOSE_REP&quot;)
  public synchronized AFRMISocketFactory getSocketFactory() {
<span class="fc" id="L129">    return socketFactory;</span>
  }

  /**
   * Returns the registry port.
   *
   * @return The port.
   */
  public final int getRegistryPort() {
<span class="fc" id="L138">    return registryPort;</span>
  }

  AFRMIService getRMIService() throws RemoteException, NotBoundException {
<span class="fc" id="L142">    return getRMIService(getRegistry());</span>
  }

  AFRMIService getRMIService(AFRegistry reg) throws RemoteException, NotBoundException {
<span class="fc bfc" id="L146" title="All 2 branches covered.">    if (rmiService == null) {</span>
<span class="fc" id="L147">      this.rmiService = getRMIServiceFromRegistry(reg);</span>
    }
<span class="fc" id="L149">    return rmiService;</span>
  }

  AFRMIService getRMIServiceFromRegistry(AFRegistry reg) throws RemoteException, NotBoundException {
    AFRMIService service;
<span class="fc" id="L154">    service = (AFRMIService) reg.lookup(RMI_SERVICE_NAME, 5, TimeUnit.SECONDS);</span>
<span class="fc" id="L155">    this.remoteShutdownAllowed = service.isShutdownAllowed();</span>
<span class="fc" id="L156">    return service;</span>
  }

  private void closeUponRuntimeShutdown() {
<span class="fc bfc" id="L160" title="All 2 branches covered.">    if (addedShutdownHook.compareAndSet(false, true)) {</span>
<span class="fc" id="L161">      ShutdownHookSupport.addWeakShutdownHook(new ShutdownHook() {</span>

        @Override
        public void onRuntimeShutdown(Thread thread) throws IOException {
<span class="fc" id="L165">          synchronized (AFNaming.class) {</span>
<span class="pc bpc" id="L166" title="1 of 4 branches missed.">            if (registry != null &amp;&amp; registry.isLocal()) {</span>
<span class="nc" id="L167">              shutdownRegistry();</span>
            }
<span class="fc" id="L169">          }</span>
<span class="fc" id="L170">        }</span>
      });
    }
<span class="fc" id="L173">  }</span>

  private void rebindRMIService(final AFRMIService assigner) throws RemoteException {
<span class="fc" id="L176">    rmiService = assigner;</span>
<span class="fc" id="L177">    getRegistry().rebind(RMI_SERVICE_NAME, assigner);</span>
<span class="fc" id="L178">  }</span>

  @Override
  public AFRegistry getRegistry() throws RemoteException {
<span class="nc" id="L182">    return getRegistry(0, TimeUnit.SECONDS);</span>
  }

  /**
   * Returns a reference to the existing RMI registry.
   *
   * If there's no registry running at this port after waiting for up to the given time, an
   * exception is thrown.
   *
   * @param timeout The timeout value.
   * @param unit The timeout unit.
   * @return The registry.
   * @throws RemoteException If there was a problem.
   */
  public AFRegistry getRegistry(long timeout, TimeUnit unit) throws RemoteException {
<span class="fc bfc" id="L197" title="All 2 branches covered.">    if (shutdownInProgress.get()) {</span>
<span class="fc" id="L198">      throw new ShutdownException();</span>
    }
<span class="fc" id="L200">    synchronized (AFNaming.class) {</span>
<span class="fc" id="L201">      AFRegistry reg = getRegistry(false);</span>
<span class="fc bfc" id="L202" title="All 2 branches covered.">      if (reg == null) {</span>
<span class="fc" id="L203">        reg = openRegistry(timeout, unit);</span>
      }
<span class="fc" id="L205">      return reg;</span>
    }
  }

  /**
   * Tries to access the registry, waiting some time if necessary.
   *
   * @param timeout The timeout.
   * @param unit The unit for the timeout.
   * @return The registry instance.
   * @throws RemoteException on error.
   */
  protected abstract AFRegistry openRegistry(long timeout, TimeUnit unit) throws RemoteException;

  /**
   * Returns a reference to the RMI registry, or {@code null}.
   *
   * If there's no registry running at this port, and {@code create} is set to {@code true}, a new
   * one is created; when {@code create} is set to {@code false}, {@code null} is returned.
   *
   * @param create {@code true} if a new register may be created if necessary.
   * @return The registry, or {@code null}
   * @throws RemoteException If there was a problem.
   */
  public AFRegistry getRegistry(boolean create) throws RemoteException {
<span class="pc bpc" id="L230" title="1 of 2 branches missed.">    if (shutdownInProgress.get()) {</span>
<span class="nc" id="L231">      throw new ShutdownException();</span>
    }
<span class="fc" id="L233">    synchronized (AFNaming.class) {</span>
<span class="fc bfc" id="L234" title="All 2 branches covered.">      if (registry != null) {</span>
<span class="fc" id="L235">        return registry;</span>
<span class="fc bfc" id="L236" title="All 2 branches covered.">      } else if (!socketFactory.hasRegisteredPort(registryPort)) {</span>
<span class="pc bpc" id="L237" title="1 of 2 branches missed.">        return create ? createRegistry() : null;</span>
      }

<span class="fc" id="L240">      AFRegistry reg = locateRegistry();</span>
<span class="fc" id="L241">      setRegistry(reg);</span>

      try {
<span class="fc" id="L244">        getRMIService(reg);</span>
<span class="nc" id="L245">      } catch (NotBoundException | NoSuchObjectException | ConnectIOException e) {</span>
<span class="nc bnc" id="L246" title="All 2 branches missed.">        if (create) {</span>
<span class="nc" id="L247">          setRegistry(null);</span>
<span class="nc" id="L248">          return createRegistry();</span>
        } else {
<span class="nc" id="L250">          throw new ServerException(&quot;Could not access &quot; + AFRMIService.class.getName(), e);</span>
        }
<span class="fc" id="L252">      }</span>

<span class="fc" id="L254">      return registry;</span>
    }
  }

  private AFRegistry locateRegistry() throws RemoteException {
<span class="fc" id="L259">    Registry regImpl = LocateRegistry.getRegistry(null, registryPort, socketFactory);</span>
<span class="pc bpc" id="L260" title="1 of 2 branches missed.">    return regImpl == null ? null : newAFRegistry(regImpl);</span>
  }

  /**
   * Shuts this RMI Registry down.
   *
   * @throws RemoteException if the operation fails.
   */
  public void shutdownRegistry() throws RemoteException {
<span class="fc" id="L269">    synchronized (AFNaming.class) {</span>
<span class="pc bpc" id="L270" title="1 of 2 branches missed.">      if (registry == null) {</span>
<span class="nc" id="L271">        return;</span>
      }

<span class="fc" id="L274">      AFRegistry registryToBeClosed = registry;</span>
<span class="fc" id="L275">      AFRMIService rmiServiceToBeClosed = rmiService;</span>

<span class="fc bfc" id="L277" title="All 2 branches covered.">      if (!registryToBeClosed.isLocal()) {</span>
<span class="fc bfc" id="L278" title="All 2 branches covered.">        if (!isRemoteShutdownAllowed()) {</span>
<span class="fc" id="L279">          throw new ServerException(&quot;The server refuses to be shutdown remotely&quot;);</span>
        }
<span class="fc" id="L281">        setRegistry(null);</span>

        try {
<span class="fc" id="L284">          shutdownViaRMIService(registryToBeClosed, rmiServiceToBeClosed);</span>
<span class="nc" id="L285">        } catch (Exception e) {</span>
          // ignore
<span class="fc" id="L287">        }</span>
<span class="fc" id="L288">        return;</span>
      }

<span class="fc" id="L291">      setRegistry(null);</span>

<span class="pc bpc" id="L293" title="1 of 2 branches missed.">      if (!shutdownInProgress.compareAndSet(false, true)) {</span>
<span class="nc" id="L294">        return;</span>
      }
      try {
<span class="fc" id="L297">        unexportRMIService(registryToBeClosed, (AFRMIServiceImpl) rmiServiceToBeClosed);</span>
<span class="fc" id="L298">        forceUnexportBound(registryToBeClosed);</span>
<span class="fc" id="L299">        closeSocketFactory();</span>
<span class="fc" id="L300">        shutdownRegistryFinishingTouches();</span>
      } finally {
<span class="fc" id="L302">        shutdownInProgress.set(false);</span>
      }
<span class="fc" id="L304">    }</span>
<span class="fc" id="L305">  }</span>

  /**
   * Called by {@link #shutdownRegistry()} as the final step.
   */
  protected abstract void shutdownRegistryFinishingTouches();

  private void unexportRMIService(AFRegistry reg, AFRMIServiceImpl serv) throws AccessException,
      RemoteException {
<span class="pc bpc" id="L314" title="1 of 2 branches missed.">    if (serv != null) {</span>
<span class="fc" id="L315">      serv.shutdownRegisteredCloseables();</span>
    }

    try {
<span class="pc bpc" id="L319" title="1 of 2 branches missed.">      if (serv != null) {</span>
<span class="fc" id="L320">        unexportObject(serv);</span>
      }
<span class="fc" id="L322">      reg.unbind(RMI_SERVICE_NAME);</span>
<span class="nc" id="L323">    } catch (ShutdownException | NotBoundException e) {</span>
      // ignore
<span class="fc" id="L325">    }</span>
<span class="fc" id="L326">    this.rmiService = null;</span>
<span class="fc" id="L327">  }</span>

  private void forceUnexportBound(AFRegistry reg) {
    try {
<span class="fc" id="L331">      reg.forceUnexportBound();</span>
<span class="nc" id="L332">    } catch (Exception e) {</span>
      // ignore
<span class="fc" id="L334">    }</span>
<span class="fc" id="L335">  }</span>

  private void closeSocketFactory() {
<span class="pc bpc" id="L338" title="1 of 2 branches missed.">    if (socketFactory != null) {</span>
      try {
<span class="fc" id="L340">        socketFactory.close();</span>
<span class="nc" id="L341">      } catch (IOException e) {</span>
        // ignore
<span class="fc" id="L343">      }</span>
    }
<span class="fc" id="L345">  }</span>

  private void shutdownViaRMIService(AFRegistry reg, AFRMIService serv) throws RemoteException {
    try {
<span class="pc bpc" id="L349" title="1 of 2 branches missed.">      if (serv == null) {</span>
<span class="nc" id="L350">        serv = getRMIService(reg);</span>
      }
<span class="pc bpc" id="L352" title="1 of 2 branches missed.">      if (serv.isShutdownAllowed()) {</span>
<span class="fc" id="L353">        serv.shutdown();</span>
      }
<span class="nc" id="L355">    } catch (ServerException | ConnectIOException | NotBoundException e) {</span>
      // ignore
<span class="fc" id="L357">    }</span>
<span class="fc" id="L358">  }</span>

  /**
   * Creates a new RMI {@link Registry}.
   *
   * If there already was a registry created previously, it is shut down and replaced by the current
   * one.
   *
   * Use {@link #getRegistry()} to try to reuse an existing registry.
   *
   * @return The registry
   * @throws RemoteException if the operation fails.
   * @see #getRegistry()
   */
  public AFRegistry createRegistry() throws RemoteException {
<span class="fc" id="L373">    synchronized (AFNaming.class) {</span>
<span class="fc" id="L374">      AFRegistry existingRegistry = registry;</span>
<span class="fc bfc" id="L375" title="All 2 branches covered.">      if (existingRegistry == null) {</span>
        try {
<span class="fc" id="L377">          existingRegistry = getRegistry(false);</span>
<span class="nc" id="L378">        } catch (ServerException e) {</span>
<span class="nc" id="L379">          Throwable cause = e.getCause();</span>
<span class="nc bnc" id="L380" title="All 4 branches missed.">          if (cause instanceof NotBoundException || cause instanceof ConnectIOException) {</span>
<span class="nc" id="L381">            existingRegistry = null;</span>
          } else {
<span class="nc" id="L383">            throw e;</span>
          }
<span class="fc" id="L385">        }</span>
      }
<span class="fc bfc" id="L387" title="All 2 branches covered.">      if (existingRegistry != null) {</span>
<span class="pc bpc" id="L388" title="1 of 2 branches missed.">        if (!isRemoteShutdownAllowed()) {</span>
<span class="nc" id="L389">          throw new ServerException(&quot;The server refuses to be shutdown remotely&quot;);</span>
        }
<span class="fc" id="L391">        shutdownRegistry();</span>
      }

<span class="fc" id="L394">      initRegistryPrerequisites();</span>

<span class="fc" id="L396">      setRegistry(newAFRegistry(LocateRegistry.createRegistry(registryPort, socketFactory,</span>
          socketFactory)));

<span class="fc" id="L399">      final AFRMIService service = new AFRMIServiceImpl(this);</span>
<span class="fc" id="L400">      UnicastRemoteObject.exportObject(service, servicePort, socketFactory, socketFactory);</span>

<span class="fc" id="L402">      rebindRMIService(service);</span>

<span class="fc" id="L404">      return registry;</span>
    }
  }

  /**
   * Called by {@link #createRegistry()} right before creating/setting the registry.
   *
   * @throws ServerException on error.
   */
  protected abstract void initRegistryPrerequisites() throws ServerException;

  /**
   * Checks if this {@link AFNaming} instance can be shut down remotely.
   *
   * @return {@code true} if remote shutdown is allowed.
   */
  public boolean isRemoteShutdownAllowed() {
<span class="fc" id="L421">    return remoteShutdownAllowed;</span>
  }

  /**
   * Controls whether this {@link AFNaming} instance can be shut down remotely.
   *
   * @param remoteShutdownAllowed {@code true} if remote shutdown is allowed.
   */
  public void setRemoteShutdownAllowed(boolean remoteShutdownAllowed) {
<span class="fc" id="L430">    this.remoteShutdownAllowed = remoteShutdownAllowed;</span>
<span class="fc" id="L431">  }</span>

  /**
   * Exports and binds the given Remote object to the given name, using the given {@link AFNaming}
   * setup.
   *
   * @param name The name to use to bind the object in the registry.
   * @param obj The object to export and bind.
   * @throws RemoteException if the operation fails.
   * @throws AlreadyBoundException if there already was something bound at that name
   */
  public void exportAndBind(String name, Remote obj) throws RemoteException, AlreadyBoundException {
<span class="fc" id="L443">    exportObject(obj, getSocketFactory());</span>

<span class="fc" id="L445">    getRegistry().bind(name, obj);</span>
<span class="fc" id="L446">  }</span>

  /**
   * Exports and re-binds the given Remote object to the given name, using the given
   * {@link AFNaming} setup.
   *
   * @param name The name to use to bind the object in the registry.
   * @param obj The object to export and bind.
   * @throws RemoteException if the operation fails.
   */
  public void exportAndRebind(String name, Remote obj) throws RemoteException {
<span class="fc" id="L457">    exportObject(obj, getSocketFactory());</span>

<span class="fc" id="L459">    getRegistry().rebind(name, obj);</span>
<span class="fc" id="L460">  }</span>

  /**
   * Forcibly un-exports the given object, if it exists, and unbinds the object from the registry
   * (otherwise returns without an error).
   *
   * @param name The name used to bind the object.
   * @param obj The object to un-export.
   * @throws RemoteException if the operation fails.
   */
  public void unexportAndUnbind(String name, Remote obj) throws RemoteException {
<span class="fc" id="L471">    unexportObject(obj);</span>
    try {
<span class="fc" id="L473">      unbind(name);</span>
<span class="nc" id="L474">    } catch (MalformedURLException | NotBoundException e) {</span>
      // ignore
<span class="fc" id="L476">    }</span>
<span class="fc" id="L477">  }</span>

  /**
   * Exports the given Remote object, using the given socket factory and a randomly assigned port.
   *
   * NOTE: This helper function can also be used for regular RMI servers.
   *
   * @param obj The object to export.
   * @param socketFactory The socket factory to use.
   * @return The remote stub.
   * @throws RemoteException if the operation fails.
   */
  public static Remote exportObject(Remote obj, RMISocketFactory socketFactory)
      throws RemoteException {
<span class="fc" id="L491">    return UnicastRemoteObject.exportObject(obj, 0, socketFactory, socketFactory);</span>
  }

  /**
   * Forcibly un-exports the given object, if it exists (otherwise returns without an error). This
   * should be called upon closing a {@link Closeable} {@link Remote} object.
   *
   * NOTE: This helper function can also be used for regular RMI servers.
   *
   * @param obj The object to un-export.
   */
  public static void unexportObject(Remote obj) {
    try {
<span class="fc" id="L504">      UnicastRemoteObject.unexportObject(obj, true);</span>
<span class="fc" id="L505">    } catch (NoSuchObjectException e) {</span>
      // ignore
<span class="fc" id="L507">    }</span>
<span class="fc" id="L508">  }</span>

  private void setRegistry(AFRegistry registry) {
<span class="fc" id="L511">    synchronized (AFNaming.class) {</span>
<span class="fc" id="L512">      this.registry = registry;</span>
<span class="fc bfc" id="L513" title="All 2 branches covered.">      if (registry == null) {</span>
<span class="fc" id="L514">        rmiService = null;</span>
<span class="fc bfc" id="L515" title="All 2 branches covered.">      } else if (registry.isLocal()) {</span>
<span class="fc" id="L516">        closeUponRuntimeShutdown();</span>
      }
<span class="fc" id="L518">    }</span>
<span class="fc" id="L519">  }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>