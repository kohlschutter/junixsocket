<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>SNIHostnameCapture.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">junixsocket-codecoverage</a> &gt; <a href="../index.html" class="el_bundle">junixsocket-ssl</a> &gt; <a href="index.source.html" class="el_package">org.newsclub.net.unix.ssl</a> &gt; <span class="el_source">SNIHostnameCapture.java</span></div><h1>SNIHostnameCapture.java</h1><pre class="source lang-java linenums">/*
 * junixsocket
 *
 * Copyright 2009-2024 Christian Kohlschütter
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.newsclub.net.unix.ssl;

import java.util.List;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;
import java.util.function.Consumer;
import java.util.function.Supplier;

import javax.net.ssl.ExtendedSSLSession;
import javax.net.ssl.SNIHostName;
import javax.net.ssl.SNIMatcher;
import javax.net.ssl.SNIServerName;
import javax.net.ssl.SSLSession;
import javax.net.ssl.SSLSocket;
import javax.net.ssl.StandardConstants;

import com.kohlschutter.annotations.compiletime.SuppressFBWarnings;

/**
 * Helper class to simplify retrieving the requested SNI hostname sent from an SSL client to an SSL
 * server.
 *
 * @author Christian Kohlschütter
 */
public final class SNIHostnameCapture {
  /**
   * {@link SNIMatcher} that accepts and matches &quot;any hostname&quot;.
   */
<span class="fc" id="L48">  public static final SNIMatcher ACCEPT_ANY_HOSTNAME = new SNIMatcher(</span>
<span class="fc" id="L49">      StandardConstants.SNI_HOST_NAME) {</span>

    @Override
    public boolean matches(SNIServerName serverName) {
<span class="pc bpc" id="L53" title="1 of 2 branches missed.">      return serverName.getType() == StandardConstants.SNI_HOST_NAME;</span>
    }
  };

<span class="fc" id="L57">  private final CompletableFuture&lt;String&gt; hostnameFuture = new CompletableFuture&lt;&gt;();</span>

  private final Supplier&lt;String&gt; defaultHostnameSupplier;

<span class="fc" id="L61">  private SNIHostnameCapture(Supplier&lt;String&gt; defaultHostnameSupplier) {</span>
<span class="fc" id="L62">    this.defaultHostnameSupplier = defaultHostnameSupplier;</span>
<span class="fc" id="L63">  }</span>

  /**
   * Configures the given server {@link SSLSocket} to match the given hostname pattern.
   * &lt;p&gt;
   * The matched hostname is then accessible after the handshake is completed, via
   * {@link #getHostname()}. If no hostname was retrieved, {@code null} is assumed.
   *
   * @param sslSocket The socket to configure.
   * @param hostnameMatcher The matcher to use.
   * @return The {@link SNIHostnameCapture} instance.
   * @see #ACCEPT_ANY_HOSTNAME
   */
  public static SNIHostnameCapture configure(SSLSocket sslSocket, SNIMatcher hostnameMatcher) {
<span class="fc" id="L77">    return configure(sslSocket, hostnameMatcher, null);</span>
  }

  /**
   * Configures the given server {@link SSLSocket} to match the given hostname pattern.
   * &lt;p&gt;
   * The matched hostname is then accessible after the handshake is completed, via
   * {@link #getHostname()}. If no hostname was retrieved, a fallback is retrieved via the given
   * supplier.
   *
   * @param sslSocket The socket to configure.
   * @param hostnameMatcher The matcher to use.
   * @param defaultHostnameSupplier The supplier for a default hostname, or {@code null}.
   * @return The {@link SNIHostnameCapture} instance.
   * @see #ACCEPT_ANY_HOSTNAME
   */
  public static SNIHostnameCapture configure(SSLSocket sslSocket, SNIMatcher hostnameMatcher,
      Supplier&lt;String&gt; defaultHostnameSupplier) {
<span class="fc bfc" id="L95" title="All 2 branches covered.">    SNIHostnameCapture capture = new SNIHostnameCapture(defaultHostnameSupplier == null ? () -&gt; null</span>
<span class="fc" id="L96">        : defaultHostnameSupplier);</span>

<span class="fc" id="L98">    sslSocket.addHandshakeCompletedListener((e) -&gt; {</span>
<span class="fc" id="L99">      capture.set(null);</span>
<span class="fc" id="L100">    });</span>

<span class="fc" id="L102">    SSLParametersUtil.setSNIMatcher(sslSocket, new CallbackSNIMatcher(hostnameMatcher, (name,</span>
        matches) -&gt; {
<span class="fc bfc" id="L104" title="All 4 branches covered.">      if (matches &amp;&amp; name instanceof SNIHostName) {</span>
<span class="fc" id="L105">        capture.set(((SNIHostName) name).getAsciiName());</span>
      }
<span class="fc" id="L107">    }));</span>

<span class="fc" id="L109">    return capture;</span>
  }

  // @ExcludeFromCodeCoverageGeneratedReport(reason = &quot;if-statement is just a precaution&quot;)
  private void set(String hostname) {
<span class="fc" id="L114">    hostnameFuture.complete(hostname);</span>
<span class="fc" id="L115">  }</span>

  /**
   * Checks if a hostname can be returned by calling {@link #getHostname()} (which most likely means
   * the handshake is complete), optionally waiting up to the given time interval if not yet
   * complete.
   *
   * @param timeout The maximum timeout value to wait for.
   * @param unit Timeout unit.
   * @return {@code true} if {@link #getHostname()} will not throw an {@link IllegalStateException}.
   * @throws InterruptedException if the current thread was interrupted while waiting.
   */
  public boolean isComplete(long timeout, TimeUnit unit) throws InterruptedException {
    try {
<span class="fc" id="L129">      hostnameFuture.get(timeout, unit);</span>
<span class="fc" id="L130">      return hostnameFuture.isDone();</span>
<span class="nc" id="L131">    } catch (ExecutionException | TimeoutException e) {</span>
<span class="nc" id="L132">      return false;</span>
    }
  }

  /**
   * Checks if a hostname can be returned by calling {@link #getHostname()} (which most likely means
   * the handshake is complete).
   *
   * @return {@code true} if {@link #getHostname()} will not throw an {@link IllegalStateException}.
   */
  public boolean isComplete() {
<span class="fc" id="L143">    return hostnameFuture.isDone();</span>
  }

  /**
   * Returns the hostname (either the retrieved one, or a fallback), which could also be
   * {@code null}.
   * &lt;p&gt;
   * If the method is called before the handshake is complete (check with {@link #isComplete()} or
   * simply call after {@link SSLSocket#startHandshake()}), an {@link IllegalStateException} is
   * thrown.
   *
   * @return The hostname, or {@code null}.
   * @throws IllegalStateException if the method was called before a hostname could be retrieved.
   */
  @SuppressFBWarnings(&quot;NP_NONNULL_PARAM_VIOLATION&quot;)
  public String getHostname() {
<span class="fc bfc" id="L159" title="All 2 branches covered.">    if (!isComplete()) {</span>
<span class="fc" id="L160">      throw new IllegalStateException(&quot;Handshake not yet complete&quot;);</span>
    }
<span class="fc" id="L162">    String hn = hostnameFuture.getNow(null);</span>
<span class="fc bfc" id="L163" title="All 2 branches covered.">    if (hn == null) {</span>
<span class="fc" id="L164">      return defaultHostnameSupplier.get();</span>
    } else {
<span class="fc" id="L166">      return hn;</span>
    }
  }

  /**
   * Returns the hostname from the data stored in a socket's {@link ExtendedSSLSession}, if
   * available. The default fallback handler is used if the data could not be retrieved.
   * &lt;p&gt;
   * This is only for testing purposes. BouncyCastle doesn't support this, for example.
   *
   * @param socket The socket.
   * @return The hostname (retrieved or fallback).
   */
  String getHostnameFromSSLSession(SSLSocket socket,
      Consumer&lt;UnsupportedOperationException&gt; usoCallback) {
<span class="fc" id="L181">    SSLSession session = socket.getSession();</span>
<span class="pc bpc" id="L182" title="1 of 2 branches missed.">    if (session instanceof ExtendedSSLSession) {</span>
<span class="fc" id="L183">      ExtendedSSLSession extSession = (ExtendedSSLSession) session;</span>
      try {
<span class="fc" id="L185">        List&lt;SNIServerName&gt; list = extSession.getRequestedServerNames();</span>
<span class="pc bpc" id="L186" title="1 of 2 branches missed.">        if (list != null) {</span>
<span class="fc bfc" id="L187" title="All 2 branches covered.">          for (SNIServerName sn : list) {</span>
<span class="pc bpc" id="L188" title="1 of 2 branches missed.">            if (sn instanceof SNIHostName) {</span>
<span class="fc" id="L189">              return ((SNIHostName) sn).getAsciiName();</span>
<span class="nc bnc" id="L190" title="All 2 branches missed.">            } else if (sn.getType() == StandardConstants.SNI_HOST_NAME) {</span>
<span class="nc" id="L191">              return new SNIHostName(sn.getEncoded()).getAsciiName();</span>
            }
<span class="nc" id="L193">          }</span>
        }
<span class="fc" id="L195">      } catch (UnsupportedOperationException e) {</span>
        // fall through
<span class="pc bpc" id="L197" title="1 of 2 branches missed.">        if (usoCallback != null) {</span>
<span class="fc" id="L198">          usoCallback.accept(e);</span>
        }
<span class="fc" id="L200">      }</span>
    }
<span class="fc" id="L202">    return defaultHostnameSupplier.get();</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>