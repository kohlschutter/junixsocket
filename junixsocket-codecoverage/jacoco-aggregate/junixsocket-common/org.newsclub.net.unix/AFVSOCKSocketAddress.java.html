<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>AFVSOCKSocketAddress.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">junixsocket-codecoverage</a> &gt; <a href="../index.html" class="el_bundle">junixsocket-common</a> &gt; <a href="index.source.html" class="el_package">org.newsclub.net.unix</a> &gt; <span class="el_source">AFVSOCKSocketAddress.java</span></div><h1>AFVSOCKSocketAddress.java</h1><pre class="source lang-java linenums">/*
 * junixsocket
 *
 * Copyright 2009-2024 Christian Kohlschütter
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.newsclub.net.unix;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.net.InetAddress;
import java.net.SocketAddress;
import java.net.SocketException;
import java.net.URI;
import java.nio.ByteBuffer;
import java.util.Arrays;
import java.util.HashSet;
import java.util.Locale;
import java.util.Objects;
import java.util.Set;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.newsclub.net.unix.pool.ObjectPool.Lease;

/**
 * An {@link AFSocketAddress} for VSOCK sockets.
 *
 * @author Christian Kohlschütter
 */
public final class AFVSOCKSocketAddress extends AFSocketAddress {
  private static final long serialVersionUID = 1L; // do not change!

<span class="fc" id="L46">  private static final Pattern PAT_VSOCK_URI_HOST_AND_PORT = Pattern.compile(</span>
      &quot;^(?&lt;port&gt;any|[0-9a-fx\\-]+)(\\.(?&lt;cid&gt;any|hypervisor|local|host|[0-9a-fx\\-]+))?(?:\\:(?&lt;javaPort&gt;[0-9]+))?$&quot;);

  private static AFAddressFamily&lt;AFVSOCKSocketAddress&gt; afVsock;

  /**
   * &quot;Any address for binding&quot;.
   */
  public static final int VMADDR_CID_ANY = -1;

  /**
   * Reserved for services built into the hypervisor.
   */
  public static final int VMADDR_CID_HYPERVISOR = 0;

  /**
   * The well-known address for local communication (loopback).
   */
  public static final int VMADDR_CID_LOCAL = 1;

  /**
   * The well-known address of the host.
   */
  public static final int VMADDR_CID_HOST = 2;

  /**
   * Any port number for binding.
   */
  public static final int VMADDR_PORT_ANY = -1;

  private AFVSOCKSocketAddress(int port, final byte[] socketAddress,
      Lease&lt;ByteBuffer&gt; nativeAddress) throws SocketException {
<span class="fc" id="L78">    super(port, socketAddress, nativeAddress, addressFamily());</span>
<span class="fc" id="L79">  }</span>

  private static AFVSOCKSocketAddress newAFSocketAddress(int port, final byte[] socketAddress,
      Lease&lt;ByteBuffer&gt; nativeAddress) throws SocketException {
<span class="nc" id="L83">    return newDeserializedAFSocketAddress(port, socketAddress, nativeAddress, addressFamily(),</span>
        AFVSOCKSocketAddress::new);
  }

  /**
   * Returns an {@link AFVSOCKSocketAddress} that refers to a given VSOCK port and CID; the &quot;java
   * port&quot; is set to -1.
   *
   * @param port The VSOCK port
   * @param cid The CID.
   * @return A corresponding {@link AFVSOCKSocketAddress} instance.
   * @throws SocketException if the operation fails.
   */
  public static AFVSOCKSocketAddress ofPortAndCID(int port, int cid) throws SocketException {
<span class="fc" id="L97">    return ofPortAndCID(-1, port, cid);</span>
  }

  /**
   * Returns an {@link AFVSOCKSocketAddress} that refers to a given VSOCK port on the hypervisor;
   * the &quot;java port&quot; is set to -1.
   *
   * @param port The VSOCK port
   * @return A corresponding {@link AFVSOCKSocketAddress} instance.
   * @throws SocketException if the operation fails.
   */
  public static AFVSOCKSocketAddress ofHypervisorPort(int port) throws SocketException {
<span class="fc" id="L109">    return ofPortAndCID(port, VMADDR_CID_HYPERVISOR);</span>
  }

  /**
   * Returns an {@link AFVSOCKSocketAddress}, especially useful for binding, that refers to &quot;any&quot;
   * port on the hypervisor; the &quot;java port&quot; is set to -1.
   *
   * @return A corresponding {@link AFVSOCKSocketAddress} instance.
   * @throws SocketException if the operation fails.
   */
  public static AFVSOCKSocketAddress ofAnyHypervisorPort() throws SocketException {
<span class="fc" id="L120">    return ofPortAndCID(VMADDR_PORT_ANY, VMADDR_CID_HYPERVISOR);</span>
  }

  /**
   * Returns an {@link AFVSOCKSocketAddress} that refers to the given port with the local/loopback
   * CID; the &quot;java port&quot; is set to -1.
   *
   * @param port The VSOCK port.
   * @return A corresponding {@link AFVSOCKSocketAddress} instance.
   * @throws SocketException if the operation fails.
   */
  public static AFVSOCKSocketAddress ofLocalPort(int port) throws SocketException {
<span class="fc" id="L132">    return ofPortAndCID(port, VMADDR_CID_LOCAL);</span>
  }

  /**
   * Returns an {@link AFVSOCKSocketAddress}, especially useful for binding, that refers to &quot;any&quot;
   * port with the local/loopback CID; the &quot;java port&quot; is set to -1.
   *
   * @return A corresponding {@link AFVSOCKSocketAddress} instance.
   * @throws SocketException if the operation fails.
   */
  public static AFVSOCKSocketAddress ofAnyLocalPort() throws SocketException {
<span class="fc" id="L143">    return ofPortAndCID(VMADDR_PORT_ANY, VMADDR_CID_LOCAL);</span>
  }

  /**
   * Returns an {@link AFVSOCKSocketAddress} that refers to a given VSOCK port on the host; the
   * &quot;java port&quot; is set to -1.
   *
   * @param port The VSOCK port
   * @return A corresponding {@link AFVSOCKSocketAddress} instance.
   * @throws SocketException if the operation fails.
   */
  public static AFVSOCKSocketAddress ofHostPort(int port) throws SocketException {
<span class="fc" id="L155">    return ofPortAndCID(port, VMADDR_CID_HOST);</span>
  }

  /**
   * Returns an {@link AFVSOCKSocketAddress}, especially useful for binding, that refers to &quot;any&quot;
   * port on the host; the &quot;java port&quot; is set to -1.
   *
   * @return A corresponding {@link AFVSOCKSocketAddress} instance.
   * @throws SocketException if the operation fails.
   */
  public static AFVSOCKSocketAddress ofAnyHostPort() throws SocketException {
<span class="fc" id="L166">    return ofPortAndCID(VMADDR_PORT_ANY, VMADDR_CID_HOST);</span>
  }

  /**
   * Returns an {@link AFVSOCKSocketAddress}, especially useful for binding, that refers to &quot;any&quot;
   * port and CID; the &quot;java port&quot; is set to -1.
   *
   * @return A corresponding {@link AFVSOCKSocketAddress} instance.
   * @throws SocketException if the operation fails.
   */
  public static AFVSOCKSocketAddress ofAnyPort() throws SocketException {
<span class="fc" id="L177">    return ofPortAndCID(VMADDR_PORT_ANY, VMADDR_CID_ANY);</span>
  }

  /**
   * Returns an {@link AFVSOCKSocketAddress}, especially useful for binding, that refers to the
   * given port with &quot;any CID&quot;; the &quot;java port&quot; is set to -1.
   *
   * @param port The VSOCK port.
   * @return A corresponding {@link AFVSOCKSocketAddress} instance.
   * @throws SocketException if the operation fails.
   */
  public static AFVSOCKSocketAddress ofPortWithAnyCID(int port) throws SocketException {
<span class="nc" id="L189">    return ofPortAndCID(port, VMADDR_CID_ANY);</span>
  }

  /**
   * Returns an {@link AFVSOCKSocketAddress} that refers to a given port and CID.
   *
   * @param javaPort The Java port number.
   * @param vsockPort The vsock port.
   * @param cid The CID.
   * @return A corresponding {@link AFVSOCKSocketAddress} instance.
   * @throws SocketException if the operation fails.
   */
  public static AFVSOCKSocketAddress ofPortAndCID(int javaPort, int vsockPort, int cid)
      throws SocketException {
<span class="fc" id="L203">    return resolveAddress(toBytes(vsockPort, cid), javaPort, addressFamily());</span>
  }

  /**
   * Returns an {@link AFVSOCKSocketAddress} given a special {@link InetAddress} that encodes the
   * byte sequence of an AF_VSOCK socket address, like those returned by {@link #wrapAddress()}.
   *
   * @param address The &quot;special&quot; {@link InetAddress}.
   * @param port The port (use 0 for &quot;none&quot;).
   * @return The {@link AFVSOCKSocketAddress} instance.
   * @throws SocketException if the operation fails, for example when an unsupported address is
   *           specified.
   */
  public static AFVSOCKSocketAddress unwrap(InetAddress address, int port) throws SocketException {
<span class="nc" id="L217">    return AFSocketAddress.unwrap(address, port, addressFamily());</span>
  }

  /**
   * Returns an {@link AFVSOCKSocketAddress} given a special {@link InetAddress} hostname that
   * encodes the byte sequence of an AF_VSOCK socket address, like those returned by
   * {@link #wrapAddress()}.
   *
   * @param hostname The &quot;special&quot; hostname, as provided by {@link InetAddress#getHostName()}.
   * @param port The port (use 0 for &quot;none&quot;).
   * @return The {@link AFVSOCKSocketAddress} instance.
   * @throws SocketException if the operation fails, for example when an unsupported address is
   *           specified.
   */
  public static AFVSOCKSocketAddress unwrap(String hostname, int port) throws SocketException {
<span class="nc" id="L232">    return AFSocketAddress.unwrap(hostname, port, addressFamily());</span>
  }

  /**
   * Returns an {@link AFVSOCKSocketAddress} given a generic {@link SocketAddress}.
   *
   * @param address The address to unwrap.
   * @return The {@link AFVSOCKSocketAddress} instance.
   * @throws SocketException if the operation fails, for example when an unsupported address is
   *           specified.
   */
  public static AFVSOCKSocketAddress unwrap(SocketAddress address) throws SocketException {
<span class="nc" id="L244">    Objects.requireNonNull(address);</span>
<span class="nc bnc" id="L245" title="All 2 branches missed.">    if (!isSupportedAddress(address)) {</span>
<span class="nc" id="L246">      throw new SocketException(&quot;Unsupported address&quot;);</span>
    }
<span class="nc" id="L248">    return (AFVSOCKSocketAddress) address;</span>
  }

  /**
   * Returns the &quot;VSOCK port&quot; part of this address.
   *
   * @return The VSOCK port identifier
   * @see #getPort()
   */
  public int getVSOCKPort() {
<span class="fc" id="L258">    ByteBuffer bb = ByteBuffer.wrap(getBytes());</span>
<span class="fc" id="L259">    int a = bb.getInt(1 * 4);</span>
<span class="fc" id="L260">    return a;</span>
  }

  /**
   * Returns the &quot;VSOCK CID&quot; part of this address.
   *
   * @return The VSOCK CID identifier.
   */
  public int getVSOCKCID() {
<span class="fc" id="L269">    ByteBuffer bb = ByteBuffer.wrap(getBytes());</span>
<span class="fc" id="L270">    int a = bb.getInt(2 * 4);</span>
<span class="fc" id="L271">    return a;</span>
  }

  /**
   * Returns the &quot;VSOCK reserved1&quot; part of this address.
   *
   * @return The &quot;reserved1&quot; identifier, which should be 0.
   */
  public int getVSOCKReserved1() {
<span class="nc" id="L280">    ByteBuffer bb = ByteBuffer.wrap(getBytes());</span>
<span class="nc" id="L281">    int a = bb.getInt(0 * 4);</span>
<span class="nc" id="L282">    return a;</span>
  }

  @Override
  public String toString() {
<span class="nc" id="L287">    int port = getPort();</span>

<span class="nc" id="L289">    byte[] bytes = getBytes();</span>
<span class="nc bnc" id="L290" title="All 2 branches missed.">    if (bytes.length != (3 * 4)) {</span>
<span class="nc bnc" id="L291" title="All 2 branches missed.">      return getClass().getName() + &quot;[&quot; + (port == 0 ? &quot;&quot; : &quot;port=&quot; + port) + &quot;;UNKNOWN&quot; + &quot;]&quot;;</span>
    }

<span class="nc" id="L294">    ByteBuffer bb = ByteBuffer.wrap(bytes);</span>
<span class="nc" id="L295">    int reserved1 = bb.getInt();</span>
<span class="nc" id="L296">    int vsockPort = bb.getInt();</span>
<span class="nc" id="L297">    int cid = bb.getInt();</span>

    String vsockPortString;
<span class="nc bnc" id="L300" title="All 2 branches missed.">    if (vsockPort &gt;= -1) {</span>
<span class="nc" id="L301">      vsockPortString = Integer.toString(vsockPort);</span>
    } else {
<span class="nc" id="L303">      vsockPortString = String.format(Locale.ENGLISH, &quot;0x%08x&quot;, vsockPort);</span>
    }

<span class="nc bnc" id="L306" title="All 2 branches missed.">    String typeString = (reserved1 == 0 ? &quot;&quot; : &quot;reserved1=&quot; + reserved1 + &quot;;&quot;) + &quot;vsockPort=&quot;</span>
        + vsockPortString + &quot;;cid=&quot; + cid;

<span class="nc bnc" id="L309" title="All 2 branches missed.">    return getClass().getName() + &quot;[&quot; + (port == 0 ? &quot;&quot; : &quot;port=&quot; + port + &quot;;&quot;) + typeString + &quot;]&quot;;</span>
  }

  @Override
  public boolean hasFilename() {
<span class="nc" id="L314">    return false;</span>
  }

  @Override
  public File getFile() throws FileNotFoundException {
<span class="nc" id="L319">    throw new FileNotFoundException(&quot;no file&quot;);</span>
  }

  /**
   * Checks if an {@link InetAddress} can be unwrapped to an {@link AFVSOCKSocketAddress}.
   *
   * @param addr The instance to check.
   * @return {@code true} if so.
   * @see #wrapAddress()
   * @see #unwrap(InetAddress, int)
   */
  public static boolean isSupportedAddress(InetAddress addr) {
<span class="nc" id="L331">    return AFSocketAddress.isSupportedAddress(addr, addressFamily());</span>
  }

  /**
   * Checks if a {@link SocketAddress} can be unwrapped to an {@link AFVSOCKSocketAddress}.
   *
   * @param addr The instance to check.
   * @return {@code true} if so.
   * @see #unwrap(InetAddress, int)
   */
  public static boolean isSupportedAddress(SocketAddress addr) {
<span class="nc" id="L342">    return (addr instanceof AFVSOCKSocketAddress);</span>
  }

  @SuppressWarnings(&quot;cast&quot;)
  private static byte[] toBytes(int port, int cid) {
<span class="fc" id="L347">    ByteBuffer bb = ByteBuffer.allocate(3 * 4);</span>
<span class="fc" id="L348">    bb.putInt(0); // svm_reserved1</span>
<span class="fc" id="L349">    bb.putInt(port); // svm_port</span>
<span class="fc" id="L350">    bb.putInt(cid); // svm_cid</span>
<span class="fc" id="L351">    return (byte[]) bb.flip().array();</span>
  }

  /**
   * Returns the corresponding {@link AFAddressFamily}.
   *
   * @return The address family instance.
   */
  @SuppressWarnings(&quot;null&quot;)
  public static synchronized AFAddressFamily&lt;AFVSOCKSocketAddress&gt; addressFamily() {
<span class="fc bfc" id="L361" title="All 2 branches covered.">    if (afVsock == null) {</span>
<span class="fc" id="L362">      afVsock = AFAddressFamily.registerAddressFamily(&quot;vsock&quot;, //</span>
<span class="fc" id="L363">          AFVSOCKSocketAddress.class, new AFSocketAddressConfig&lt;AFVSOCKSocketAddress&gt;() {</span>

<span class="fc" id="L365">            private final AFSocketAddressConstructor&lt;AFVSOCKSocketAddress&gt; addrConstr =</span>
<span class="pc bpc" id="L366" title="1 of 2 branches missed.">                isUseDeserializationForInit() ? AFVSOCKSocketAddress::newAFSocketAddress</span>
<span class="fc" id="L367">                    : AFVSOCKSocketAddress::new;</span>

            @Override
            protected AFVSOCKSocketAddress parseURI(URI u, int port) throws SocketException {
<span class="nc" id="L371">              return AFVSOCKSocketAddress.of(u, port);</span>
            }

            @Override
            protected AFSocketAddressConstructor&lt;AFVSOCKSocketAddress&gt; addressConstructor() {
<span class="fc" id="L376">              return addrConstr;</span>
            }

            @Override
            protected String selectorProviderClassname() {
<span class="fc" id="L381">              return &quot;org.newsclub.net.unix.vsock.AFVSOCKSelectorProvider&quot;;</span>
            }

            @Override
            protected Set&lt;String&gt; uriSchemes() {
<span class="fc" id="L386">              return new HashSet&lt;&gt;(Arrays.asList(&quot;vsock&quot;, &quot;http+vsock&quot;, &quot;https+vsock&quot;));</span>
            }
          });
      try {
<span class="fc" id="L390">        Class.forName(&quot;org.newsclub.net.unix.vsock.AFVSOCKSelectorProvider&quot;);</span>
<span class="fc" id="L391">      } catch (ClassNotFoundException e) {</span>
        // ignore
<span class="fc" id="L393">      }</span>
    }
<span class="fc" id="L395">    return afVsock;</span>
  }

  /**
   * Returns an {@link AFVSOCKSocketAddress} for the given URI, if possible.
   *
   * @param uri The URI.
   * @return The address.
   * @throws SocketException if the operation fails.
   */
  @SuppressWarnings(&quot;PMD.ShortMethodName&quot;)
  public static AFVSOCKSocketAddress of(URI uri) throws SocketException {
<span class="fc" id="L407">    return of(uri, -1);</span>
  }

  /**
   * Returns an {@link AFVSOCKSocketAddress} for the given URI, if possible.
   *
   * @param uri The URI.
   * @param overridePort The port to forcibly use, or {@code -1} for &quot;don't override&quot;.
   * @return The address.
   * @throws SocketException if the operation fails.
   */
  @SuppressWarnings({
      &quot;PMD.CognitiveComplexity&quot;, &quot;PMD.CyclomaticComplexity&quot;, &quot;PMD.ExcessiveMethodLength&quot;,
      &quot;PMD.NcssCount&quot;, &quot;PMD.NPathComplexity&quot;, &quot;PMD.ShortMethodName&quot;})
  public static AFVSOCKSocketAddress of(URI uri, int overridePort) throws SocketException {
<span class="pc bpc" id="L422" title="1 of 2 branches missed.">    switch (uri.getScheme()) {</span>
      case &quot;vsock&quot;:
      case &quot;http+vsock&quot;:
      case &quot;https+vsock&quot;:
<span class="fc" id="L426">        break;</span>
      default:
<span class="nc" id="L428">        throw new SocketException(&quot;Unsupported URI scheme: &quot; + uri.getScheme());</span>
    }

<span class="fc" id="L431">    String host = uri.getHost();</span>
<span class="fc bfc" id="L432" title="All 2 branches covered.">    if (host == null) {</span>
<span class="fc" id="L433">      host = uri.getAuthority();</span>
<span class="pc bpc" id="L434" title="1 of 2 branches missed.">      if (host != null) {</span>
<span class="fc" id="L435">        int at = host.indexOf('@');</span>
<span class="pc bpc" id="L436" title="1 of 2 branches missed.">        if (at &gt;= 0) {</span>
<span class="nc" id="L437">          host = host.substring(at + 1);</span>
        }
      }
    }
<span class="pc bpc" id="L441" title="1 of 2 branches missed.">    if (host == null) {</span>
<span class="nc" id="L442">      throw new SocketException(&quot;Cannot get hostname from URI: &quot; + uri);</span>
    }

    try {
<span class="fc" id="L446">      Matcher m = PAT_VSOCK_URI_HOST_AND_PORT.matcher(host);</span>
<span class="fc bfc" id="L447" title="All 2 branches covered.">      if (!m.matches()) {</span>
<span class="fc" id="L448">        throw new SocketException(&quot;Invalid VSOCK URI: &quot; + uri);</span>
      }

<span class="fc" id="L451">      String cidStr = m.group(&quot;cid&quot;);</span>
<span class="fc" id="L452">      String portStr = m.group(&quot;port&quot;);</span>
<span class="fc" id="L453">      String javaPortStr = m.group(&quot;javaPort&quot;);</span>

      int cid;
<span class="fc bfc" id="L456" title="All 7 branches covered.">      switch (cidStr == null ? &quot;&quot; : cidStr) {</span>
        case &quot;&quot;:
        case &quot;any&quot;:
<span class="fc" id="L459">          cid = VMADDR_CID_ANY;</span>
<span class="fc" id="L460">          break;</span>
        case &quot;hypervisor&quot;:
<span class="fc" id="L462">          cid = VMADDR_CID_HYPERVISOR;</span>
<span class="fc" id="L463">          break;</span>
        case &quot;local&quot;:
<span class="fc" id="L465">          cid = VMADDR_CID_LOCAL;</span>
<span class="fc" id="L466">          break;</span>
        case &quot;host&quot;:
<span class="fc" id="L468">          cid = VMADDR_CID_HOST;</span>
<span class="fc" id="L469">          break;</span>
        default:
<span class="fc" id="L471">          cid = parseInt(cidStr);</span>
          break;
      }

      int port;
<span class="pc bpc" id="L476" title="1 of 4 branches missed.">      switch (portStr == null ? &quot;&quot; : portStr) {</span>
        case &quot;any&quot;:
        case &quot;&quot;:
<span class="fc" id="L479">          port = VMADDR_PORT_ANY;</span>
<span class="fc" id="L480">          break;</span>
        default:
<span class="fc" id="L482">          port = parseInt(portStr);</span>
          break;
      }

<span class="pc bpc" id="L486" title="1 of 2 branches missed.">      int javaPort = overridePort != -1 ? overridePort : uri.getPort();</span>
<span class="pc bpc" id="L487" title="3 of 4 branches missed.">      if (javaPortStr != null &amp;&amp; !javaPortStr.isEmpty()) {</span>
<span class="nc" id="L488">        javaPort = parseInt(javaPortStr);</span>
      }

<span class="fc" id="L491">      return ofPortAndCID(javaPort, port, cid);</span>
<span class="nc" id="L492">    } catch (IllegalArgumentException e) {</span>
<span class="nc" id="L493">      throw (SocketException) new SocketException(&quot;Invalid VSOCK URI: &quot; + uri).initCause(e);</span>
    }
  }

  @Override
  @SuppressWarnings({&quot;PMD.CognitiveComplexity&quot;, &quot;PMD.CompareObjectsWithEquals&quot;})
  public URI toURI(String scheme, URI template) throws IOException {
<span class="pc bpc" id="L500" title="1 of 2 branches missed.">    switch (scheme) {</span>
      case &quot;vsock&quot;:
      case &quot;http+vsock&quot;:
      case &quot;https+vsock&quot;:
<span class="fc" id="L504">        break;</span>
      default:
<span class="nc" id="L506">        return super.toURI(scheme, template);</span>
    }

<span class="fc" id="L509">    byte[] bytes = getBytes();</span>
<span class="pc bpc" id="L510" title="1 of 2 branches missed.">    if (bytes.length != (3 * 4)) {</span>
<span class="nc" id="L511">      return super.toURI(scheme, template);</span>
    }

<span class="fc" id="L514">    StringBuilder sb = new StringBuilder();</span>

    String portStr;
    int port;
<span class="fc bfc" id="L518" title="All 2 branches covered.">    switch ((port = getVSOCKPort())) {</span>
      case VMADDR_PORT_ANY:
<span class="fc" id="L520">        portStr = &quot;any&quot;;</span>
<span class="fc" id="L521">        break;</span>
      default:
<span class="fc" id="L523">        portStr = toUnsignedString(port);</span>
        break;
    }

<span class="fc" id="L527">    sb.append(portStr);</span>
<span class="fc" id="L528">    sb.append('.');</span>
    String cidStr;
    int cid;
<span class="fc bfc" id="L531" title="All 5 branches covered.">    switch ((cid = getVSOCKCID())) {</span>
      case VMADDR_CID_ANY:
<span class="fc" id="L533">        cidStr = &quot;any&quot;;</span>
<span class="fc" id="L534">        break;</span>
      case VMADDR_CID_HYPERVISOR:
<span class="fc" id="L536">        cidStr = &quot;hypervisor&quot;;</span>
<span class="fc" id="L537">        break;</span>
      case VMADDR_CID_LOCAL:
<span class="fc" id="L539">        cidStr = &quot;local&quot;;</span>
<span class="fc" id="L540">        break;</span>
      case VMADDR_CID_HOST:
<span class="fc" id="L542">        cidStr = &quot;host&quot;;</span>
<span class="fc" id="L543">        break;</span>
      default:
<span class="fc" id="L545">        cidStr = toUnsignedString(cid);</span>
        break;
    }

<span class="fc" id="L549">    sb.append(cidStr);</span>

<span class="fc" id="L551">    return new HostAndPort(sb.toString(), getPort()).toURI(scheme, template);</span>
  }

  private static int parseInt(String v) {
<span class="fc bfc" id="L555" title="All 2 branches covered.">    if (v.startsWith(&quot;0x&quot;)) {</span>
<span class="fc" id="L556">      return parseUnsignedInt(v.substring(2), 16);</span>
<span class="fc bfc" id="L557" title="All 2 branches covered.">    } else if (v.startsWith(&quot;-&quot;)) {</span>
<span class="fc" id="L558">      return Integer.parseInt(v);</span>
    } else {
<span class="fc" id="L560">      return parseUnsignedInt(v, 10);</span>
    }
  }

  /**
   * Checks if the given address could cover another address.
   *
   * By default, this is only true if both addresses are regarded equal using
   * {@link #equals(Object)}.
   *
   * However, implementations may support &quot;wildcard&quot; addresses, and this method would compare a
   * wildcard address against some non-wildcard address, for example.
   *
   * @param covered The other address that could be covered by this address.
   * @return {@code true} if the other address could be covered.
   */
  @Override
  public boolean covers(AFSocketAddress covered) {
<span class="nc bnc" id="L578" title="All 2 branches missed.">    if (super.covers(covered)) {</span>
<span class="nc" id="L579">      return true;</span>
<span class="nc bnc" id="L580" title="All 2 branches missed.">    } else if (covered instanceof AFVSOCKSocketAddress) {</span>
<span class="nc" id="L581">      AFVSOCKSocketAddress other = (AFVSOCKSocketAddress) covered;</span>

<span class="nc bnc" id="L583" title="All 2 branches missed.">      if (getVSOCKCID() == VMADDR_CID_ANY) {</span>
<span class="nc bnc" id="L584" title="All 2 branches missed.">        if (getVSOCKPort() == VMADDR_PORT_ANY) {</span>
<span class="nc" id="L585">          return true;</span>
        } else {
<span class="nc bnc" id="L587" title="All 2 branches missed.">          return getVSOCKPort() == other.getVSOCKPort();</span>
        }
<span class="nc bnc" id="L589" title="All 2 branches missed.">      } else if (getVSOCKPort() == VMADDR_PORT_ANY) {</span>
<span class="nc bnc" id="L590" title="All 2 branches missed.">        return getVSOCKCID() == other.getVSOCKCID();</span>
      }
    }

<span class="nc" id="L594">    return equals(covered);</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>