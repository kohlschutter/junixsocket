<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>AFTIPCSocketAddress.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">junixsocket-codecoverage</a> &gt; <a href="../index.html" class="el_bundle">junixsocket-common</a> &gt; <a href="index.source.html" class="el_package">org.newsclub.net.unix</a> &gt; <span class="el_source">AFTIPCSocketAddress.java</span></div><h1>AFTIPCSocketAddress.java</h1><pre class="source lang-java linenums">/*
 * junixsocket
 *
 * Copyright 2009-2024 Christian Kohlschütter
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.newsclub.net.unix;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.Serializable;
import java.net.InetAddress;
import java.net.InetSocketAddress;
import java.net.SocketAddress;
import java.net.SocketException;
import java.net.URI;
import java.nio.ByteBuffer;
import java.util.Arrays;
import java.util.HashSet;
import java.util.Locale;
import java.util.Objects;
import java.util.Set;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.eclipse.jdt.annotation.NonNull;
import org.eclipse.jdt.annotation.NonNullByDefault;

/**
 * An {@link AFSocketAddress} for TIPC sockets.
 *
 * The TIPC socket API provides three different address types:
 * &lt;ul&gt;
 * &lt;li&gt;&lt;em&gt;Service Address.&lt;/em&gt;
 * &lt;p&gt;
 * This address type consists of a 32-bit service type identifier and a 32-bit service instance
 * identifier.
 * &lt;/p&gt;
 * &lt;p&gt;
 * The type identifier is typically determined and hard-coded by the user application programmer,
 * but its value may have to be coordinated with other applications which might be present in the
 * same cluster. The instance identifier is often calculated by the program, based on application
 * specific criteria.
 * &lt;/p&gt;
 * &lt;p&gt;
 * Typical invocation: {@link #ofService(int, int)}.
 * &lt;/p&gt;
 * &lt;/li&gt;
 * &lt;li&gt;&lt;em&gt;Service Range.&lt;/em&gt;
 * &lt;p&gt;
 * This address type represents a range of service addresses of the same type and with instances
 * between a lower and an upper range limit.
 * &lt;/p&gt;
 * &lt;p&gt;
 * By binding a socket to this address type one can make it represent many instances, something
 * which has proved useful in many cases. This address type is also used as multicast address.
 * &lt;/p&gt;
 * &lt;p&gt;
 * Typical invocation: {@link #ofServiceRange(int, int, int)}.
 * &lt;/p&gt;
 * &lt;/li&gt;
 * &lt;li&gt;&lt;em&gt;Socket Address.&lt;/em&gt;
 * &lt;p&gt;
 * This address is a reference to a specific socket in the cluster.
 * &lt;/p&gt;
 * &lt;p&gt;
 * It contains a 32-bit port number and a 32-bit node hash number. The port number is generated by
 * the system when the socket is created, and the node hash is generated from the corresponding node
 * identity.
 * &lt;/p&gt;
 * &lt;p&gt;
 * An address of this type can be used for connecting or for sending messages in the same way as
 * service addresses can be used, but is only valid as long as the referenced socket exists.
 * &lt;/p&gt;
 * &lt;p&gt;
 * Typical invocation: {@link #ofSocket(int, int)}.
 * &lt;/p&gt;
 * &lt;/li&gt;
 * &lt;/ul&gt;
 * &lt;p&gt;
 * When binding a socket to a service address or address range, the visibility scope of the binding
 * must be indicated. There are two options, {@link Scope#SCOPE_NODE} if the user only wants node
 * local visibility, and {@link Scope#SCOPE_CLUSTER} if he wants cluster global visibility. There
 * are almost no limitations to how sockets can be bound to service addresses: one socket can be
 * bound to many addresses or ranges, and many sockets can be bound to the same address or range.
 * &lt;/p&gt;
 * &lt;p&gt;
 * The service types 0 through 63 are however reserved for system internal use, and are not
 * available for user space applications.
 * &lt;/p&gt;
 * &lt;p&gt;
 * When sending a message by service address the sender may indicate a lookup domain, also called
 * lookup scope. This is a node hash number, limiting the set of eligible destination sockets to the
 * indicated node. If this value is zero, all matching sockets in the whole cluster, as visible from
 * the source node, are eligible.
 * &lt;/p&gt;
 *
 * @author Christian Kohlschütter (documentation credits to Jon Maloy and the TIPC team).
 */
public final class AFTIPCSocketAddress extends AFSocketAddress {
  private static final long serialVersionUID = 1L; // do not change!

<span class="fc" id="L115">  private static final Pattern PAT_TIPC_URI_HOST_AND_PORT = Pattern.compile(</span>
      &quot;^((?:(?:(?&lt;scope&gt;cluster|node|default|[0-9a-fx]+)\\-)?(?&lt;type&gt;service|service-range|socket)\\.)|&quot;
          + &quot;(?&lt;scope2&gt;cluster|node|default|[0-9a-fx]+)\\-(?&lt;type2&gt;[0-9a-fx]+)\\.)?&quot;
          + &quot;(?&lt;a&gt;[0-9a-fx]+)\\.(?&lt;b&gt;[0-9a-fx]+)(?:\\.(?&lt;c&gt;[0-9a-fx]+))?(?:\\:(?&lt;javaPort&gt;[0-9]+))?$&quot;);

  /**
   * The &quot;topology&quot; service name type.
   */
  public static final int TIPC_TOP_SRV = 1;

  /**
   * The lowest user-publishable name type.
   */
  public static final int TIPC_RESERVED_TYPES = 64;

  private static AFAddressFamily&lt;AFTIPCSocketAddress&gt; afTipc;

  /**
   * The TIPC address type.
   *
   * @author Christian Kohlschütter
   */
  @NonNullByDefault
  public static final class AddressType extends NamedInteger {
    private static final long serialVersionUID = 1L;

    /**
     * Describes a TIPC &quot;service range&quot; address.
     */
    public static final AddressType SERVICE_RANGE;

    /**
     * Describes a TIPC &quot;service&quot; address.
     */
    public static final AddressType SERVICE_ADDR;

    /**
     * Describes a TIPC &quot;socket&quot; address.
     */
    public static final AddressType SOCKET_ADDR;

<span class="fc" id="L156">    private static final @NonNull AddressType[] VALUES = init(new @NonNull AddressType[] {</span>
        SERVICE_RANGE = new AddressType(&quot;SERVICE_RANGE&quot;, 1, //
<span class="nc" id="L158">            (a, b, c) -&gt; formatTIPCInt(a) + &quot;@&quot; + formatTIPCInt(b) + &quot;-&quot; + formatTIPCInt(c)), //</span>
        SERVICE_ADDR = new AddressType(&quot;SERVICE_ADDR&quot;, 2, //
<span class="nc bnc" id="L160" title="All 2 branches missed.">            (a, b, c) -&gt; formatTIPCInt(a) + &quot;@&quot; + formatTIPCInt(b) + (c == 0 ? &quot;&quot; : &quot;:&quot;</span>
<span class="nc" id="L161">                + formatTIPCInt(c))), //</span>
        SOCKET_ADDR = new AddressType(&quot;SOCKET_ADDR&quot;, 3, //
<span class="nc bnc" id="L163" title="All 2 branches missed.">            (a, b, c) -&gt; formatTIPCInt(a) + &quot;@&quot; + formatTIPCInt(b) + (c == 0 ? &quot;&quot; : &quot;:&quot;</span>
<span class="nc" id="L164">                + formatTIPCInt(c))), //</span>
    });

    /**
     * The provider of a debug string.
     */
    private final DebugStringProvider ds;

    private AddressType(int id) {
<span class="nc" id="L173">      super(id);</span>
<span class="nc" id="L174">      this.ds = (a, b, c) -&gt; &quot;:&quot; + toUnsignedString(a) + &quot;:&quot; + toUnsignedString(b) + &quot;:&quot;</span>
<span class="nc" id="L175">          + toUnsignedString(c);</span>
<span class="nc" id="L176">    }</span>

    private AddressType(String name, int id, DebugStringProvider ds) {
<span class="fc" id="L179">      super(name, id);</span>
<span class="fc" id="L180">      this.ds = ds;</span>
<span class="fc" id="L181">    }</span>

    static AddressType ofValue(int v) {
<span class="fc" id="L184">      return ofValue(VALUES, AddressType::new, v);</span>
    }

    @FunctionalInterface
    interface DebugStringProvider extends Serializable {
      String toDebugString(int a, int b, int c);
    }

    /**
     * Formats an integer as an unsigned, zero-padded 32-bit hexadecimal number.
     *
     * @param i The number.
     * @return The string.
     */
    @SuppressWarnings(&quot;null&quot;)
    public static String formatTIPCInt(int i) {
<span class="nc" id="L200">      return String.format(Locale.ENGLISH, &quot;0x%08x&quot;, (i &amp; 0xFFFFFFFFL));</span>
    }

    private String toDebugString(Scope scope, int a, int b, int c) {
<span class="nc bnc" id="L204" title="All 4 branches missed.">      if (this == SOCKET_ADDR &amp;&amp; scope.equals(Scope.SCOPE_NOT_SPECIFIED)) {</span>
<span class="nc" id="L205">        return name() + &quot;(&quot; + value() + &quot;);&quot; + ds.toDebugString(a, b, c);</span>
      } else {
<span class="nc" id="L207">        return name() + &quot;(&quot; + value() + &quot;);&quot; + scope + &quot;:&quot; + ds.toDebugString(a, b, c);</span>
      }
    }
  }

  /**
   * The TIPC visibility scope.
   *
   * @author Christian Kohlschütter
   */
  @NonNullByDefault
  public static final class Scope extends NamedInteger {
    private static final long serialVersionUID = 1L;

    /**
     * Cluster-wide scope.
     */
    public static final Scope SCOPE_CLUSTER;

    /**
     * Node-only scope.
     */
    public static final Scope SCOPE_NODE;

    /**
     * Scope not specified (for example, when using socket addresses).
     */
    public static final Scope SCOPE_NOT_SPECIFIED;

<span class="fc" id="L236">    private static final @NonNull Scope[] VALUES = init(new @NonNull Scope[] {</span>
        SCOPE_NOT_SPECIFIED = new Scope(&quot;SCOPE_NOT_SPECIFIED&quot;, 0), //
        SCOPE_CLUSTER = new Scope(&quot;SCOPE_CLUSTER&quot;, 2), //
        SCOPE_NODE = new Scope(&quot;SCOPE_NODE&quot;, 3), //
    });

    private Scope(int id) {
<span class="fc" id="L243">      super(id);</span>
<span class="fc" id="L244">    }</span>

    private Scope(String name, int id) {
<span class="fc" id="L247">      super(name, id);</span>
<span class="fc" id="L248">    }</span>

    /**
     * Returns a {@link Scope} instance given an integer value.
     *
     * @param v The scope value.
     * @return The {@link Scope} instance.
     */
    public static Scope ofValue(int v) {
<span class="fc" id="L257">      return ofValue(VALUES, Scope::new, v);</span>
    }
  }

  private AFTIPCSocketAddress(int port, final byte[] socketAddress, ByteBuffer nativeAddress)
      throws SocketException {
<span class="fc" id="L263">    super(port, socketAddress, nativeAddress, addressFamily());</span>
<span class="fc" id="L264">  }</span>

  private static AFTIPCSocketAddress newAFSocketAddress(int port, final byte[] socketAddress,
      ByteBuffer nativeAddress) throws SocketException {
<span class="nc" id="L268">    return newDeserializedAFSocketAddress(port, socketAddress, nativeAddress, addressFamily(),</span>
        AFTIPCSocketAddress::new);
  }

  /**
   * Returns an {@link AFTIPCSocketAddress} that refers to a given service type and instance, using
   * the given scope.
   *
   * @param scope The address scope.
   * @param type The service type (0-63 are reserved).
   * @param instance The service instance ID.
   * @return A corresponding {@link AFTIPCSocketAddress} instance.
   * @throws SocketException if the operation fails.
   */
  public static AFTIPCSocketAddress ofService(Scope scope, int type, int instance)
      throws SocketException {
<span class="fc" id="L284">    return ofService(scope, type, instance, 0);</span>
  }

  /**
   * Returns an {@link AFTIPCSocketAddress} that refers to a given service type and instance,
   * implicitly using cluster scope ({@link Scope#SCOPE_CLUSTER}).
   *
   * @param type The service type (0-63 are reserved).
   * @param instance The service instance ID.
   * @return A corresponding {@link AFTIPCSocketAddress} instance.
   * @throws SocketException if the operation fails.
   */
  public static AFTIPCSocketAddress ofService(int type, int instance) throws SocketException {
<span class="fc" id="L297">    return ofService(Scope.SCOPE_CLUSTER, type, instance, 0);</span>
  }

  /**
   * Returns an {@link AFTIPCSocketAddress} that refers to a given service type and instance, using
   * the given scope and the given lookup domain.
   *
   * @param scope The address scope.
   * @param type The service type (0-63 are reserved).
   * @param instance The service instance ID.
   * @param domain The lookup domain. 0 indicates cluster global lookup, otherwise a node hash,
   *          indicating that lookup should be performed only on that node
   * @return A corresponding {@link AFTIPCSocketAddress} instance.
   * @throws SocketException if the operation fails.
   */
  public static AFTIPCSocketAddress ofService(Scope scope, int type, int instance, int domain)
      throws SocketException {
<span class="fc" id="L314">    return ofService(0, scope, type, instance, domain);</span>
  }

  /**
   * Returns an {@link AFTIPCSocketAddress} that refers to a given service type and instance, using
   * the given scope and the given lookup domain. A Java-only &quot;IP port number&quot; is stored along the
   * instance for compatibility reasons.
   *
   * @param javaPort The emulated &quot;port&quot; number (not part of TIPC).
   * @param scope The address scope.
   * @param type The service type (0-63 are reserved).
   * @param instance The service instance ID.
   * @param domain The lookup domain. 0 indicates cluster global lookup, otherwise a node hash,
   *          indicating that lookup should be performed only on that node
   * @return A corresponding {@link AFTIPCSocketAddress} instance.
   * @throws SocketException if the operation fails.
   */
  public static AFTIPCSocketAddress ofService(int javaPort, Scope scope, int type, int instance,
      int domain) throws SocketException {
<span class="fc" id="L333">    return resolveAddress(toBytes(AddressType.SERVICE_ADDR, scope, type, instance, domain),</span>
<span class="fc" id="L334">        javaPort, addressFamily());</span>
  }

  /**
   * Returns an {@link AFTIPCSocketAddress} that refers to a given service range type and instance
   * boundaries (lower/upper values), using the given scope.
   *
   * @param scope The address scope.
   * @param type The service type (0-63 are reserved).
   * @param lower Lower end of service instance ID range.
   * @param upper Upper end of service instance ID range.
   * @return A corresponding {@link AFTIPCSocketAddress} instance.
   * @throws SocketException if the operation fails.
   */
  public static AFTIPCSocketAddress ofServiceRange(Scope scope, int type, int lower, int upper)
      throws SocketException {
<span class="fc" id="L350">    return ofServiceRange(0, scope, type, lower, upper);</span>
  }

  /**
   * Returns an {@link AFTIPCSocketAddress} that refers to a given service range type and instance
   * boundaries (lower/upper values), implicitly using cluster scope ({@link Scope#SCOPE_CLUSTER}).
   *
   * @param type The service type (0-63 are reserved).
   * @param lower Lower end of service instance ID range.
   * @param upper Upper end of service instance ID range.
   * @return A corresponding {@link AFTIPCSocketAddress} instance.
   * @throws SocketException if the operation fails.
   */
  public static AFTIPCSocketAddress ofServiceRange(int type, int lower, int upper)
      throws SocketException {
<span class="fc" id="L365">    return ofServiceRange(0, Scope.SCOPE_CLUSTER, type, lower, upper);</span>
  }

  /**
   * Returns an {@link AFTIPCSocketAddress} that refers to a given service range type and instance
   * boundaries (lower/upper values), implicitly using cluster scope ({@link Scope#SCOPE_CLUSTER}).
   * A Java-only &quot;IP port number&quot; is stored along the instance for compatibility reasons.
   *
   * @param javaPort The emulated &quot;port&quot; number (not part of TIPC).
   * @param scope The address scope.
   * @param type The service type (0-63 are reserved).
   * @param lower Lower end of service instance ID range.
   * @param upper Upper end of service instance ID range.
   * @return A corresponding {@link AFTIPCSocketAddress} instance.
   * @throws SocketException if the operation fails.
   */
  public static AFTIPCSocketAddress ofServiceRange(int javaPort, Scope scope, int type, int lower,
      int upper) throws SocketException {
<span class="fc" id="L383">    return resolveAddress(toBytes(AddressType.SERVICE_RANGE, scope, type, lower, upper), javaPort,</span>
<span class="fc" id="L384">        addressFamily());</span>
  }

  /**
   * Returns an {@link AFTIPCSocketAddress} that refers to a given TIPC socket address (i.e.,
   * referring to a particular socket instance instead of a service address).
   *
   * @param ref 32-bit port reference ID (not to be confused with the
   *          {@link InetSocketAddress#getPort()} port).
   * @param node Node hash number (can be used as lookup domain with
   *          {@link #ofService(Scope, int, int, int)}).
   * @return A corresponding {@link AFTIPCSocketAddress} instance.
   * @throws SocketException if the operation fails.
   */
  public static AFTIPCSocketAddress ofSocket(int ref, int node) throws SocketException {
<span class="fc" id="L399">    return ofSocket(0, ref, node);</span>
  }

  /**
   * Returns an {@link AFTIPCSocketAddress} that refers to a given TIPC socket address (i.e.,
   * referring to a particular socket instance instead of a service address). A Java-only &quot;IP port
   * number&quot; is stored along the instance for compatibility reasons.
   *
   * @param javaPort The emulated &quot;port&quot; number (not part of TIPC).
   * @param ref 32-bit port reference ID (not to be confused with the
   *          {@link InetSocketAddress#getPort()} port).
   * @param node Node hash number (can be used as lookup domain with
   *          {@link #ofService(Scope, int, int, int)}).
   * @return A corresponding {@link AFTIPCSocketAddress} instance.
   * @throws SocketException if the operation fails.
   */
  public static AFTIPCSocketAddress ofSocket(int javaPort, int ref, int node)
      throws SocketException {
<span class="fc" id="L417">    return resolveAddress(toBytes(AddressType.SOCKET_ADDR, Scope.SCOPE_NOT_SPECIFIED, ref, node, 0),</span>
<span class="fc" id="L418">        javaPort, addressFamily());</span>
  }

  /**
   * Returns an {@link AFTIPCSocketAddress} that refers to the topology service.
   *
   * @return A corresponding {@link AFTIPCSocketAddress} instance.
   * @throws SocketException if the operation fails.
   */
  public static AFTIPCSocketAddress ofTopologyService() throws SocketException {
<span class="nc" id="L428">    return resolveAddress(toBytes(AddressType.SERVICE_ADDR, Scope.SCOPE_NOT_SPECIFIED, TIPC_TOP_SRV,</span>
<span class="nc" id="L429">        TIPC_TOP_SRV, 0), 0, addressFamily());</span>
  }

  private static int parseUnsignedInt(String v) {
<span class="fc bfc" id="L433" title="All 2 branches covered.">    if (v.startsWith(&quot;0x&quot;)) {</span>
<span class="fc" id="L434">      return parseUnsignedInt(v.substring(2), 16);</span>
    } else {
<span class="fc" id="L436">      return parseUnsignedInt(v, 10);</span>
    }
  }

  /**
   * Returns an {@link AFTIPCSocketAddress} given a special {@link InetAddress} that encodes the
   * byte sequence of an AF_TIPC socket address, like those returned by {@link #wrapAddress()}.
   *
   * @param address The &quot;special&quot; {@link InetAddress}.
   * @param port The port (use 0 for &quot;none&quot;).
   * @return The {@link AFTIPCSocketAddress} instance.
   * @throws SocketException if the operation fails, for example when an unsupported address is
   *           specified.
   */
  public static AFTIPCSocketAddress unwrap(InetAddress address, int port) throws SocketException {
<span class="nc" id="L451">    return AFSocketAddress.unwrap(address, port, addressFamily());</span>
  }

  /**
   * Returns an {@link AFTIPCSocketAddress} given a special {@link InetAddress} hostname that
   * encodes the byte sequence of an AF_TIPC socket address, like those returned by
   * {@link #wrapAddress()}.
   *
   * @param hostname The &quot;special&quot; hostname, as provided by {@link InetAddress#getHostName()}.
   * @param port The port (use 0 for &quot;none&quot;).
   * @return The {@link AFTIPCSocketAddress} instance.
   * @throws SocketException if the operation fails, for example when an unsupported address is
   *           specified.
   */
  public static AFTIPCSocketAddress unwrap(String hostname, int port) throws SocketException {
<span class="nc" id="L466">    return AFSocketAddress.unwrap(hostname, port, addressFamily());</span>
  }

  /**
   * Returns an {@link AFTIPCSocketAddress} given a generic {@link SocketAddress}.
   *
   * @param address The address to unwrap.
   * @return The {@link AFTIPCSocketAddress} instance.
   * @throws SocketException if the operation fails, for example when an unsupported address is
   *           specified.
   */
  public static AFTIPCSocketAddress unwrap(SocketAddress address) throws SocketException {
<span class="nc" id="L478">    Objects.requireNonNull(address);</span>
<span class="nc bnc" id="L479" title="All 2 branches missed.">    if (!isSupportedAddress(address)) {</span>
<span class="nc" id="L480">      throw new SocketException(&quot;Unsupported address&quot;);</span>
    }
<span class="nc" id="L482">    return (AFTIPCSocketAddress) address;</span>
  }

  /**
   * Returns the scope of this address.
   *
   * @return The scope.
   */
  public Scope getScope() {
<span class="nc" id="L491">    byte[] bytes = getBytes();</span>
<span class="nc bnc" id="L492" title="All 2 branches missed.">    if (bytes.length != (5 * 4)) {</span>
<span class="nc" id="L493">      return Scope.SCOPE_NOT_SPECIFIED;</span>
    }
<span class="nc" id="L495">    return Scope.ofValue(ByteBuffer.wrap(bytes, 4, 4).getInt());</span>
  }

  /**
   * Returns the TIPC type part of this address.
   *
   * @return The type identifier
   */
  public int getTIPCType() {
<span class="nc" id="L504">    ByteBuffer bb = ByteBuffer.wrap(getBytes());</span>
<span class="nc" id="L505">    int a = bb.getInt(2 * 4);</span>
<span class="nc" id="L506">    return a;</span>
  }

  /**
   * Returns the TIPC instance part of this address.
   *
   * @return The instance identifier.
   */
  public int getTIPCInstance() {
<span class="nc" id="L515">    ByteBuffer bb = ByteBuffer.wrap(getBytes());</span>
<span class="nc" id="L516">    int a = bb.getInt(3 * 4);</span>
<span class="nc" id="L517">    return a;</span>
  }

  /**
   * Returns the TIPC domain part of this address.
   *
   * @return The domain identifier.
   */
  public int getTIPCDomain() {
<span class="nc" id="L526">    ByteBuffer bb = ByteBuffer.wrap(getBytes());</span>
<span class="nc" id="L527">    int a = bb.getInt(4 * 4);</span>
<span class="nc" id="L528">    return a;</span>
  }

  /**
   * Returns the TIPC lower instance of this address.
   *
   * @return The lower instance identifier.
   */
  public int getTIPCLower() {
<span class="nc" id="L537">    ByteBuffer bb = ByteBuffer.wrap(getBytes());</span>
<span class="nc" id="L538">    int a = bb.getInt(2 * 4);</span>
<span class="nc" id="L539">    return a;</span>
  }

  /**
   * Returns the TIPC upper instance of this address.
   *
   * @return The lower instance identifier.
   */
  public int getTIPCUpper() {
<span class="nc" id="L548">    ByteBuffer bb = ByteBuffer.wrap(getBytes());</span>
<span class="nc" id="L549">    int a = bb.getInt(3 * 4);</span>
<span class="nc" id="L550">    return a;</span>
  }

  /**
   * Returns the TIPC ref of this address.
   *
   * @return The ref identifier.
   */
  public int getTIPCRef() {
<span class="nc" id="L559">    ByteBuffer bb = ByteBuffer.wrap(getBytes());</span>
<span class="nc" id="L560">    int a = bb.getInt(2 * 4);</span>
<span class="nc" id="L561">    return a;</span>
  }

  /**
   * Returns the TIPC node hash of this address.
   *
   * @return The node hash.
   */
  public int getTIPCNodeHash() {
<span class="nc" id="L570">    ByteBuffer bb = ByteBuffer.wrap(getBytes());</span>
<span class="nc" id="L571">    int a = bb.getInt(3 * 4);</span>
<span class="nc" id="L572">    return a;</span>
  }

  @Override
  public String toString() {
<span class="nc" id="L577">    int port = getPort();</span>

<span class="nc" id="L579">    byte[] bytes = getBytes();</span>
<span class="nc bnc" id="L580" title="All 2 branches missed.">    if (bytes.length != (5 * 4)) {</span>
<span class="nc bnc" id="L581" title="All 2 branches missed.">      return getClass().getName() + &quot;[&quot; + (port == 0 ? &quot;&quot; : &quot;port=&quot; + port) + &quot;;UNKNOWN&quot; + &quot;]&quot;;</span>
    }

<span class="nc" id="L584">    ByteBuffer bb = ByteBuffer.wrap(bytes);</span>
<span class="nc" id="L585">    int typeId = bb.getInt();</span>
<span class="nc" id="L586">    int scopeId = bb.getInt();</span>
<span class="nc" id="L587">    int a = bb.getInt();</span>
<span class="nc" id="L588">    int b = bb.getInt();</span>
<span class="nc" id="L589">    int c = bb.getInt();</span>

<span class="nc" id="L591">    Scope scope = Scope.ofValue((byte) scopeId);</span>

<span class="nc" id="L593">    AddressType type = AddressType.ofValue(typeId);</span>
<span class="nc" id="L594">    String typeString = type.toDebugString(scope, a, b, c);</span>

<span class="nc bnc" id="L596" title="All 2 branches missed.">    return getClass().getName() + &quot;[&quot; + (port == 0 ? &quot;&quot; : &quot;port=&quot; + port + &quot;;&quot;) + typeString + &quot;]&quot;;</span>
  }

  @Override
  public boolean hasFilename() {
<span class="nc" id="L601">    return false;</span>
  }

  @Override
  public File getFile() throws FileNotFoundException {
<span class="nc" id="L606">    throw new FileNotFoundException(&quot;no file&quot;);</span>
  }

  /**
   * Checks if an {@link InetAddress} can be unwrapped to an {@link AFTIPCSocketAddress}.
   *
   * @param addr The instance to check.
   * @return {@code true} if so.
   * @see #wrapAddress()
   * @see #unwrap(InetAddress, int)
   */
  public static boolean isSupportedAddress(InetAddress addr) {
<span class="nc" id="L618">    return AFSocketAddress.isSupportedAddress(addr, addressFamily());</span>
  }

  /**
   * Checks if a {@link SocketAddress} can be unwrapped to an {@link AFTIPCSocketAddress}.
   *
   * @param addr The instance to check.
   * @return {@code true} if so.
   * @see #unwrap(InetAddress, int)
   */
  public static boolean isSupportedAddress(SocketAddress addr) {
<span class="nc" id="L629">    return (addr instanceof AFTIPCSocketAddress);</span>
  }

  @SuppressWarnings(&quot;cast&quot;)
  private static byte[] toBytes(AddressType addrType, Scope scope, int a, int b, int c) {
<span class="fc" id="L634">    ByteBuffer bb = ByteBuffer.allocate(5 * 4);</span>
<span class="fc" id="L635">    bb.putInt(addrType.value());</span>
<span class="fc" id="L636">    bb.putInt(scope.value());</span>
<span class="fc" id="L637">    bb.putInt(a);</span>
<span class="fc" id="L638">    bb.putInt(b);</span>
<span class="fc" id="L639">    bb.putInt(c);</span>
<span class="fc" id="L640">    return (byte[]) bb.flip().array();</span>
  }

  /**
   * Returns the corresponding {@link AFAddressFamily}.
   *
   * @return The address family instance.
   */
  @SuppressWarnings(&quot;null&quot;)
  public static synchronized AFAddressFamily&lt;AFTIPCSocketAddress&gt; addressFamily() {
<span class="fc bfc" id="L650" title="All 2 branches covered.">    if (afTipc == null) {</span>
<span class="fc" id="L651">      afTipc = AFAddressFamily.registerAddressFamily(&quot;tipc&quot;, //</span>
<span class="fc" id="L652">          AFTIPCSocketAddress.class, new AFSocketAddressConfig&lt;AFTIPCSocketAddress&gt;() {</span>

<span class="fc" id="L654">            private final AFSocketAddressConstructor&lt;AFTIPCSocketAddress&gt; addrConstr =</span>
<span class="pc bpc" id="L655" title="1 of 2 branches missed.">                isUseDeserializationForInit() ? AFTIPCSocketAddress::newAFSocketAddress</span>
<span class="fc" id="L656">                    : AFTIPCSocketAddress::new;</span>

            @Override
            protected AFTIPCSocketAddress parseURI(URI u, int port) throws SocketException {
<span class="nc" id="L660">              return AFTIPCSocketAddress.of(u, port);</span>
            }

            @Override
            protected AFSocketAddressConstructor&lt;AFTIPCSocketAddress&gt; addressConstructor() {
<span class="fc" id="L665">              return addrConstr;</span>
            }

            @Override
            protected String selectorProviderClassname() {
<span class="fc" id="L670">              return &quot;org.newsclub.net.unix.tipc.AFTIPCSelectorProvider&quot;;</span>
            }

            @Override
            protected Set&lt;String&gt; uriSchemes() {
<span class="fc" id="L675">              return new HashSet&lt;&gt;(Arrays.asList(&quot;tipc&quot;, &quot;http+tipc&quot;, &quot;https+tipc&quot;));</span>
            }
          });
      try {
<span class="nc" id="L679">        Class.forName(&quot;org.newsclub.net.unix.tipc.AFTIPCSelectorProvider&quot;);</span>
<span class="fc" id="L680">      } catch (ClassNotFoundException e) {</span>
        // ignore
<span class="nc" id="L682">      }</span>
    }
<span class="fc" id="L684">    return afTipc;</span>
  }

  private String toTipcInt(int v) {
<span class="fc bfc" id="L688" title="All 2 branches covered.">    if (v &lt; 0) {</span>
<span class="fc" id="L689">      return &quot;0x&quot; + toUnsignedString(v, 16);</span>
    } else {
<span class="fc" id="L691">      return toUnsignedString(v);</span>
    }
  }

  /**
   * Returns an {@link AFTIPCSocketAddress} for the given URI, if possible.
   *
   * @param uri The URI.
   * @return The address.
   * @throws SocketException if the operation fails.
   */
  @SuppressWarnings(&quot;PMD.ShortMethodName&quot;)
  public static AFTIPCSocketAddress of(URI uri) throws SocketException {
<span class="fc" id="L704">    return of(uri, -1);</span>
  }

  /**
   * Returns an {@link AFTIPCSocketAddress} for the given URI, if possible.
   *
   * @param uri The URI.
   * @param overridePort The port to forcibly use, or {@code -1} for &quot;don't override&quot;.
   * @return The address.
   * @throws SocketException if the operation fails.
   */
  @SuppressWarnings({
      &quot;PMD.CognitiveComplexity&quot;, &quot;PMD.CyclomaticComplexity&quot;, &quot;PMD.ExcessiveMethodLength&quot;,
      &quot;PMD.NcssCount&quot;, &quot;PMD.NPathComplexity&quot;, &quot;PMD.ShortMethodName&quot;})
  public static AFTIPCSocketAddress of(URI uri, int overridePort) throws SocketException {
<span class="pc bpc" id="L719" title="1 of 2 branches missed.">    switch (uri.getScheme()) {</span>
      case &quot;tipc&quot;:
      case &quot;http+tipc&quot;:
      case &quot;https+tipc&quot;:
<span class="fc" id="L723">        break;</span>
      default:
<span class="nc" id="L725">        throw new SocketException(&quot;Unsupported URI scheme: &quot; + uri.getScheme());</span>
    }

<span class="fc" id="L728">    String host = uri.getHost();</span>
<span class="fc bfc" id="L729" title="All 2 branches covered.">    if (host == null) {</span>
<span class="fc" id="L730">      host = uri.getAuthority();</span>
<span class="pc bpc" id="L731" title="1 of 2 branches missed.">      if (host != null) {</span>
<span class="fc" id="L732">        int at = host.indexOf('@');</span>
<span class="pc bpc" id="L733" title="1 of 2 branches missed.">        if (at &gt;= 0) {</span>
<span class="nc" id="L734">          host = host.substring(at + 1);</span>
        }
      }
    }
<span class="pc bpc" id="L738" title="1 of 2 branches missed.">    if (host == null) {</span>
<span class="nc" id="L739">      throw new SocketException(&quot;Cannot get hostname from URI: &quot; + uri);</span>
    }
<span class="pc bpc" id="L741" title="1 of 2 branches missed.">    int port = overridePort != -1 ? overridePort : uri.getPort();</span>
<span class="pc bpc" id="L742" title="1 of 2 branches missed.">    if (port != -1) {</span>
<span class="nc" id="L743">      host += &quot;:&quot; + port;</span>
    }
    try {
<span class="fc" id="L746">      Matcher m = PAT_TIPC_URI_HOST_AND_PORT.matcher(host);</span>
<span class="fc bfc" id="L747" title="All 2 branches covered.">      if (!m.matches()) {</span>
<span class="fc" id="L748">        throw new SocketException(&quot;Invalid TIPC URI: &quot; + uri);</span>
      }

<span class="fc" id="L751">      String typeStr = m.group(&quot;type&quot;);</span>
<span class="fc" id="L752">      String scopeStr = m.group(&quot;scope&quot;);</span>
<span class="fc bfc" id="L753" title="All 2 branches covered.">      if (typeStr == null) {</span>
<span class="fc" id="L754">        typeStr = m.group(&quot;type2&quot;);</span>
<span class="fc" id="L755">        scopeStr = m.group(&quot;scope2&quot;);</span>
      }
<span class="fc" id="L757">      String strA = m.group(&quot;a&quot;);</span>
<span class="fc" id="L758">      String strB = m.group(&quot;b&quot;);</span>
<span class="fc" id="L759">      String strC = m.group(&quot;c&quot;);</span>
<span class="fc" id="L760">      String javaPortStr = m.group(&quot;javaPort&quot;);</span>

      final AddressType addrType;
<span class="fc bfc" id="L763" title="All 7 branches covered.">      switch (typeStr == null ? &quot;&quot; : typeStr) {</span>
        case &quot;service&quot;:
<span class="fc" id="L765">          addrType = AddressType.SERVICE_ADDR;</span>
<span class="fc" id="L766">          break;</span>
        case &quot;service-range&quot;:
<span class="fc" id="L768">          addrType = AddressType.SERVICE_RANGE;</span>
<span class="fc" id="L769">          break;</span>
        case &quot;socket&quot;:
<span class="fc" id="L771">          addrType = AddressType.SOCKET_ADDR;</span>
<span class="fc" id="L772">          break;</span>
        case &quot;&quot;:
<span class="fc" id="L774">          addrType = AddressType.SERVICE_ADDR;</span>
<span class="fc" id="L775">          break;</span>
        default:
<span class="fc" id="L777">          addrType = AddressType.ofValue(parseUnsignedInt(typeStr));</span>
          break;
      }

      final Scope scope;
<span class="fc bfc" id="L782" title="All 7 branches covered.">      switch (scopeStr == null ? &quot;&quot; : scopeStr) {</span>
        case &quot;cluster&quot;:
<span class="fc" id="L784">          scope = Scope.SCOPE_CLUSTER;</span>
<span class="fc" id="L785">          break;</span>
        case &quot;node&quot;:
<span class="fc" id="L787">          scope = Scope.SCOPE_NODE;</span>
<span class="fc" id="L788">          break;</span>
        case &quot;default&quot;:
<span class="fc" id="L790">          scope = Scope.SCOPE_NOT_SPECIFIED;</span>
<span class="fc" id="L791">          break;</span>
        case &quot;&quot;:
<span class="fc bfc" id="L793" title="All 4 branches covered.">          if (addrType == AddressType.SERVICE_ADDR || addrType == AddressType.SERVICE_RANGE) { // NOPMD</span>
<span class="fc" id="L794">            scope = Scope.SCOPE_CLUSTER;</span>
          } else {
<span class="fc" id="L796">            scope = Scope.SCOPE_NOT_SPECIFIED;</span>
          }
<span class="fc" id="L798">          break;</span>
        default:
<span class="fc" id="L800">          scope = Scope.ofValue(parseUnsignedInt(scopeStr));</span>
          break;
      }

<span class="fc" id="L804">      int a = parseUnsignedInt(strA);</span>
<span class="fc" id="L805">      int b = parseUnsignedInt(strB);</span>

      int c;
<span class="pc bpc" id="L808" title="1 of 4 branches missed.">      if (strC == null || strC.isEmpty()) {</span>
<span class="fc bfc" id="L809" title="All 2 branches covered.">        if (addrType == AddressType.SERVICE_RANGE) { // NOPMD</span>
<span class="fc" id="L810">          c = b;</span>
        } else {
<span class="fc" id="L812">          c = 0;</span>
        }
      } else {
<span class="fc" id="L815">        c = parseUnsignedInt(strC);</span>
      }

<span class="pc bpc" id="L818" title="1 of 4 branches missed.">      int javaPort = javaPortStr == null || javaPortStr.isEmpty() ? port : Integer.parseInt(</span>
          javaPortStr);
<span class="pc bpc" id="L820" title="1 of 2 branches missed.">      if (overridePort != -1) {</span>
<span class="nc" id="L821">        javaPort = overridePort;</span>
      }

<span class="fc" id="L824">      return resolveAddress(toBytes(addrType, scope, a, b, c), javaPort, addressFamily());</span>
<span class="nc" id="L825">    } catch (IllegalArgumentException e) {</span>
<span class="nc" id="L826">      throw (SocketException) new SocketException(&quot;Invalid TIPC URI: &quot; + uri).initCause(e);</span>
    }
  }

  @Override
  @SuppressWarnings({&quot;PMD.CognitiveComplexity&quot;, &quot;PMD.CompareObjectsWithEquals&quot;})
  public URI toURI(String scheme, URI template) throws IOException {
<span class="pc bpc" id="L833" title="1 of 2 branches missed.">    switch (scheme) {</span>
      case &quot;tipc&quot;:
      case &quot;http+tipc&quot;:
      case &quot;https+tipc&quot;:
<span class="fc" id="L837">        break;</span>
      default:
<span class="nc" id="L839">        return super.toURI(scheme, template);</span>
    }

<span class="fc" id="L842">    byte[] bytes = getBytes();</span>
<span class="pc bpc" id="L843" title="1 of 2 branches missed.">    if (bytes.length != (5 * 4)) {</span>
<span class="nc" id="L844">      return super.toURI(scheme, template);</span>
    }

<span class="fc" id="L847">    ByteBuffer bb = ByteBuffer.wrap(bytes);</span>
<span class="fc" id="L848">    AddressType addrType = AddressType.ofValue(bb.getInt());</span>
<span class="fc" id="L849">    Scope scope = Scope.ofValue(bb.getInt());</span>

<span class="fc" id="L851">    StringBuilder sb = new StringBuilder();</span>

<span class="fc" id="L853">    boolean haveScope = true;</span>
<span class="fc bfc" id="L854" title="All 2 branches covered.">    if (scope == Scope.SCOPE_NOT_SPECIFIED) {</span>
<span class="fc" id="L855">      sb.append(&quot;default-&quot;);</span>
<span class="fc bfc" id="L856" title="All 2 branches covered.">    } else if (scope == Scope.SCOPE_CLUSTER) {</span>
<span class="pc bpc" id="L857" title="1 of 4 branches missed.">      if (addrType == AddressType.SERVICE_ADDR || addrType == AddressType.SERVICE_RANGE) { // NOPMD</span>
        // implied
<span class="fc" id="L859">        haveScope = false;</span>
      } else {
<span class="nc" id="L861">        sb.append(&quot;cluster-&quot;);</span>
      }
<span class="fc bfc" id="L863" title="All 2 branches covered.">    } else if (scope == Scope.SCOPE_NODE) {</span>
<span class="fc" id="L864">      sb.append(&quot;node-&quot;);</span>
    } else {
<span class="fc" id="L866">      sb.append(toTipcInt(scope.value()));</span>
<span class="fc" id="L867">      sb.append('-');</span>
    }

<span class="fc" id="L870">    boolean addrTypeImplied = false;</span>
<span class="fc bfc" id="L871" title="All 2 branches covered.">    if (addrType == AddressType.SERVICE_ADDR) {</span>
<span class="fc bfc" id="L872" title="All 2 branches covered.">      if (!haveScope) {</span>
<span class="fc" id="L873">        addrTypeImplied = true;</span>
      } else {
<span class="fc" id="L875">        sb.append(&quot;service&quot;);</span>
      }
<span class="fc bfc" id="L877" title="All 2 branches covered.">    } else if (addrType == AddressType.SERVICE_RANGE) {</span>
<span class="fc" id="L878">      sb.append(&quot;service-range&quot;);</span>
<span class="pc bpc" id="L879" title="1 of 2 branches missed.">    } else if (addrType == AddressType.SOCKET_ADDR) {</span>
<span class="fc" id="L880">      sb.append(&quot;socket&quot;);</span>
    } else {
<span class="nc" id="L882">      sb.append(toTipcInt(addrType.value()));</span>
    }
<span class="fc bfc" id="L884" title="All 2 branches covered.">    if (!addrTypeImplied) {</span>
<span class="fc" id="L885">      sb.append('.');</span>
    }

<span class="fc" id="L888">    int a = bb.getInt();</span>
<span class="fc" id="L889">    int b = bb.getInt();</span>
<span class="fc" id="L890">    int c = bb.getInt();</span>

<span class="fc" id="L892">    sb.append(toTipcInt(a));</span>
<span class="fc" id="L893">    sb.append('.');</span>
<span class="fc" id="L894">    sb.append(toTipcInt(b));</span>
<span class="fc bfc" id="L895" title="All 2 branches covered.">    if (c != 0) {</span>
<span class="fc" id="L896">      sb.append('.');</span>
<span class="fc" id="L897">      sb.append(toTipcInt(c));</span>
    }

<span class="fc" id="L900">    return new HostAndPort(sb.toString(), getPort()).toURI(scheme, template);</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>