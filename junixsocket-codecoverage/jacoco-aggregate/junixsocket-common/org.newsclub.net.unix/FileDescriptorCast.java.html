<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>FileDescriptorCast.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">junixsocket-codecoverage</a> &gt; <a href="../index.html" class="el_bundle">junixsocket-common</a> &gt; <a href="index.source.html" class="el_package">org.newsclub.net.unix</a> &gt; <span class="el_source">FileDescriptorCast.java</span></div><h1>FileDescriptorCast.java</h1><pre class="source lang-java linenums">/*
 * junixsocket
 *
 * Copyright 2009-2024 Christian Kohlschütter
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.newsclub.net.unix;

import java.io.Closeable;
import java.io.FileDescriptor;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.lang.ProcessBuilder.Redirect;
import java.net.DatagramSocket;
import java.net.ServerSocket;
import java.net.Socket;
import java.nio.channels.DatagramChannel;
import java.nio.channels.FileChannel;
import java.nio.channels.ReadableByteChannel;
import java.nio.channels.ServerSocketChannel;
import java.nio.channels.SocketChannel;
import java.nio.channels.WritableByteChannel;
import java.nio.channels.spi.AbstractSelectableChannel;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;
import java.util.Objects;
import java.util.Set;

import org.eclipse.jdt.annotation.NonNull;

import com.kohlschutter.annotations.compiletime.SuppressFBWarnings;

/**
 * Provides object-oriented access to file descriptors via {@link InputStream}, {@link Socket},
 * etc., depending on the file descriptor type.
 * &lt;p&gt;
 * Typical usage:
 * &lt;/p&gt;
 * &lt;pre&gt;&lt;code&gt;
 * FileDescriptor fd;
 *
 * // succeeds if fd refers to an AF_UNIX stream socket
 * AFUNIXSocket socket = FileDescriptorCast.using(fd).as(AFUNIXSocket.class);
 *
 * // succeeds if fd refers to an AF_UNIX datagram socket
 * AFUNIXDatagramChannel channel = FileDescriptorCast.using(fd).as(AFUNIXDatagramChannel.class);
 *
 * // always succeeds
 * InputStream in = FileDescriptorCast.using(fd).as(InputStream.class);
 * OutputStream in = FileDescriptorCast.using(fd).as(OutputStream.class);
 * &lt;/code&gt;&lt;/pre&gt;
 * &lt;p&gt;
 * &lt;b&gt;Important notes&lt;/b&gt;
 * &lt;ol&gt;
 * &lt;li&gt;On some platforms (e.g., Solaris, Illumos) you may need to re-apply a read timeout (e.g.,
 * using {@link Socket#setSoTimeout(int)}) after obtaining the socket.&lt;/li&gt;
 * &lt;li&gt;You may lose Java port information for {@link AFSocketAddress} implementations that do not
 * encode this information directly (such as {@link AFUNIXSocketAddress} and
 * {@link AFTIPCSocketAddress}).&lt;/li&gt;
 * &lt;li&gt;The &quot;blocking&quot; state of a socket may be forcibly changed to &quot;blocking&quot; when performing the
 * cast, especially when casting to {@link Socket}, {@link DatagramSocket} or {@link ServerSocket}
 * and any of their subclasses where &quot;blocking&quot; is the expected state.&lt;/li&gt;
 * &lt;li&gt;When calling {@link #using(FileDescriptor)} for a {@link FileDescriptor} obtained from
 * another socket or other resource in the same JVM (i.e., not from another process), especially for
 * sockets provided by junixsocket itself, there is a chance that the garbage collector may clean up
 * the original socket at an opportune moment, thereby closing the resource underlying the shared
 * {@link FileDescriptor} prematurely.
 * &lt;p&gt;
 * This is considered an edge-case, and deliberately not handled automatically for performance and
 * portability reasons: We would have to do additional reference counting on all FileDescriptor
 * instances, either through patching {@code FileCleanable} or a shared data structure.
 * &lt;p&gt;
 * The issue can be prevented by keeping a reference to the original object, such as keeping it in
 * an enclosing try-with-resources block or as a member variable, for example. Alternatively, using
 * a &quot;duplicate&quot; file descriptor (via {@link #duplicating(FileDescriptor)}) circumvents this
 * problem, at the cost of using additional system resources.&lt;/li&gt;
 * &lt;li&gt;As a consequence of the previous point: For {@link #using(FileDescriptor)}: when casting file
 * descriptors that belong to a junixsocket-controlled sockets, the target socket is configured in a
 * way such that garbage collection will not automatically close the target's underlying file
 * descriptor (but still potentially any file descriptors received from other processes via
 * ancillary messages).&lt;/li&gt;
 * &lt;li&gt;The same restrictions as for {@link #using(FileDescriptor)} apply to
 * {@link #unsafeUsing(int)} as well.&lt;/li&gt;
 * &lt;/ol&gt;
 *
 * @author Christian Kohlschütter
 */
@SuppressWarnings(&quot;PMD.CouplingBetweenObjects&quot;)
public final class FileDescriptorCast implements FileDescriptorAccess {
<span class="fc" id="L104">  private static final Map&lt;Class&lt;?&gt;, CastingProviderMap&gt; PRIMARY_TYPE_PROVIDERS_MAP = Collections</span>
<span class="fc" id="L105">      .synchronizedMap(new HashMap&lt;&gt;());</span>

  private static final AFFunction&lt;FileDescriptor, FileInputStream&gt; FD_IS_PROVIDER = System
<span class="pc bpc" id="L108" title="1 of 2 branches missed.">      .getProperty(&quot;osv.version&quot;) != null ? LenientFileInputStream::new : FileInputStream::new;</span>

<span class="fc" id="L110">  private static final CastingProviderMap GLOBAL_PROVIDERS_FINAL = new CastingProviderMap() {</span>

    @Override
    protected void addProviders() {
      // FileDescriptor and Object cannot be overridden
<span class="fc" id="L115">      addProvider(FileDescriptor.class, new CastingProvider&lt;FileDescriptor&gt;() {</span>
        @Override
        public FileDescriptor provideAs(FileDescriptorCast fdc,
            Class&lt;? super FileDescriptor&gt; desiredType) throws IOException {
<span class="fc" id="L119">          return fdc.getFileDescriptor();</span>
        }
      });
<span class="fc" id="L122">    }</span>
  };

<span class="fc" id="L125">  private static final CastingProviderMap GLOBAL_PROVIDERS = new CastingProviderMap() {</span>
    @Override
    protected void addProviders() {
<span class="fc" id="L128">      addProvider(WritableByteChannel.class, new CastingProvider&lt;WritableByteChannel&gt;() {</span>
        @SuppressWarnings(&quot;resource&quot;)
        @Override
        public WritableByteChannel provideAs(FileDescriptorCast fdc,
            Class&lt;? super WritableByteChannel&gt; desiredType) throws IOException {
<span class="nc" id="L133">          return new FileOutputStream(fdc.getFileDescriptor()).getChannel();</span>
        }
      });
<span class="fc" id="L136">      addProvider(ReadableByteChannel.class, new CastingProvider&lt;ReadableByteChannel&gt;() {</span>
        @Override
        public ReadableByteChannel provideAs(FileDescriptorCast fdc,
            Class&lt;? super ReadableByteChannel&gt; desiredType) throws IOException {
<span class="nc" id="L140">          return FD_IS_PROVIDER.apply(fdc.getFileDescriptor()).getChannel();</span>
        }
      });

<span class="fc" id="L144">      addProvider(FileChannel.class, new CastingProvider&lt;FileChannel&gt;() {</span>
        @Override
        public FileChannel provideAs(FileDescriptorCast fdc, Class&lt;? super FileChannel&gt; desiredType)
            throws IOException {
<span class="fc" id="L148">          return RAFChannelProvider.getFileChannel(fdc.getFileDescriptor());</span>
        }
      });

<span class="fc" id="L152">      addProvider(FileOutputStream.class, new CastingProvider&lt;FileOutputStream&gt;() {</span>
        @Override
        public FileOutputStream provideAs(FileDescriptorCast fdc,
            Class&lt;? super FileOutputStream&gt; desiredType) throws IOException {
<span class="fc" id="L156">          return new FileOutputStream(fdc.getFileDescriptor());</span>
        }
      });
<span class="fc" id="L159">      addProvider(FileInputStream.class, new CastingProvider&lt;FileInputStream&gt;() {</span>
        @Override
        public FileInputStream provideAs(FileDescriptorCast fdc,
            Class&lt;? super FileInputStream&gt; desiredType) throws IOException {
<span class="fc" id="L163">          return FD_IS_PROVIDER.apply(fdc.getFileDescriptor());</span>
        }
      });
<span class="fc" id="L166">      addProvider(FileDescriptor.class, new CastingProvider&lt;FileDescriptor&gt;() {</span>
        @Override
        public FileDescriptor provideAs(FileDescriptorCast fdc,
            Class&lt;? super FileDescriptor&gt; desiredType) throws IOException {
<span class="nc" id="L170">          return fdc.getFileDescriptor();</span>
        }
      });
<span class="fc" id="L173">      addProvider(Integer.class, new CastingProvider&lt;Integer&gt;() {</span>
        @Override
        public Integer provideAs(FileDescriptorCast fdc, Class&lt;? super Integer&gt; desiredType)
            throws IOException {
<span class="fc" id="L177">          FileDescriptor fd = fdc.getFileDescriptor();</span>
<span class="pc bpc" id="L178" title="1 of 2 branches missed.">          int val = fd.valid() ? NativeUnixSocket.getFD(fd) : -1;</span>
<span class="pc bpc" id="L179" title="1 of 2 branches missed.">          if (val == -1) {</span>
<span class="nc" id="L180">            throw new IOException(&quot;Not a valid file descriptor&quot;);</span>
          }
<span class="fc" id="L182">          return val;</span>
        }
      });

<span class="pc bpc" id="L186" title="1 of 2 branches missed.">      if (AFSocket.supports(AFSocketCapability.CAPABILITY_FD_AS_REDIRECT)) {</span>
<span class="fc" id="L187">        addProvider(Redirect.class, new CastingProvider&lt;Redirect&gt;() {</span>
          @Override
          public Redirect provideAs(FileDescriptorCast fdc, Class&lt;? super Redirect&gt; desiredType)
              throws IOException {

<span class="fc" id="L192">            Redirect red = NativeUnixSocket.initRedirect(fdc.getFileDescriptor());</span>
<span class="pc bpc" id="L193" title="1 of 2 branches missed.">            if (red == null) {</span>
<span class="nc" id="L194">              throw new ClassCastException(&quot;Cannot access file descriptor as &quot; + desiredType);</span>
            }
<span class="fc" id="L196">            return red;</span>
          }
        });
      }
<span class="fc" id="L200">    }</span>
  };

<span class="fc" id="L203">  private static final int FD_IN = getFdIfPossible(FileDescriptor.in);</span>
<span class="fc" id="L204">  private static final int FD_OUT = getFdIfPossible(FileDescriptor.out);</span>
<span class="fc" id="L205">  private static final int FD_ERR = getFdIfPossible(FileDescriptor.err);</span>

  static {
<span class="fc" id="L208">    registerGenericSocketSupport();</span>
<span class="fc" id="L209">  }</span>

  private final FileDescriptor fdObj;

<span class="fc" id="L213">  private int localPort = 0;</span>
<span class="fc" id="L214">  private int remotePort = 0;</span>

  private final CastingProviderMap cpm;

<span class="fc" id="L218">  private FileDescriptorCast(FileDescriptor fdObj, CastingProviderMap cpm) {</span>
<span class="fc" id="L219">    this.fdObj = Objects.requireNonNull(fdObj);</span>
<span class="fc" id="L220">    this.cpm = Objects.requireNonNull(cpm);</span>
<span class="fc" id="L221">  }</span>

  private static int getFdIfPossible(FileDescriptor fd) {
<span class="pc bpc" id="L224" title="1 of 2 branches missed.">    if (!NativeUnixSocket.isLoaded()) {</span>
<span class="nc" id="L225">      return -1;</span>
    }
    try {
<span class="pc bpc" id="L228" title="1 of 2 branches missed.">      if (!fd.valid()) {</span>
<span class="nc" id="L229">        return -1;</span>
      }
<span class="fc" id="L231">      return NativeUnixSocket.getFD(fd);</span>
<span class="nc" id="L232">    } catch (IOException e) {</span>
<span class="nc" id="L233">      return -1;</span>
    }
  }

  private static void registerCastingProviders(Class&lt;?&gt; primaryType, CastingProviderMap cpm) {
<span class="fc" id="L238">    Objects.requireNonNull(primaryType);</span>
    CastingProviderMap prev;
<span class="pc bpc" id="L240" title="1 of 2 branches missed.">    if ((prev = PRIMARY_TYPE_PROVIDERS_MAP.put(primaryType, cpm)) != null) {</span>
<span class="nc" id="L241">      PRIMARY_TYPE_PROVIDERS_MAP.put(primaryType, prev);</span>
<span class="nc" id="L242">      throw new IllegalStateException(&quot;Already registered: &quot; + primaryType);</span>
    }
<span class="fc" id="L244">  }</span>

  static &lt;A extends AFSocketAddress&gt; void registerCastingProviders(
      AFAddressFamilyConfig&lt;A&gt; config) {
<span class="fc" id="L248">    Class&lt;? extends AFSocket&lt;A&gt;&gt; socketClass = config.socketClass();</span>
<span class="fc" id="L249">    Class&lt;? extends AFDatagramSocket&lt;A&gt;&gt; datagramSocketClass = config.datagramSocketClass();</span>

<span class="fc" id="L251">    registerCastingProviders(socketClass, new CastingProviderMap() {</span>

      @SuppressWarnings(&quot;null&quot;)
      @Override
      protected void addProviders() {
<span class="fc" id="L256">        addProviders(GLOBAL_PROVIDERS);</span>

<span class="fc" id="L258">        final CastingProviderSocketOrChannel&lt;AFSocket&lt;A&gt;&gt; cpSocketOrChannel = (fdc, desiredType,</span>
<span class="fc" id="L259">            isChannel) -&gt; reconfigure(isChannel, AFSocket.newInstance(config.socketConstructor(),</span>
<span class="fc" id="L260">                (AFSocketFactory&lt;A&gt;) null, fdc.getFileDescriptor(), fdc.localPort, fdc.remotePort));</span>
<span class="fc" id="L261">        final CastingProviderSocketOrChannel&lt;AFServerSocket&lt;A&gt;&gt; cpServerSocketOrChannel = (fdc,</span>
<span class="fc" id="L262">            desiredType, isChannel) -&gt; reconfigure(isChannel, AFServerSocket.newInstance(config</span>
<span class="fc" id="L263">                .serverSocketConstructor(), fdc.getFileDescriptor(), fdc.localPort,</span>
                fdc.remotePort));

<span class="fc" id="L266">        registerGenericSocketProviders();</span>

<span class="fc" id="L268">        addProvider(socketClass, (fdc, desiredType) -&gt; cpSocketOrChannel.provideAs(fdc, desiredType,</span>
            false));
<span class="fc" id="L270">        addProvider(config.serverSocketClass(), (fdc, desiredType) -&gt; cpServerSocketOrChannel</span>
<span class="fc" id="L271">            .provideAs(fdc, desiredType, false));</span>
<span class="fc" id="L272">        addProvider(config.socketChannelClass(), (fdc, desiredType) -&gt; cpSocketOrChannel.provideAs(</span>
<span class="fc" id="L273">            fdc, AFSocket.class, true).getChannel());</span>
<span class="fc" id="L274">        addProvider(config.serverSocketChannelClass(), (fdc, desiredType) -&gt; cpServerSocketOrChannel</span>
<span class="fc" id="L275">            .provideAs(fdc, AFServerSocket.class, true).getChannel());</span>
<span class="fc" id="L276">      }</span>
    });

<span class="fc" id="L279">    registerCastingProviders(datagramSocketClass, new CastingProviderMap() {</span>

      @SuppressWarnings(&quot;null&quot;)
      @Override
      protected void addProviders() {
<span class="fc" id="L284">        addProviders(GLOBAL_PROVIDERS);</span>

<span class="fc" id="L286">        final CastingProviderSocketOrChannel&lt;AFDatagramSocket&lt;A&gt;&gt; cpDatagramSocketOrChannel = (fdc,</span>
<span class="fc" id="L287">            desiredType, isChannel) -&gt; reconfigure(isChannel, AFDatagramSocket.newInstance(config</span>
<span class="fc" id="L288">                .datagramSocketConstructor(), fdc.getFileDescriptor(), fdc.localPort,</span>
                fdc.remotePort));

<span class="fc" id="L291">        registerGenericDatagramSocketProviders();</span>

<span class="pc" id="L293">        addProvider(datagramSocketClass, (fdc, desiredType) -&gt; cpDatagramSocketOrChannel.provideAs(</span>
            fdc, desiredType, false));
<span class="fc" id="L295">        addProvider(config.datagramChannelClass(), (fdc, desiredType) -&gt; cpDatagramSocketOrChannel</span>
<span class="fc" id="L296">            .provideAs(fdc, AFDatagramSocket.class, true).getChannel());</span>
<span class="fc" id="L297">      }</span>
    });
<span class="fc" id="L299">  }</span>

  private abstract static class CastingProviderMap {
<span class="fc" id="L302">    private final Map&lt;Class&lt;?&gt;, CastingProvider&lt;?&gt;&gt; providers = new HashMap&lt;&gt;();</span>
<span class="fc" id="L303">    private final Set&lt;Class&lt;?&gt;&gt; classes = Collections.unmodifiableSet(providers.keySet());</span>

    @SuppressWarnings(&quot;PMD.ConstructorCallsOverridableMethod&quot;)
<span class="fc" id="L306">    protected CastingProviderMap() {</span>
<span class="fc" id="L307">      addProviders();</span>

<span class="fc" id="L309">      addProviders(GLOBAL_PROVIDERS_FINAL);</span>
<span class="fc" id="L310">    }</span>

    @SuppressWarnings(&quot;null&quot;)
    protected void registerGenericSocketProviders() {
<span class="fc" id="L314">      final CastingProviderSocketOrChannel&lt;AFSocket&lt;AFGenericSocketAddress&gt;&gt; cpSocketOrChannelGeneric =</span>
<span class="fc" id="L315">          (fdc, desiredType, isChannel) -&gt; reconfigure(isChannel, AFSocket.newInstance(</span>
              AFGenericSocket::new, (AFSocketFactory&lt;AFGenericSocketAddress&gt;) null, fdc
<span class="fc" id="L317">                  .getFileDescriptor(), fdc.localPort, fdc.remotePort));</span>
<span class="fc" id="L318">      final CastingProviderSocketOrChannel&lt;AFServerSocket&lt;AFGenericSocketAddress&gt;&gt; cpServerSocketOrChannelGeneric =</span>
<span class="fc" id="L319">          (fdc, desiredType, isChannel) -&gt; reconfigure(isChannel, AFServerSocket.newInstance(</span>
<span class="fc" id="L320">              AFGenericServerSocket::new, fdc.getFileDescriptor(), fdc.localPort, fdc.remotePort));</span>

<span class="fc" id="L322">      addProvider(AFGenericSocket.class, (fdc, desiredType) -&gt; cpSocketOrChannelGeneric.provideAs(</span>
          fdc, desiredType, false));
<span class="pc" id="L324">      addProvider(AFGenericServerSocket.class, (fdc, desiredType) -&gt; cpServerSocketOrChannelGeneric</span>
<span class="nc" id="L325">          .provideAs(fdc, desiredType, false));</span>
<span class="fc" id="L326">      addProvider(AFGenericSocketChannel.class, (fdc, desiredType) -&gt; cpSocketOrChannelGeneric</span>
<span class="nc" id="L327">          .provideAs(fdc, AFSocket.class, true).getChannel());</span>
<span class="fc" id="L328">      addProvider(AFGenericServerSocketChannel.class, (fdc,</span>
<span class="fc" id="L329">          desiredType) -&gt; cpServerSocketOrChannelGeneric.provideAs(fdc, AFServerSocket.class, true)</span>
<span class="fc" id="L330">              .getChannel());</span>
<span class="fc" id="L331">    }</span>

    @SuppressWarnings(&quot;null&quot;)
    protected void registerGenericDatagramSocketProviders() {
<span class="fc" id="L335">      final CastingProviderSocketOrChannel&lt;AFDatagramSocket&lt;AFGenericSocketAddress&gt;&gt; cpDatagramSocketOrChannelGeneric =</span>
<span class="nc" id="L336">          (fdc, desiredType, isChannel) -&gt; reconfigure(isChannel, AFDatagramSocket.newInstance(</span>
<span class="nc" id="L337">              AFGenericDatagramSocket::new, fdc.getFileDescriptor(), fdc.localPort,</span>
              fdc.remotePort));

<span class="pc" id="L340">      addProvider(AFDatagramSocket.class, (fdc, desiredType) -&gt; cpDatagramSocketOrChannelGeneric</span>
<span class="nc" id="L341">          .provideAs(fdc, desiredType, false));</span>
<span class="fc" id="L342">      addProvider(AFDatagramChannel.class, (fdc, desiredType) -&gt; cpDatagramSocketOrChannelGeneric</span>
<span class="nc" id="L343">          .provideAs(fdc, AFDatagramSocket.class, true).getChannel());</span>
<span class="fc" id="L344">    }</span>

    protected abstract void addProviders();

    protected final &lt;T&gt; void addProvider(Class&lt;T&gt; type, CastingProvider&lt;?&gt; cp) {
<span class="fc" id="L349">      Objects.requireNonNull(type);</span>

<span class="fc" id="L351">      addProvider0(type, cp);</span>
<span class="fc" id="L352">    }</span>

    private void addProvider0(Class&lt;?&gt; type, CastingProvider&lt;?&gt; cp) {
<span class="fc bfc" id="L355" title="All 2 branches covered.">      if (providers.put(type, cp) != cp) { // NOPMD</span>
<span class="fc bfc" id="L356" title="All 2 branches covered.">        for (Class&lt;?&gt; cl : type.getInterfaces()) {</span>
<span class="fc" id="L357">          addProvider0(cl, cp);</span>
        }
<span class="fc" id="L359">        Class&lt;?&gt; scl = type.getSuperclass();</span>
<span class="fc bfc" id="L360" title="All 2 branches covered.">        if (scl != null) {</span>
<span class="fc" id="L361">          addProvider0(scl, cp);</span>
        }
      }
<span class="fc" id="L364">    }</span>

    protected final void addProviders(CastingProviderMap other) {
<span class="pc bpc" id="L367" title="1 of 4 branches missed.">      if (other == null || other == this) { // NOPMD</span>
<span class="fc" id="L368">        return;</span>
      }
<span class="fc" id="L370">      this.providers.putAll(other.providers);</span>
<span class="fc" id="L371">    }</span>

    @SuppressWarnings(&quot;unchecked&quot;)
    public &lt;T&gt; CastingProvider&lt;? extends T&gt; get(Class&lt;T&gt; desiredType) {
<span class="fc" id="L375">      return (CastingProvider&lt;? extends T&gt;) providers.get(desiredType);</span>
    }
  }

  @FunctionalInterface
  private interface CastingProvider&lt;T&gt; {
    T provideAs(FileDescriptorCast fdc, Class&lt;? super T&gt; desiredType) throws IOException;
  }

  @FunctionalInterface
  private interface CastingProviderSocketOrChannel&lt;T&gt; {
    T provideAs(FileDescriptorCast fdc, Class&lt;? super T&gt; desiredType, boolean isChannel)
        throws IOException;
  }

  /**
   * Creates a {@link FileDescriptorCast} using the given file descriptor.
   * &lt;p&gt;
   * Note that if any resource that also references this {@link FileDescriptor} is
   * garbage-collected, the cleanup for that object may close the referenced {@link FileDescriptor},
   * thereby resulting in premature connection losses, etc. See {@link #duplicating(FileDescriptor)}
   * for a solution to this problem.
   *
   * @param fdObj The file descriptor.
   * @return The {@link FileDescriptorCast} instance.
   * @throws IOException on error, especially if the given file descriptor is invalid or
   *           unsupported.
   */
  public static FileDescriptorCast using(FileDescriptor fdObj) throws IOException {
<span class="fc bfc" id="L404" title="All 2 branches covered.">    if (!fdObj.valid()) {</span>
<span class="fc" id="L405">      throw new IOException(&quot;Not a valid file descriptor&quot;);</span>
    }

<span class="pc bpc" id="L408" title="1 of 2 branches missed.">    Class&lt;?&gt; primaryType = NativeUnixSocket.isLoaded() ? NativeUnixSocket.primaryType(fdObj) : null;</span>
<span class="fc bfc" id="L409" title="All 2 branches covered.">    if (primaryType == null) {</span>
<span class="fc" id="L410">      primaryType = FileDescriptor.class;</span>
    }

<span class="fc" id="L413">    triggerInit();</span>

<span class="fc" id="L415">    CastingProviderMap map = PRIMARY_TYPE_PROVIDERS_MAP.get(primaryType);</span>
<span class="fc bfc" id="L416" title="All 2 branches covered.">    return new FileDescriptorCast(fdObj, map == null ? GLOBAL_PROVIDERS : map);</span>
  }

  /**
   * Creates a {@link FileDescriptorCast} using a &lt;em&gt;duplicate&lt;/em&gt; of the given file descriptor.
   * &lt;p&gt;
   * Duplicating a file descriptor is performed at the system-level, which means an additional file
   * descriptor pointing to the same resource as the original is created by the operating system.
   * &lt;p&gt;
   * The advantage of using {@link #duplicating(FileDescriptor)} over {@link #using(FileDescriptor)}
   * is that neither implicit garbage collection nor an explicit call to {@link Closeable#close()}
   * on a resource owning the original {@link FileDescriptor} affects the availability of the
   * resource from the target of the cast.
   *
   * @param fdObj The file descriptor to duplicate.
   * @return The {@link FileDescriptorCast} instance.
   * @throws IOException on error, especially if the given file descriptor is invalid or
   *           unsupported, or if duplicating fails or is unsupported.
   */
  public static FileDescriptorCast duplicating(FileDescriptor fdObj) throws IOException {
<span class="pc bpc" id="L436" title="1 of 2 branches missed.">    if (!fdObj.valid()) {</span>
<span class="nc" id="L437">      throw new IOException(&quot;Not a valid file descriptor&quot;);</span>
    }

<span class="fc" id="L440">    FileDescriptor duplicate = NativeUnixSocket.duplicate(fdObj, new FileDescriptor());</span>
<span class="pc bpc" id="L441" title="1 of 2 branches missed.">    if (duplicate == null) {</span>
<span class="nc" id="L442">      throw new IOException(&quot;Could not duplicate file descriptor&quot;);</span>
    }
<span class="fc" id="L444">    return using(duplicate);</span>
  }

  /**
   * Creates a {@link FileDescriptorCast} using the given native file descriptor value.
   * &lt;p&gt;
   * This method is inherently unsafe as it may
   * &lt;ol&gt;
   * &lt;li&gt;make assumptions on the internal system representation of a file descriptor (which differs
   * between Windows and Unix, for example).&lt;/li&gt;
   * &lt;li&gt;provide access to resources that are otherwise not accessible&lt;/li&gt;
   * &lt;/ol&gt;
   * &lt;p&gt;
   * Note that attempts are made to reuse {@link FileDescriptor#in}, {@link FileDescriptor#out}, and
   * {@link FileDescriptor#err}, respectively.
   *
   * @param fd The system-native file descriptor value.
   * @return The {@link FileDescriptorCast} instance.
   * @throws IOException on error, especially if the given file descriptor is invalid or
   *           unsupported, or when &quot;unsafe&quot; operations are unavailable or manually disabled for the
   *           current environment.
   */
  @Unsafe
  public static FileDescriptorCast unsafeUsing(int fd) throws IOException {
<span class="fc" id="L468">    AFSocket.ensureUnsafeSupported();</span>

    FileDescriptor fdObj;
<span class="fc bfc" id="L471" title="All 2 branches covered.">    if (fd == -1) {</span>
<span class="fc" id="L472">      throw new IOException(&quot;Not a valid file descriptor&quot;);</span>
<span class="pc bpc" id="L473" title="1 of 2 branches missed.">    } else if (fd == FD_IN) {</span>
<span class="nc" id="L474">      fdObj = FileDescriptor.in;</span>
<span class="fc bfc" id="L475" title="All 2 branches covered.">    } else if (fd == FD_OUT) {</span>
<span class="fc" id="L476">      fdObj = FileDescriptor.out;</span>
<span class="pc bpc" id="L477" title="1 of 2 branches missed.">    } else if (fd == FD_ERR) {</span>
<span class="nc" id="L478">      fdObj = FileDescriptor.err;</span>
    } else {
<span class="fc" id="L480">      fdObj = null;</span>
    }

<span class="fc bfc" id="L483" title="All 2 branches covered.">    if (fdObj != null) {</span>
<span class="fc" id="L484">      int check = getFdIfPossible(fdObj);</span>
<span class="pc bpc" id="L485" title="1 of 2 branches missed.">      if (fd == check) {</span>
<span class="fc" id="L486">        return using(fdObj);</span>
      }
    }

<span class="fc" id="L490">    fdObj = new FileDescriptor();</span>
<span class="fc" id="L491">    NativeUnixSocket.initFD(fdObj, fd);</span>

<span class="fc" id="L493">    return using(fdObj);</span>
  }

  private static void triggerInit() {
<span class="fc bfc" id="L497" title="All 2 branches covered.">    for (AFAddressFamily&lt;?&gt; family : new AFAddressFamily&lt;?&gt;[] {</span>
<span class="fc" id="L498">        AFUNIXSocketAddress.addressFamily(), //</span>
<span class="fc" id="L499">        AFTIPCSocketAddress.addressFamily(), //</span>
<span class="fc" id="L500">        AFVSOCKSocketAddress.addressFamily(), //</span>
<span class="fc" id="L501">        AFSYSTEMSocketAddress.addressFamily(), //</span>
    }) {
<span class="fc" id="L503">      Objects.requireNonNull(family.getClass()); // trigger init</span>
    }
<span class="fc" id="L505">  }</span>

  /**
   * Registers the given port number as the &quot;local port&quot; for this file descriptor.
   *
   * Important: This only changes the state of this instance. The actual file descriptor is not
   * affected.
   *
   * @param port The port to assign to (must be &amp;gt;= 0).
   * @return This instance.
   */
  public FileDescriptorCast withLocalPort(int port) {
<span class="pc bpc" id="L517" title="1 of 2 branches missed.">    if (port &lt; 0) {</span>
<span class="nc" id="L518">      throw new IllegalArgumentException();</span>
    }
<span class="fc" id="L520">    this.localPort = port;</span>
<span class="fc" id="L521">    return this;</span>
  }

  /**
   * Registers the given port number as the &quot;remote port&quot; for this file descriptor.
   *
   * Important: This only changes the state of this instance. The actual file descriptor is not
   * affected.
   *
   * @param port The port to assign to (must be &amp;gt;= 0).
   * @return This instance.
   */
  public FileDescriptorCast withRemotePort(int port) {
<span class="pc bpc" id="L534" title="1 of 2 branches missed.">    if (port &lt; 0) {</span>
<span class="nc" id="L535">      throw new IllegalArgumentException();</span>
    }
<span class="fc" id="L537">    this.remotePort = port;</span>
<span class="fc" id="L538">    return this;</span>
  }

  /**
   * Casts this instance to the desired type.
   *
   * @param &lt;K&gt; The desired type.
   * @param desiredType The class of the desired type.
   * @return s An instance of the desired type.
   * @throws IOException if there was a problem while casting.
   * @throws ClassCastException if the cast cannot be legally made.
   * @see #availableTypes()
   * @see #isAvailable(Class)
   */
  @SuppressWarnings(&quot;PMD.ShortMethodName&quot;)
  public @NonNull &lt;K&gt; K as(Class&lt;K&gt; desiredType) throws IOException {
<span class="fc" id="L554">    Objects.requireNonNull(desiredType);</span>

<span class="fc" id="L556">    CastingProvider&lt;? extends K&gt; provider = cpm.get(desiredType);</span>
<span class="fc bfc" id="L557" title="All 2 branches covered.">    if (provider != null) {</span>
<span class="fc" id="L558">      K obj = desiredType.cast(provider.provideAs(this, desiredType));</span>
<span class="fc" id="L559">      Objects.requireNonNull(obj);</span>
<span class="fc" id="L560">      return obj;</span>
    } else {
<span class="fc" id="L562">      throw new ClassCastException(&quot;Cannot access file descriptor as &quot; + desiredType);</span>
    }
  }

  /**
   * Checks if the instance can be cast as the given desired type (using {@link #as(Class)}).
   *
   * @param desiredType The class of the desired type.
   * @return {@code true} if the cast can be made.
   * @throws IOException on error.
   * @see #as(Class)
   */
  public boolean isAvailable(Class&lt;?&gt; desiredType) throws IOException {
<span class="fc" id="L575">    return cpm.providers.containsKey(desiredType);</span>
  }

  /**
   * Returns a collection of available types this instance can be cast to (using
   * {@link #as(Class)}).
   *
   * @return The collection of available types.
   */
  public Set&lt;Class&lt;?&gt;&gt; availableTypes() {
<span class="fc" id="L585">    return cpm.classes;</span>
  }

  @Override
  @SuppressFBWarnings(&quot;EI_EXPOSE_REP&quot;)
  public FileDescriptor getFileDescriptor() {
<span class="fc" id="L591">    return fdObj;</span>
  }

  private static final class LenientFileInputStream extends FileInputStream {
    private LenientFileInputStream(FileDescriptor fdObj) {
<span class="nc" id="L596">      super(fdObj);</span>
<span class="nc" id="L597">    }</span>

    @Override
    public int available() throws IOException {
      try {
<span class="nc" id="L602">        return super.available();</span>
<span class="nc" id="L603">      } catch (IOException e) {</span>
<span class="nc" id="L604">        String msg = e.getMessage();</span>
<span class="nc bnc" id="L605" title="All 2 branches missed.">        if (&quot;Invalid seek&quot;.equals(msg)) {</span>
          // OSv may not like FileInputStream#availabe() on pipe fds.
<span class="nc" id="L607">          return 0;</span>
        }
<span class="nc" id="L609">        throw e;</span>
      }
    }
  }

  /**
   * Add support for otherwise unsupported sockets.
   */
  private static void registerGenericSocketSupport() {
<span class="fc" id="L618">    registerCastingProviders(Socket.class, new CastingProviderMap() {</span>

      @Override
      protected void addProviders() {
<span class="fc" id="L622">        addProviders(GLOBAL_PROVIDERS);</span>

<span class="fc" id="L624">        registerGenericSocketProviders();</span>
<span class="fc" id="L625">      }</span>
    });

<span class="fc" id="L628">    registerCastingProviders(DatagramSocket.class, new CastingProviderMap() {</span>
      @Override
      protected void addProviders() {
<span class="fc" id="L631">        addProviders(GLOBAL_PROVIDERS);</span>

<span class="fc" id="L633">        registerGenericDatagramSocketProviders();</span>
<span class="fc" id="L634">      }</span>
    });
<span class="fc" id="L636">  }</span>

  @SuppressWarnings(&quot;null&quot;)
  private static &lt;S extends AFSocket&lt;?&gt;&gt; S reconfigure(boolean isChannel, S socket)
      throws IOException {
<span class="fc" id="L641">    reconfigure(isChannel, socket.getChannel());</span>
<span class="fc" id="L642">    socket.getAFImpl().getCore().disableCleanFd();</span>
<span class="fc" id="L643">    return socket;</span>
  }

  @SuppressWarnings(&quot;null&quot;)
  private static &lt;S extends AFServerSocket&lt;?&gt;&gt; S reconfigure(boolean isChannel, S socket)
      throws IOException {
<span class="fc" id="L649">    reconfigure(isChannel, socket.getChannel());</span>
<span class="fc" id="L650">    socket.getAFImpl().getCore().disableCleanFd();</span>
<span class="fc" id="L651">    return socket;</span>
  }

  @SuppressWarnings(&quot;null&quot;)
  private static &lt;S extends AFDatagramSocket&lt;?&gt;&gt; S reconfigure(boolean isChannel, S socket)
      throws IOException {
<span class="fc" id="L657">    reconfigure(isChannel, socket.getChannel());</span>
<span class="fc" id="L658">    socket.getAFImpl().getCore().disableCleanFd();</span>
<span class="fc" id="L659">    return socket;</span>
  }

  /**
   * Reconfigures the Java-side of the socket/socket channel such that its state is compatible with
   * the native socket's state. This is necessary to properly configure blocking/non-blocking state,
   * as that is cached on the Java side.
   * &lt;p&gt;
   * If {@code isChannel} is false, then we want to cast to a {@link Socket}, {@link DatagramSocket}
   * or {@link ServerSocket}, which means blocking I/O is desired. If the underlying native socket
   * is configured non-blocking, we need to reset the state to &quot;blocking&quot; accordingly.
   * &lt;p&gt;
   * If {@code isChannel} is true, then we want to cast to a {@link SocketChannel},
   * {@link DatagramChannel} or {@link ServerSocketChannel}, in which case the blocking state should
   * be preserved, if possible. It is then up to the user to check blocking state via
   * {@link AbstractSelectableChannel#isBlocking()} prior to using the socket.
   * &lt;p&gt;
   * Note that on Windows, it may be impossible to query the blocking state from an external socket,
   * so the state is always forcibly set to &quot;blocking&quot;.
   *
   * @param &lt;S&gt; The type.
   * @param isChannel The desired cast type (socket=set to blocking, or channel=preserve state).
   * @param socketChannel The channel.
   * @throws IOException on error.
   */
  private static &lt;@NonNull S extends AFSomeSocketChannel&gt; void reconfigure(boolean isChannel,
      S socketChannel) throws IOException {
<span class="fc bfc" id="L686" title="All 2 branches covered.">    if (isChannel) {</span>
<span class="fc" id="L687">      reconfigureKeepBlockingState(socketChannel);</span>
    } else {
<span class="fc" id="L689">      reconfigureSetBlocking(socketChannel);</span>
    }
<span class="fc" id="L691">  }</span>

  private static &lt;@NonNull S extends AFSomeSocketChannel&gt; void reconfigureKeepBlockingState(
      S socketChannel) throws IOException {
<span class="fc" id="L695">    int result = NativeUnixSocket.checkBlocking(socketChannel.getFileDescriptor());</span>

    boolean blocking;
<span class="pc bpc" id="L698" title="3 of 4 branches missed.">    switch (result) {</span>
      case 0:
<span class="nc" id="L700">        blocking = false;</span>
<span class="nc" id="L701">        break;</span>
      case 1:
<span class="fc" id="L703">        blocking = true;</span>
<span class="fc" id="L704">        break;</span>
      case 2:
        // need to reconfigure/forcibly override any cached result -&gt; set to blocking by default
<span class="nc" id="L707">        socketChannel.configureBlocking(false);</span>
<span class="nc" id="L708">        socketChannel.configureBlocking(true);</span>
<span class="nc" id="L709">        return;</span>
      default:
<span class="nc" id="L711">        throw new OperationNotSupportedSocketException(&quot;Invalid blocking state&quot;);</span>
    }

<span class="fc" id="L714">    socketChannel.configureBlocking(blocking);</span>
<span class="fc" id="L715">  }</span>

  private static &lt;@NonNull S extends AFSomeSocketChannel&gt; void reconfigureSetBlocking(
      S socketChannel) throws IOException {
<span class="fc" id="L719">    int result = NativeUnixSocket.checkBlocking(socketChannel.getFileDescriptor());</span>

<span class="pc bpc" id="L721" title="3 of 4 branches missed.">    switch (result) {</span>
      case 0:
        // see below
<span class="nc" id="L724">        break;</span>
      case 1:
        // already blocking, nothing to do
<span class="fc" id="L727">        return;</span>
      case 2:
        // need to reconfigure/forcibly override any cached result -&gt; set to blocking by default
        // see below
<span class="nc" id="L731">        break;</span>
      default:
<span class="nc" id="L733">        throw new OperationNotSupportedSocketException(&quot;Invalid blocking state&quot;);</span>
    }

<span class="nc" id="L736">    socketChannel.configureBlocking(false);</span>
<span class="nc" id="L737">    socketChannel.configureBlocking(true);</span>
<span class="nc" id="L738">  }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>