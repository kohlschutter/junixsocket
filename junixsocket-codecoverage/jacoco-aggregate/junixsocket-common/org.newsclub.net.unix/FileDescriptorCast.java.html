<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>FileDescriptorCast.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">junixsocket-codecoverage</a> &gt; <a href="../index.html" class="el_bundle">junixsocket-common</a> &gt; <a href="index.source.html" class="el_package">org.newsclub.net.unix</a> &gt; <span class="el_source">FileDescriptorCast.java</span></div><h1>FileDescriptorCast.java</h1><pre class="source lang-java linenums">/*
 * junixsocket
 *
 * Copyright 2009-2023 Christian Kohlschütter
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.newsclub.net.unix;

import java.io.FileDescriptor;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.lang.ProcessBuilder.Redirect;
import java.net.Socket;
import java.nio.channels.FileChannel;
import java.nio.channels.ReadableByteChannel;
import java.nio.channels.WritableByteChannel;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;
import java.util.Objects;
import java.util.Set;

import org.eclipse.jdt.annotation.NonNull;

import com.kohlschutter.annotations.compiletime.SuppressFBWarnings;

/**
 * Provides object-oriented access to file descriptors via {@link InputStream}, {@link Socket},
 * etc., depending on the file descriptor type.
 * &lt;p&gt;
 * Typical usage:
 * &lt;/p&gt;
 * &lt;pre&gt;&lt;code&gt;
 * FileDescriptor fd;
 *
 * // succeeds if fd refers to an AF_UNIX stream socket
 * AFUNIXSocket socket = FileDescriptorCast.using(fd).as(AFUNIXSocket.class);
 *
 * // succeeds if fd refers to an AF_UNIX datagram socket
 * AFUNIXDatagramChannel channel = FileDescriptorCast.using(fd).as(AFUNIXDatagramChannel.class);
 *
 * // always succeeds
 * InputStream in = FileDescriptorCast.using(fd).as(InputStream.class);
 * OutputStream in = FileDescriptorCast.using(fd).as(OutputStream.class);
 * &lt;/code&gt;&lt;/pre&gt;
 * &lt;p&gt;
 * IMPORTANT: On some platforms (e.g., Solaris, Illumos) you may need to re-apply a read timeout
 * (e.g., using {@link Socket#setSoTimeout(int)}) after obtaining the socket.
 * &lt;/p&gt;
 * &lt;p&gt;
 * Note that you may also lose Java port information for {@link AFSocketAddress} implementations
 * that do not encode this information directly (such as {@link AFUNIXSocketAddress} and
 * {@link AFTIPCSocketAddress}).
 * &lt;/p&gt;
 *
 * @author Christian Kohlschütter
 */
public final class FileDescriptorCast implements FileDescriptorAccess {
<span class="fc" id="L72">  private static final Map&lt;Class&lt;?&gt;, CastingProviderMap&gt; PRIMARY_TYPE_PROVIDERS_MAP = Collections</span>
<span class="fc" id="L73">      .synchronizedMap(new HashMap&lt;&gt;());</span>

  private static final AFFunction&lt;FileDescriptor, FileInputStream&gt; FD_IS_PROVIDER = System
<span class="pc bpc" id="L76" title="1 of 2 branches missed.">      .getProperty(&quot;osv.version&quot;) != null ? LenientFileInputStream::new : FileInputStream::new;</span>

<span class="fc" id="L78">  private static final CastingProviderMap GLOBAL_PROVIDERS_FINAL = new CastingProviderMap() {</span>

    @Override
    protected void addProviders() {
      // FileDescriptor and Object cannot be overridden
<span class="fc" id="L83">      addProvider(FileDescriptor.class, new CastingProvider&lt;FileDescriptor&gt;() {</span>
        @Override
        public FileDescriptor provideAs(FileDescriptorCast fdc,
            Class&lt;? super FileDescriptor&gt; desiredType) throws IOException {
<span class="fc" id="L87">          return fdc.getFileDescriptor();</span>
        }
      });
<span class="fc" id="L90">    }</span>
  };

<span class="fc" id="L93">  private static final CastingProviderMap GLOBAL_PROVIDERS = new CastingProviderMap() {</span>
    @Override
    protected void addProviders() {
<span class="fc" id="L96">      addProvider(WritableByteChannel.class, new CastingProvider&lt;WritableByteChannel&gt;() {</span>
        @SuppressWarnings(&quot;resource&quot;)
        @Override
        public WritableByteChannel provideAs(FileDescriptorCast fdc,
            Class&lt;? super WritableByteChannel&gt; desiredType) throws IOException {
<span class="nc" id="L101">          return new FileOutputStream(fdc.getFileDescriptor()).getChannel();</span>
        }
      });
<span class="fc" id="L104">      addProvider(ReadableByteChannel.class, new CastingProvider&lt;ReadableByteChannel&gt;() {</span>
        @Override
        public ReadableByteChannel provideAs(FileDescriptorCast fdc,
            Class&lt;? super ReadableByteChannel&gt; desiredType) throws IOException {
<span class="nc" id="L108">          return FD_IS_PROVIDER.apply(fdc.getFileDescriptor()).getChannel();</span>
        }
      });

<span class="fc" id="L112">      addProvider(FileChannel.class, new CastingProvider&lt;FileChannel&gt;() {</span>
        @Override
        public FileChannel provideAs(FileDescriptorCast fdc, Class&lt;? super FileChannel&gt; desiredType)
            throws IOException {
<span class="fc" id="L116">          return RAFChannelProvider.getFileChannel(fdc.getFileDescriptor());</span>
        }
      });

<span class="fc" id="L120">      addProvider(FileOutputStream.class, new CastingProvider&lt;FileOutputStream&gt;() {</span>
        @Override
        public FileOutputStream provideAs(FileDescriptorCast fdc,
            Class&lt;? super FileOutputStream&gt; desiredType) throws IOException {
<span class="fc" id="L124">          return new FileOutputStream(fdc.getFileDescriptor());</span>
        }
      });
<span class="fc" id="L127">      addProvider(FileInputStream.class, new CastingProvider&lt;FileInputStream&gt;() {</span>
        @Override
        public FileInputStream provideAs(FileDescriptorCast fdc,
            Class&lt;? super FileInputStream&gt; desiredType) throws IOException {
<span class="fc" id="L131">          return FD_IS_PROVIDER.apply(fdc.getFileDescriptor());</span>
        }
      });
<span class="fc" id="L134">      addProvider(FileDescriptor.class, new CastingProvider&lt;FileDescriptor&gt;() {</span>
        @Override
        public FileDescriptor provideAs(FileDescriptorCast fdc,
            Class&lt;? super FileDescriptor&gt; desiredType) throws IOException {
<span class="nc" id="L138">          return fdc.getFileDescriptor();</span>
        }
      });
<span class="fc" id="L141">      addProvider(Integer.class, new CastingProvider&lt;Integer&gt;() {</span>
        @Override
        public Integer provideAs(FileDescriptorCast fdc, Class&lt;? super Integer&gt; desiredType)
            throws IOException {
<span class="fc" id="L145">          FileDescriptor fd = fdc.getFileDescriptor();</span>
<span class="pc bpc" id="L146" title="1 of 2 branches missed.">          int val = fd.valid() ? NativeUnixSocket.getFD(fd) : -1;</span>
<span class="pc bpc" id="L147" title="1 of 2 branches missed.">          if (val == -1) {</span>
<span class="nc" id="L148">            throw new IOException(&quot;Not a valid file descriptor&quot;);</span>
          }
<span class="fc" id="L150">          return val;</span>
        }
      });

<span class="pc bpc" id="L154" title="1 of 2 branches missed.">      if (AFSocket.supports(AFSocketCapability.CAPABILITY_FD_AS_REDIRECT)) {</span>
<span class="fc" id="L155">        addProvider(Redirect.class, new CastingProvider&lt;Redirect&gt;() {</span>
          @Override
          public Redirect provideAs(FileDescriptorCast fdc, Class&lt;? super Redirect&gt; desiredType)
              throws IOException {

<span class="fc" id="L160">            Redirect red = NativeUnixSocket.initRedirect(fdc.getFileDescriptor());</span>
<span class="pc bpc" id="L161" title="1 of 2 branches missed.">            if (red == null) {</span>
<span class="nc" id="L162">              throw new ClassCastException(&quot;Cannot access file descriptor as &quot; + desiredType);</span>
            }
<span class="fc" id="L164">            return red;</span>
          }
        });
      }
<span class="fc" id="L168">    }</span>
  };

<span class="fc" id="L171">  private static final int FD_IN = getFdIfPossible(FileDescriptor.in);</span>
<span class="fc" id="L172">  private static final int FD_OUT = getFdIfPossible(FileDescriptor.out);</span>
<span class="fc" id="L173">  private static final int FD_ERR = getFdIfPossible(FileDescriptor.err);</span>

  private final FileDescriptor fdObj;

<span class="fc" id="L177">  private int localPort = 0;</span>
<span class="fc" id="L178">  private int remotePort = 0;</span>

  private final CastingProviderMap cpm;

<span class="fc" id="L182">  private FileDescriptorCast(FileDescriptor fdObj, CastingProviderMap cpm) {</span>
<span class="fc" id="L183">    this.fdObj = Objects.requireNonNull(fdObj);</span>
<span class="fc" id="L184">    this.cpm = Objects.requireNonNull(cpm);</span>
<span class="fc" id="L185">  }</span>

  private static int getFdIfPossible(FileDescriptor fd) {
<span class="pc bpc" id="L188" title="1 of 2 branches missed.">    if (!NativeUnixSocket.isLoaded()) {</span>
<span class="nc" id="L189">      return -1;</span>
    }
    try {
<span class="pc bpc" id="L192" title="1 of 2 branches missed.">      if (!fd.valid()) {</span>
<span class="nc" id="L193">        return -1;</span>
      }
<span class="fc" id="L195">      return NativeUnixSocket.getFD(fd);</span>
<span class="nc" id="L196">    } catch (IOException e) {</span>
<span class="nc" id="L197">      return -1;</span>
    }
  }

  private static void registerCastingProviders(Class&lt;?&gt; primaryType, CastingProviderMap cpm) {
<span class="fc" id="L202">    Objects.requireNonNull(primaryType);</span>
    CastingProviderMap prev;
<span class="pc bpc" id="L204" title="1 of 2 branches missed.">    if ((prev = PRIMARY_TYPE_PROVIDERS_MAP.put(primaryType, cpm)) != null) {</span>
<span class="nc" id="L205">      PRIMARY_TYPE_PROVIDERS_MAP.put(primaryType, prev);</span>
<span class="nc" id="L206">      throw new IllegalStateException(&quot;Already registered: &quot; + primaryType);</span>
    }
<span class="fc" id="L208">  }</span>

  static &lt;A extends AFSocketAddress&gt; void registerCastingProviders(
      AFAddressFamilyConfig&lt;A&gt; config) {
<span class="fc" id="L212">    Class&lt;? extends AFSocket&lt;A&gt;&gt; socketClass = config.socketClass();</span>
<span class="fc" id="L213">    Class&lt;? extends AFDatagramSocket&lt;A&gt;&gt; datagramSocketClass = config.datagramSocketClass();</span>

<span class="fc" id="L215">    registerCastingProviders(socketClass, new CastingProviderMap() {</span>

      @SuppressWarnings(&quot;null&quot;)
      @Override
      protected void addProviders() {
<span class="fc" id="L220">        addProviders(GLOBAL_PROVIDERS);</span>

<span class="fc" id="L222">        final CastingProvider&lt;AFSocket&lt;A&gt;&gt; cpSocket = (fdc, desiredType) -&gt; AFSocket.newInstance(</span>
<span class="fc" id="L223">            config.socketConstructor(), (AFSocketFactory&lt;A&gt;) null, fdc.getFileDescriptor(),</span>
            fdc.localPort, fdc.remotePort);
<span class="fc" id="L225">        final CastingProvider&lt;AFServerSocket&lt;A&gt;&gt; cpServerSocket = (fdc,</span>
<span class="fc" id="L226">            desiredType) -&gt; AFServerSocket.newInstance(config.serverSocketConstructor(), fdc</span>
<span class="fc" id="L227">                .getFileDescriptor(), fdc.localPort, fdc.remotePort);</span>

<span class="fc" id="L229">        addProvider(socketClass, cpSocket);</span>
<span class="fc" id="L230">        addProvider(config.serverSocketClass(), cpServerSocket);</span>

<span class="fc" id="L232">        addProvider(config.socketChannelClass(), (fdc, desiredType) -&gt; cpSocket.provideAs(fdc,</span>
<span class="fc" id="L233">            AFSocket.class).getChannel());</span>
<span class="fc" id="L234">        addProvider(config.serverSocketChannelClass(), (fdc, desiredType) -&gt; cpServerSocket</span>
<span class="nc" id="L235">            .provideAs(fdc, AFServerSocket.class).getChannel());</span>
<span class="fc" id="L236">      }</span>
    });

<span class="fc" id="L239">    registerCastingProviders(datagramSocketClass, new CastingProviderMap() {</span>

      @SuppressWarnings(&quot;null&quot;)
      @Override
      protected void addProviders() {
<span class="fc" id="L244">        addProviders(GLOBAL_PROVIDERS);</span>

<span class="fc" id="L246">        final CastingProvider&lt;AFDatagramSocket&lt;A&gt;&gt; cpDatagramSocket = (fdc,</span>
<span class="fc" id="L247">            desiredType) -&gt; AFDatagramSocket.newInstance(config.datagramSocketConstructor(), fdc</span>
<span class="fc" id="L248">                .getFileDescriptor(), fdc.localPort, fdc.remotePort);</span>

<span class="fc" id="L250">        addProvider(datagramSocketClass, cpDatagramSocket);</span>

<span class="fc" id="L252">        addProvider(config.datagramChannelClass(), (fdc, desiredType) -&gt; cpDatagramSocket.provideAs(</span>
<span class="fc" id="L253">            fdc, AFDatagramSocket.class).getChannel());</span>
<span class="fc" id="L254">      }</span>
    });
<span class="fc" id="L256">  }</span>

  private abstract static class CastingProviderMap {
<span class="fc" id="L259">    private final Map&lt;Class&lt;?&gt;, CastingProvider&lt;?&gt;&gt; providers = new HashMap&lt;&gt;();</span>
<span class="fc" id="L260">    private final Set&lt;Class&lt;?&gt;&gt; classes = Collections.unmodifiableSet(providers.keySet());</span>

    @SuppressWarnings(&quot;PMD.ConstructorCallsOverridableMethod&quot;)
<span class="fc" id="L263">    protected CastingProviderMap() {</span>
<span class="fc" id="L264">      addProviders();</span>

<span class="fc" id="L266">      addProviders(GLOBAL_PROVIDERS_FINAL);</span>
<span class="fc" id="L267">    }</span>

    protected abstract void addProviders();

    protected final &lt;T&gt; void addProvider(Class&lt;T&gt; type, CastingProvider&lt;?&gt; cp) {
<span class="fc" id="L272">      Objects.requireNonNull(type);</span>

<span class="fc" id="L274">      addProvider0(type, cp);</span>
<span class="fc" id="L275">    }</span>

    private void addProvider0(Class&lt;?&gt; type, CastingProvider&lt;?&gt; cp) {
<span class="fc bfc" id="L278" title="All 2 branches covered.">      if (providers.put(type, cp) != cp) { // NOPMD</span>
<span class="fc bfc" id="L279" title="All 2 branches covered.">        for (Class&lt;?&gt; cl : type.getInterfaces()) {</span>
<span class="fc" id="L280">          addProvider0(cl, cp);</span>
        }
<span class="fc" id="L282">        Class&lt;?&gt; scl = type.getSuperclass();</span>
<span class="fc bfc" id="L283" title="All 2 branches covered.">        if (scl != null) {</span>
<span class="fc" id="L284">          addProvider0(scl, cp);</span>
        }
      }
<span class="fc" id="L287">    }</span>

    protected final void addProviders(CastingProviderMap other) {
<span class="pc bpc" id="L290" title="1 of 4 branches missed.">      if (other == null || other == this) { // NOPMD</span>
<span class="fc" id="L291">        return;</span>
      }
<span class="fc" id="L293">      this.providers.putAll(other.providers);</span>
<span class="fc" id="L294">    }</span>

    @SuppressWarnings(&quot;unchecked&quot;)
    public &lt;T&gt; CastingProvider&lt;? extends T&gt; get(Class&lt;T&gt; desiredType) {
<span class="fc" id="L298">      return (CastingProvider&lt;? extends T&gt;) providers.get(desiredType);</span>
    }
  }

  @FunctionalInterface
  private interface CastingProvider&lt;T&gt; {
    T provideAs(FileDescriptorCast fdc, Class&lt;? super T&gt; desiredType) throws IOException;
  }

  /**
   * Creates a {@link FileDescriptorCast} using the given file descriptor.
   *
   * @param fdObj The file descriptor.
   * @return The {@link FileDescriptorCast} instance.
   * @throws IOException on error, especially if the given file descriptor is invalid or
   *           unsupported.
   */
  public static FileDescriptorCast using(FileDescriptor fdObj) throws IOException {
<span class="fc bfc" id="L316" title="All 2 branches covered.">    if (!fdObj.valid()) {</span>
<span class="fc" id="L317">      throw new IOException(&quot;Not a valid file descriptor&quot;);</span>
    }
<span class="pc bpc" id="L319" title="1 of 2 branches missed.">    Class&lt;?&gt; primaryType = NativeUnixSocket.isLoaded() ? NativeUnixSocket.primaryType(fdObj) : null;</span>
<span class="fc bfc" id="L320" title="All 2 branches covered.">    if (primaryType == null) {</span>
<span class="fc" id="L321">      primaryType = FileDescriptor.class;</span>
    }

<span class="fc" id="L324">    triggerInit();</span>

<span class="fc" id="L326">    CastingProviderMap map = PRIMARY_TYPE_PROVIDERS_MAP.get(primaryType);</span>
<span class="fc bfc" id="L327" title="All 2 branches covered.">    return new FileDescriptorCast(fdObj, map == null ? GLOBAL_PROVIDERS : map);</span>
  }

  /**
   * Creates a {@link FileDescriptorCast} using the given native file descriptor value.
   * &lt;p&gt;
   * This method is inherently unsafe as it may
   * &lt;ol&gt;
   * &lt;li&gt;make assumptions on the internal system representation of a file descriptor (which differs
   * between Windows and Unix, for example).&lt;/li&gt;
   * &lt;li&gt;provide access to resources that are otherwise not accessible&lt;/li&gt;
   * &lt;/ol&gt;
   * &lt;p&gt;
   * Note that attempts are made to reuse {@link FileDescriptor#in}, {@link FileDescriptor#out}, and
   * {@link FileDescriptor#err}, respectively.
   *
   * @param fd The system-native file descriptor value.
   * @return The {@link FileDescriptorCast} instance.
   * @throws IOException on error, especially if the given file descriptor is invalid or
   *           unsupported, or when &quot;unsafe&quot; operations are unavailable or manually disabled for the
   *           current environment.
   */
  @Unsafe
  public static FileDescriptorCast unsafeUsing(int fd) throws IOException {
<span class="fc" id="L351">    AFSocket.ensureUnsafeSupported();</span>

    FileDescriptor fdObj;
<span class="fc bfc" id="L354" title="All 2 branches covered.">    if (fd == -1) {</span>
<span class="fc" id="L355">      throw new IOException(&quot;Not a valid file descriptor&quot;);</span>
<span class="pc bpc" id="L356" title="1 of 2 branches missed.">    } else if (fd == FD_IN) {</span>
<span class="nc" id="L357">      fdObj = FileDescriptor.in;</span>
<span class="fc bfc" id="L358" title="All 2 branches covered.">    } else if (fd == FD_OUT) {</span>
<span class="fc" id="L359">      fdObj = FileDescriptor.out;</span>
<span class="pc bpc" id="L360" title="1 of 2 branches missed.">    } else if (fd == FD_ERR) {</span>
<span class="nc" id="L361">      fdObj = FileDescriptor.err;</span>
    } else {
<span class="fc" id="L363">      fdObj = null;</span>
    }

<span class="fc bfc" id="L366" title="All 2 branches covered.">    if (fdObj != null) {</span>
<span class="fc" id="L367">      int check = getFdIfPossible(fdObj);</span>
<span class="pc bpc" id="L368" title="1 of 2 branches missed.">      if (fd == check) {</span>
<span class="fc" id="L369">        return using(fdObj);</span>
      }
    }

<span class="fc" id="L373">    fdObj = new FileDescriptor();</span>
<span class="fc" id="L374">    NativeUnixSocket.initFD(fdObj, fd);</span>

<span class="fc" id="L376">    return using(fdObj);</span>
  }

  private static void triggerInit() {
<span class="fc bfc" id="L380" title="All 2 branches covered.">    for (AFAddressFamily&lt;?&gt; family : new AFAddressFamily&lt;?&gt;[] {</span>
<span class="fc" id="L381">        AFUNIXSocketAddress.addressFamily(), //</span>
<span class="fc" id="L382">        AFTIPCSocketAddress.addressFamily(), //</span>
<span class="fc" id="L383">        AFVSOCKSocketAddress.addressFamily(), //</span>
<span class="fc" id="L384">        AFSYSTEMSocketAddress.addressFamily(), //</span>
    }) {
<span class="fc" id="L386">      Objects.requireNonNull(family.getClass()); // trigger init</span>
    }
<span class="fc" id="L388">  }</span>

  /**
   * Registers the given port number as the &quot;local port&quot; for this file descriptor.
   *
   * Important: This only changes the state of this instance. The actual file descriptor is not
   * affected.
   *
   * @param port The port to assign to (must be &amp;gt;= 0).
   * @return This instance.
   */
  public FileDescriptorCast withLocalPort(int port) {
<span class="pc bpc" id="L400" title="1 of 2 branches missed.">    if (port &lt; 0) {</span>
<span class="nc" id="L401">      throw new IllegalArgumentException();</span>
    }
<span class="fc" id="L403">    this.localPort = port;</span>
<span class="fc" id="L404">    return this;</span>
  }

  /**
   * Registers the given port number as the &quot;remote port&quot; for this file descriptor.
   *
   * Important: This only changes the state of this instance. The actual file descriptor is not
   * affected.
   *
   * @param port The port to assign to (must be &amp;gt;= 0).
   * @return This instance.
   */
  public FileDescriptorCast withRemotePort(int port) {
<span class="pc bpc" id="L417" title="1 of 2 branches missed.">    if (port &lt; 0) {</span>
<span class="nc" id="L418">      throw new IllegalArgumentException();</span>
    }
<span class="fc" id="L420">    this.remotePort = port;</span>
<span class="fc" id="L421">    return this;</span>
  }

  /**
   * Casts this instance to the desired type.
   *
   * @param &lt;K&gt; The desired type.
   * @param desiredType The class of the desired type.
   * @return s An instance of the desired type.
   * @throws IOException if there was a problem while casting.
   * @throws ClassCastException if the cast cannot be legally made.
   * @see #availableTypes()
   * @see #isAvailable(Class)
   */
  @SuppressWarnings(&quot;PMD.ShortMethodName&quot;)
  public @NonNull &lt;K&gt; K as(Class&lt;K&gt; desiredType) throws IOException {
<span class="fc" id="L437">    Objects.requireNonNull(desiredType);</span>

<span class="fc" id="L439">    CastingProvider&lt;? extends K&gt; provider = cpm.get(desiredType);</span>
<span class="fc bfc" id="L440" title="All 2 branches covered.">    if (provider != null) {</span>
<span class="fc" id="L441">      K obj = desiredType.cast(provider.provideAs(this, desiredType));</span>
<span class="fc" id="L442">      Objects.requireNonNull(obj);</span>
<span class="fc" id="L443">      return obj;</span>
    } else {
<span class="fc" id="L445">      throw new ClassCastException(&quot;Cannot access file descriptor as &quot; + desiredType);</span>
    }
  }

  /**
   * Checks if the instance can be cast as the given desired type (using {@link #as(Class)}).
   *
   * @param desiredType The class of the desired type.
   * @return {@code true} if the cast can be made.
   * @throws IOException on error.
   * @see #as(Class)
   */
  public boolean isAvailable(Class&lt;?&gt; desiredType) throws IOException {
<span class="fc" id="L458">    return cpm.providers.containsKey(desiredType);</span>
  }

  /**
   * Returns a collection of available types this instance can be cast to (using
   * {@link #as(Class)}).
   *
   * @return The collection of available types.
   */
  public Set&lt;Class&lt;?&gt;&gt; availableTypes() {
<span class="fc" id="L468">    return cpm.classes;</span>
  }

  @Override
  @SuppressFBWarnings(&quot;EI_EXPOSE_REP&quot;)
  public FileDescriptor getFileDescriptor() {
<span class="fc" id="L474">    return fdObj;</span>
  }

  private static final class LenientFileInputStream extends FileInputStream {
    private LenientFileInputStream(FileDescriptor fdObj) {
<span class="nc" id="L479">      super(fdObj);</span>
<span class="nc" id="L480">    }</span>

    @Override
    public int available() throws IOException {
      try {
<span class="nc" id="L485">        return super.available();</span>
<span class="nc" id="L486">      } catch (IOException e) {</span>
<span class="nc" id="L487">        String msg = e.getMessage();</span>
<span class="nc bnc" id="L488" title="All 2 branches missed.">        if (&quot;Invalid seek&quot;.equals(msg)) {</span>
          // OSv may not like FileInputStream#availabe() on pipe fds.
<span class="nc" id="L490">          return 0;</span>
        }
<span class="nc" id="L492">        throw e;</span>
      }
    }
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.10.202304240956</span></div></body></html>