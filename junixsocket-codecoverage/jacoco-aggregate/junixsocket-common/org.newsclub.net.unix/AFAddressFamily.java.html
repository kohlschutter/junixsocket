<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>AFAddressFamily.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">junixsocket-codecoverage</a> &gt; <a href="../index.html" class="el_bundle">junixsocket-common</a> &gt; <a href="index.source.html" class="el_package">org.newsclub.net.unix</a> &gt; <span class="el_source">AFAddressFamily.java</span></div><h1>AFAddressFamily.java</h1><pre class="source lang-java linenums">/*
 * junixsocket
 *
 * Copyright 2009-2023 Christian Kohlschütter
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.newsclub.net.unix;

import java.io.IOException;
import java.lang.reflect.InvocationTargetException;
import java.net.SocketException;
import java.net.URI;
import java.nio.channels.ServerSocketChannel;
import java.nio.channels.SocketChannel;
import java.nio.channels.UnsupportedAddressTypeException;
import java.nio.channels.spi.SelectorProvider;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import java.util.concurrent.atomic.AtomicBoolean;

import org.eclipse.jdt.annotation.NonNull;
import org.eclipse.jdt.annotation.Nullable;
import org.newsclub.net.unix.AFSocketAddress.AFSocketAddressConstructor;

/**
 * Describes an address family supported by junixsocket.
 *
 * @param &lt;A&gt; The corresponding {@link AFSocketAddress} subclass.
 * @author Christian Kohlschütter
 */
public final class AFAddressFamily&lt;A extends AFSocketAddress&gt; {
<span class="fc" id="L47">  private static final Map&lt;String, AFAddressFamily&lt;?&gt;&gt; AF_MAP = Collections.synchronizedMap(</span>
      new HashMap&lt;&gt;());
<span class="fc" id="L49">  private static final Map&lt;String, AFAddressFamily&lt;?&gt;&gt; URI_SCHEMES = Collections.synchronizedMap(</span>
      new HashMap&lt;&gt;());
<span class="fc" id="L51">  private static final AtomicBoolean DEFERRED_INIT_DONE = new AtomicBoolean(false);</span>

  private final int domain;
  private AFSocketAddressConstructor&lt;A&gt; addressConstructor;
  private @Nullable Class&lt;A&gt; addressClass;
  private final String juxString;
  private final String juxInetAddressSuffix;
  private final String addressClassname;

  private String selectorProviderClassname;

  private AFSocket.Constructor&lt;A&gt; socketConstructor;
  private AFServerSocket.Constructor&lt;A&gt; serverSocketConstructor;
  private AFSocketAddressConfig&lt;A&gt; addressConfig;

<span class="fc" id="L66">  private SelectorProvider selectorProvider = null;</span>

  static {
<span class="fc" id="L69">    NativeUnixSocket.isLoaded(); // trigger init</span>
<span class="fc" id="L70">  }</span>

<span class="fc" id="L72">  private AFAddressFamily(String juxString, int domain, String addressClassname) {</span>
<span class="fc" id="L73">    this.juxString = juxString;</span>
<span class="fc" id="L74">    this.domain = domain; // FIXME validate</span>
<span class="fc" id="L75">    this.addressClassname = addressClassname;</span>
<span class="fc" id="L76">    this.juxInetAddressSuffix = &quot;.&quot; + juxString + AFInetAddress.INETADDR_SUFFIX;</span>
<span class="fc" id="L77">  }</span>

  @SuppressWarnings(&quot;unchecked&quot;)
  static synchronized &lt;A extends AFSocketAddress&gt; @NonNull AFAddressFamily&lt;A&gt; registerAddressFamily(
      String juxString, int domain, String addressClassname) {
<span class="fc" id="L82">    AFAddressFamily&lt;?&gt; af = AF_MAP.get(juxString);</span>
<span class="pc bpc" id="L83" title="1 of 2 branches missed.">    if (af != null) {</span>
<span class="nc bnc" id="L84" title="All 2 branches missed.">      if (af.getDomain() != domain) {</span>
<span class="nc" id="L85">        throw new IllegalStateException(&quot;Wrong domain for address family &quot; + juxString + &quot;: &quot; + af</span>
<span class="nc" id="L86">            .getDomain() + &quot; vs. &quot; + domain);</span>
      }
<span class="nc" id="L88">      return (AFAddressFamily&lt;A&gt;) af;</span>
    }

<span class="fc" id="L91">    af = new AFAddressFamily&lt;&gt;(juxString, domain, addressClassname);</span>
<span class="fc" id="L92">    AF_MAP.put(juxString, af);</span>

<span class="fc" id="L94">    return (AFAddressFamily&lt;A&gt;) af;</span>
  }

  static synchronized void triggerInit() {
<span class="fc bfc" id="L98" title="All 2 branches covered.">    for (AFAddressFamily&lt;?&gt; af : new HashSet&lt;&gt;(AF_MAP.values())) {</span>
<span class="pc bpc" id="L99" title="1 of 2 branches missed.">      if (af.addressClassname != null) {</span>
        try {
<span class="fc" id="L101">          Class&lt;?&gt; clz = Class.forName(af.addressClassname);</span>
<span class="fc" id="L102">          clz.getMethod(&quot;addressFamily&quot;).invoke(null);</span>
<span class="nc" id="L103">        } catch (Exception e) {</span>
          // ignore
<span class="fc" id="L105">        }</span>
      }
<span class="fc" id="L107">    }</span>
<span class="fc" id="L108">  }</span>

  static synchronized AFAddressFamily&lt;?&gt; getAddressFamily(String juxString) {
<span class="fc" id="L111">    return AF_MAP.get(juxString);</span>
  }

  static AFAddressFamily&lt;?&gt; getAddressFamily(URI uri) {
<span class="fc" id="L115">    checkDeferredInit();</span>
<span class="fc" id="L116">    Objects.requireNonNull(uri, &quot;uri&quot;);</span>
<span class="fc" id="L117">    String scheme = uri.getScheme();</span>
<span class="fc" id="L118">    return URI_SCHEMES.get(scheme);</span>
  }

  static void checkDeferredInit() {
<span class="fc bfc" id="L122" title="All 2 branches covered.">    if (DEFERRED_INIT_DONE.compareAndSet(false, true)) {</span>
<span class="fc" id="L123">      NativeUnixSocket.isLoaded();</span>
<span class="fc" id="L124">      AFAddressFamily.triggerInit();</span>
    }
<span class="fc" id="L126">  }</span>

  int getDomain() {
<span class="fc" id="L129">    return domain;</span>
  }

  String getJuxString() {
<span class="fc" id="L133">    return juxString;</span>
  }

  AFSocketAddressConstructor&lt;A&gt; getAddressConstructor() {
<span class="pc bpc" id="L137" title="1 of 2 branches missed.">    if (addressConstructor == null) {</span>
<span class="nc" id="L138">      throw new UnsupportedAddressTypeException();</span>
    }
<span class="fc" id="L140">    return addressConstructor;</span>
  }

  private synchronized void checkProvider() {
<span class="pc bpc" id="L144" title="1 of 4 branches missed.">    if (socketConstructor == null &amp;&amp; selectorProvider == null) {</span>
      try {
<span class="fc" id="L146">        getSelectorProvider();</span>
<span class="nc" id="L147">      } catch (IllegalStateException e) {</span>
        // ignore
<span class="fc" id="L149">      }</span>
    }
<span class="fc" id="L151">  }</span>

  AFSocket.Constructor&lt;A&gt; getSocketConstructor() {
<span class="fc" id="L154">    checkProvider();</span>
<span class="pc bpc" id="L155" title="1 of 2 branches missed.">    if (socketConstructor == null) {</span>
<span class="nc" id="L156">      throw new UnsupportedAddressTypeException();</span>
    }
<span class="fc" id="L158">    return socketConstructor;</span>
  }

  AFServerSocket.Constructor&lt;A&gt; getServerSocketConstructor() {
<span class="fc" id="L162">    checkProvider();</span>
<span class="pc bpc" id="L163" title="1 of 2 branches missed.">    if (serverSocketConstructor == null) {</span>
<span class="nc" id="L164">      throw new UnsupportedAddressTypeException();</span>
    }
<span class="fc" id="L166">    return serverSocketConstructor;</span>
  }

  Class&lt;A&gt; getSocketAddressClass() {
<span class="pc bpc" id="L170" title="1 of 2 branches missed.">    if (addressClass == null) {</span>
<span class="nc" id="L171">      throw new UnsupportedAddressTypeException();</span>
    }
<span class="fc" id="L173">    return addressClass;</span>
  }

  String getJuxInetAddressSuffix() {
<span class="fc" id="L177">    return juxInetAddressSuffix;</span>
  }

  /**
   * Registers an address family.
   *
   * @param &lt;A&gt; The supported address type.
   * @param juxString The sockaddr_* identifier as registered in native code.
   * @param addressClass The supported address subclass.
   * @param config The address-specific config object.
   * @return The corresponding {@link AFAddressFamily} instance.
   */
  @SuppressWarnings({&quot;unchecked&quot;, &quot;rawtypes&quot;})
  public static synchronized &lt;A extends AFSocketAddress&gt; AFAddressFamily&lt;A&gt; registerAddressFamily(
      String juxString, //
      Class&lt;A&gt; addressClass, AFSocketAddressConfig&lt;A&gt; config) {
<span class="fc" id="L193">    AFAddressFamily&lt;?&gt; af = getAddressFamily(juxString);</span>
<span class="pc bpc" id="L194" title="1 of 2 branches missed.">    if (af == null) {</span>
<span class="nc" id="L195">      throw new IllegalStateException(&quot;Address family not supported by native code: &quot; + juxString);</span>
    }
<span class="pc bpc" id="L197" title="2 of 4 branches missed.">    if (af.addressClassname != null &amp;&amp; !addressClass.getName().equals(af.addressClassname)) {</span>
<span class="nc" id="L198">      throw new IllegalStateException(&quot;Unexpected classname for address family &quot; + juxString + &quot;: &quot;</span>
<span class="nc" id="L199">          + addressClass.getName() + &quot;; expected: &quot; + af.addressClassname);</span>
    }
<span class="pc bpc" id="L201" title="2 of 4 branches missed.">    if (af.addressConstructor != null || af.addressClass != null) {</span>
<span class="nc" id="L202">      throw new IllegalStateException(&quot;Already registered: &quot; + juxString);</span>
    }
<span class="fc" id="L204">    af.addressConfig = (AFSocketAddressConfig) config;</span>
<span class="fc" id="L205">    af.addressConstructor = (AFSocketAddressConstructor) config.addressConstructor();</span>
<span class="fc" id="L206">    af.addressClass = (Class) addressClass;</span>
<span class="fc" id="L207">    synchronized (af) { // work-around for likely false positive Spotbugs error</span>
<span class="fc" id="L208">      af.selectorProviderClassname = config.selectorProviderClassname();</span>
<span class="fc" id="L209">    }</span>

<span class="fc bfc" id="L211" title="All 2 branches covered.">    for (String scheme : config.uriSchemes()) {</span>
<span class="pc bpc" id="L212" title="1 of 2 branches missed.">      if (scheme.isEmpty()) {</span>
<span class="nc" id="L213">        throw new IllegalStateException(&quot;Invalid URI scheme; cannot register &quot; + scheme + &quot; for &quot;</span>
            + juxString);

      }
<span class="pc bpc" id="L217" title="1 of 2 branches missed.">      if (URI_SCHEMES.containsKey(scheme)) {</span>
<span class="nc" id="L218">        throw new IllegalStateException(&quot;URI scheme already registered; cannot register &quot; + scheme</span>
            + &quot; for &quot; + juxString);
      }
<span class="fc" id="L221">      URI_SCHEMES.put(scheme, af);</span>
<span class="fc" id="L222">    }</span>

<span class="fc" id="L224">    return (AFAddressFamily&lt;A&gt;) af;</span>
  }

  /**
   * Registers an implementation.
   *
   * @param &lt;A&gt; The supported address type.
   * @param juxString The sockaddr_* identifier as registered in native code.
   * @param addressFamily The supported address family as registered via
   *          {@link #registerAddressFamily(String, Class, AFSocketAddressConfig)}.
   * @param config The address family-specific configuration object.
   * @return The corresponding {@link AFAddressFamily} instance.
   */
  @SuppressWarnings({&quot;unchecked&quot;, &quot;rawtypes&quot;, &quot;PMD.ExcessiveParameterList&quot;})
  public static synchronized &lt;A extends AFSocketAddress&gt; AFAddressFamily&lt;A&gt; registerAddressFamilyImpl(
      String juxString, //
      AFAddressFamily&lt;A&gt; addressFamily, //
      AFAddressFamilyConfig&lt;A&gt; config) {
<span class="fc" id="L242">    Objects.requireNonNull(addressFamily);</span>
<span class="fc" id="L243">    Objects.requireNonNull(config);</span>

<span class="fc" id="L245">    AFAddressFamily&lt;?&gt; af = getAddressFamily(juxString);</span>
<span class="pc bpc" id="L246" title="1 of 2 branches missed.">    if (af == null) {</span>
<span class="nc" id="L247">      throw new IllegalStateException(&quot;Unknown address family: &quot; + juxString);</span>
    }
<span class="pc bpc" id="L249" title="1 of 2 branches missed.">    if (addressFamily != af) { // NOPMD.CompareObjectsWithEquals</span>
<span class="nc" id="L250">      throw new IllegalStateException(&quot;Address family inconsistency: &quot; + juxString);</span>
    }
<span class="pc bpc" id="L252" title="1 of 2 branches missed.">    if (af.socketConstructor != null) {</span>
<span class="nc" id="L253">      throw new IllegalStateException(&quot;Already registered: &quot; + juxString);</span>
    }
<span class="fc" id="L255">    af.socketConstructor = (AFSocket.Constructor) config.socketConstructor();</span>
<span class="fc" id="L256">    af.serverSocketConstructor = (AFServerSocket.Constructor) config.serverSocketConstructor();</span>

<span class="fc" id="L258">    FileDescriptorCast.registerCastingProviders(config);</span>

<span class="fc" id="L260">    return (AFAddressFamily&lt;A&gt;) af;</span>
  }

  @SuppressWarnings(&quot;unchecked&quot;)
  AFSocketImplExtensions&lt;A&gt; initImplExtensions(AncillaryDataSupport ancillaryDataSupport) {
<span class="nc bnc" id="L265" title="All 4 branches missed.">    switch (getDomain()) {</span>
      case NativeUnixSocket.DOMAIN_TIPC:
<span class="nc" id="L267">        return (AFSocketImplExtensions&lt;A&gt;) new AFTIPCSocketImplExtensions(ancillaryDataSupport);</span>
      case NativeUnixSocket.DOMAIN_VSOCK:
<span class="nc" id="L269">        return (AFSocketImplExtensions&lt;A&gt;) new AFVSOCKSocketImplExtensions(ancillaryDataSupport);</span>
      case NativeUnixSocket.DOMAIN_SYSTEM:
<span class="nc" id="L271">        return (AFSocketImplExtensions&lt;A&gt;) new AFSYSTEMSocketImplExtensions(ancillaryDataSupport);</span>
      default:
<span class="nc" id="L273">        throw new UnsupportedOperationException();</span>
    }
  }

  /**
   * Creates a new, unconnected, unbound socket compatible with this socket address.
   *
   * @return The socket instance.
   * @throws IOException on error.
   */
  public AFSocket&lt;?&gt; newSocket() throws IOException {
    try {
<span class="fc" id="L285">      return getSocketConstructor().newInstance(null, null);</span>
<span class="nc" id="L286">    } catch (UnsupportedOperationException e) {</span>
<span class="nc" id="L287">      throw (SocketException) new SocketException().initCause(e);</span>
    }
  }

  /**
   * Creates a new, unconnected, unbound server socket compatible with this socket address.
   *
   * @return The server socket instance.
   * @throws IOException on error.
   */
  public AFServerSocket&lt;?&gt; newServerSocket() throws IOException {
    try {
<span class="fc" id="L299">      return getServerSocketConstructor().newInstance(null);</span>
<span class="nc" id="L300">    } catch (UnsupportedOperationException e) {</span>
<span class="nc" id="L301">      throw (SocketException) new SocketException().initCause(e);</span>
    }
  }

  /**
   * Creates a new, unconnected, unbound {@link SocketChannel} compatible with this socket address.
   *
   * @return The socket instance.
   * @throws IOException on error.
   */
  public AFSocketChannel&lt;?&gt; newSocketChannel() throws IOException {
<span class="fc" id="L312">    return newSocket().getChannel();</span>
  }

  /**
   * Creates a new, unconnected, unbound {@link ServerSocketChannel} compatible with this socket
   * address.
   *
   * @return The socket instance.
   * @throws IOException on error.
   */
  public AFServerSocketChannel&lt;?&gt; newServerSocketChannel() throws IOException {
<span class="fc" id="L323">    return newServerSocket().getChannel();</span>
  }

  AFSocketAddress parseURI(URI u, int overridePort) throws SocketException {
<span class="pc bpc" id="L327" title="1 of 2 branches missed.">    if (addressConfig == null) {</span>
<span class="nc" id="L328">      throw new SocketException(&quot;Cannot instantiate addresses of type &quot; + addressClass);</span>
    }
<span class="fc" id="L330">    return addressConfig.parseURI(u, overridePort);</span>
  }

  /**
   * Returns the set of supported URI schemes that can be parsed to some {@link AFSocketAddress}.
   *
   * The set is dependent on which {@link AFSocketAddress} implementations are registered with
   * junixsocket.
   *
   * @return The set of supported URI schemes.
   */
  public static synchronized Set&lt;String&gt; uriSchemes() {
<span class="fc" id="L342">    checkDeferredInit();</span>
<span class="fc" id="L343">    return Collections.unmodifiableSet(URI_SCHEMES.keySet());</span>
  }

  /**
   * Returns the {@link SelectorProvider} associated with this address family, or {@code null} if no
   * such instance is registered.
   *
   * @return The {@link SelectorProvider}.
   * @throws IllegalStateException on error.
   */
  public synchronized SelectorProvider getSelectorProvider() {
<span class="fc bfc" id="L354" title="All 2 branches covered.">    if (selectorProvider != null) {</span>
<span class="fc" id="L355">      return selectorProvider;</span>
    }
<span class="pc bpc" id="L357" title="1 of 2 branches missed.">    if (selectorProviderClassname == null) {</span>
<span class="nc" id="L358">      return null;</span>
    }
    try {
<span class="fc" id="L361">      selectorProvider = (SelectorProvider) Class.forName(selectorProviderClassname).getMethod(</span>
<span class="fc" id="L362">          &quot;provider&quot;, new Class&lt;?&gt;[0]).invoke(null);</span>
<span class="nc" id="L363">    } catch (IllegalAccessException | InvocationTargetException | NoSuchMethodException</span>
        | ClassNotFoundException | RuntimeException e) {
<span class="nc" id="L365">      throw new IllegalStateException(&quot;Cannot instantiate selector provider for &quot;</span>
          + addressClassname, e);
<span class="fc" id="L367">    }</span>
<span class="fc" id="L368">    return selectorProvider;</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.10.202304240956</span></div></body></html>