<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>HostAndPort.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">junixsocket-codecoverage</a> &gt; <a href="../index.html" class="el_bundle">junixsocket-common</a> &gt; <a href="index.source.html" class="el_package">org.newsclub.net.unix</a> &gt; <span class="el_source">HostAndPort.java</span></div><h1>HostAndPort.java</h1><pre class="source lang-java linenums">/*
 * junixsocket
 *
 * Copyright 2009-2023 Christian Kohlschütter
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.newsclub.net.unix;

import java.io.UnsupportedEncodingException;
import java.net.SocketException;
import java.net.URI;
import java.net.URLDecoder;
import java.net.URLEncoder;
import java.util.Objects;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * Hostname and port.
 *
 * @author Christian Kohlschütter
 */
public final class HostAndPort {
<span class="fc" id="L35">  private static final Pattern PAT_HOST_AND_PORT = Pattern.compile(</span>
      &quot;^//((?&lt;userinfo&gt;[^/\\@]*)\\@)?(?&lt;host&gt;[^/\\:]+)(?:\\:(?&lt;port&gt;[0-9]+))?&quot;);
  private final String hostname;
  private final int port;

  /**
   * Creates a new hostname and port combination.
   *
   * @param hostname The hostname.
   * @param port The port, or {@code -1} for &quot;no port&quot;.
   */
<span class="fc" id="L46">  public HostAndPort(String hostname, int port) {</span>
<span class="fc" id="L47">    this.hostname = hostname;</span>
<span class="fc" id="L48">    this.port = port;</span>
<span class="fc" id="L49">  }</span>

  @Override
  public int hashCode() {
<span class="fc" id="L53">    final int prime = 31;</span>
<span class="fc" id="L54">    int result = 1;</span>
<span class="pc bpc" id="L55" title="1 of 2 branches missed.">    result = prime * result + ((getHostname() == null) ? 0 : getHostname().hashCode());</span>
<span class="fc" id="L56">    result = prime * result + getPort();</span>
<span class="fc" id="L57">    return result;</span>
  }

  @Override
  public boolean equals(Object obj) {
<span class="nc bnc" id="L62" title="All 2 branches missed.">    if (this == obj) {</span>
<span class="nc" id="L63">      return true;</span>
    }
<span class="nc bnc" id="L65" title="All 2 branches missed.">    if (!(obj instanceof HostAndPort)) {</span>
<span class="nc" id="L66">      return false;</span>
    }
<span class="nc" id="L68">    HostAndPort other = (HostAndPort) obj;</span>
<span class="nc bnc" id="L69" title="All 2 branches missed.">    if (getHostname() == null) {</span>
<span class="nc bnc" id="L70" title="All 2 branches missed.">      if (other.getHostname() != null) {</span>
<span class="nc" id="L71">        return false;</span>
      }
<span class="nc bnc" id="L73" title="All 2 branches missed.">    } else if (!getHostname().equals(other.getHostname())) {</span>
<span class="nc" id="L74">      return false;</span>
    }

<span class="nc bnc" id="L77" title="All 2 branches missed.">    return getPort() == other.getPort();</span>
  }

  @Override
  public String toString() {
<span class="nc bnc" id="L82" title="All 2 branches missed.">    if (getPort() == -1) {</span>
<span class="nc" id="L83">      return getHostname();</span>
    } else {
<span class="nc" id="L85">      return getHostname() + &quot;:&quot; + getPort();</span>
    }
  }

  /**
   * Tries to extract hostname and port information from the given URI.
   *
   * @param u The URI to extract from.
   * @return The parsed {@link HostAndPort} instance.
   * @throws SocketException on error.
   */
  public static HostAndPort parseFrom(URI u) throws SocketException {
<span class="fc" id="L97">    String host = u.getHost();</span>
<span class="fc bfc" id="L98" title="All 2 branches covered.">    if (host != null) {</span>
<span class="fc" id="L99">      return new HostAndPort(host, u.getPort());</span>
    }
<span class="fc" id="L101">    String raw = u.getRawSchemeSpecificPart();</span>
<span class="fc" id="L102">    Matcher m = PAT_HOST_AND_PORT.matcher(raw);</span>
<span class="pc bpc" id="L103" title="1 of 2 branches missed.">    if (!m.find()) {</span>
<span class="nc" id="L104">      throw new SocketException(&quot;Cannot parse URI: &quot; + u);</span>
    }
    try {
<span class="fc" id="L107">      host = URLDecoder.decode(m.group(&quot;host&quot;), &quot;UTF-8&quot;);</span>
<span class="nc" id="L108">    } catch (UnsupportedEncodingException e) {</span>
<span class="nc" id="L109">      throw new IllegalStateException(e);</span>
<span class="fc" id="L110">    }</span>

<span class="fc" id="L112">    String portStr = m.group(&quot;port&quot;);</span>
    int port;
<span class="fc bfc" id="L114" title="All 2 branches covered.">    if (portStr == null) {</span>
<span class="fc" id="L115">      port = -1;</span>
    } else {
<span class="fc" id="L117">      port = Integer.parseInt(portStr);</span>
    }

<span class="fc" id="L120">    return new HostAndPort(host, port);</span>
  }

  private static String urlEncode(String s) {
    try {
<span class="fc" id="L125">      return URLEncoder.encode(s, &quot;UTF-8&quot;);</span>
<span class="nc" id="L126">    } catch (UnsupportedEncodingException e) {</span>
<span class="nc" id="L127">      throw new IllegalStateException(e);</span>
    }
  }

  /**
   * Returns the hostname.
   *
   * @return The hostname.
   */
  public String getHostname() {
<span class="fc" id="L137">    return hostname;</span>
  }

  /**
   * Returns the port, or {@code -1} for &quot;no port specified&quot;.
   *
   * @return The port.
   */
  public int getPort() {
<span class="fc" id="L146">    return port;</span>
  }

  /**
   * Returns a URI with this hostname and port.
   *
   * @param scheme The scheme to use.
   * @return The URI.
   */
  public URI toURI(String scheme) {
<span class="nc" id="L156">    return toURI(scheme, null, null, null, null);</span>
  }

  /**
   * Returns a URI with this hostname and port, potentially reusing other URI parameters from the
   * given template URI (authority, path, query, fragment).
   *
   * @param scheme The scheme to use.
   * @param template The template. or {@code null}.
   * @return The URI.
   */
  public URI toURI(String scheme, URI template) {
<span class="fc bfc" id="L168" title="All 2 branches covered.">    if (template == null) {</span>
<span class="fc" id="L169">      return toURI(scheme, null, null, null, null);</span>
    }

<span class="fc" id="L172">    String rawAuthority = template.getRawAuthority();</span>
<span class="fc" id="L173">    int at = rawAuthority.indexOf('@');</span>
<span class="fc bfc" id="L174" title="All 2 branches covered.">    if (at &gt;= 0) {</span>
<span class="fc" id="L175">      rawAuthority = rawAuthority.substring(0, at);</span>
<span class="pc bpc" id="L176" title="1 of 4 branches missed.">    } else if (rawAuthority.length() &gt; 0 &amp;&amp; template.getHost() == null) {</span>
      // encoded hostname was parsed as authority
<span class="fc" id="L178">      rawAuthority = null;</span>
<span class="pc bpc" id="L179" title="1 of 4 branches missed.">    } else if (rawAuthority.length() &gt; 0 &amp;&amp; template.getAuthority().equals(template.getHost())) {</span>
      // hostname was duplicated as authority
<span class="fc" id="L181">      rawAuthority = null;</span>
<span class="pc bpc" id="L182" title="2 of 4 branches missed.">    } else if (rawAuthority.length() &gt; 0 &amp;&amp; template.getAuthority().equals(template.getHost() + &quot;:&quot;</span>
<span class="fc" id="L183">        + template.getPort())) {</span>
      // hostname:port was duplicated as authority
<span class="fc" id="L185">      rawAuthority = null;</span>
    }

<span class="fc" id="L188">    return toURI(scheme, rawAuthority, template.getRawPath(), template.getRawQuery(), template</span>
<span class="fc" id="L189">        .getRawFragment());</span>
  }

  /**
   * Returns a URI with this hostname and port, potentially using other URI parameters from the
   * given set of parameters.
   *
   * @param scheme The scheme to use.
   * @param rawAuthority The raw authority field, or {@code null}.
   * @param rawPath The raw path field, or {@code null}.
   * @param rawQuery The raw query field, or {@code null}.
   * @param rawFragment The raw fragment field, or {@code null}.
   * @return The URI.
   */
  public URI toURI(String scheme, String rawAuthority, String rawPath, String rawQuery,
      String rawFragment) {
<span class="fc" id="L205">    Objects.requireNonNull(scheme);</span>
<span class="fc bfc" id="L206" title="All 4 branches covered.">    if (rawPath != null &amp;&amp; !rawPath.isEmpty()) {</span>
<span class="pc bpc" id="L207" title="1 of 2 branches missed.">      if (!rawPath.startsWith(&quot;/&quot;)) {</span>
<span class="nc" id="L208">        throw new IllegalArgumentException(&quot;Path must be absolute: &quot; + rawPath);</span>
      }
    }

<span class="fc bfc" id="L212" title="All 2 branches covered.">    return URI.create(scheme + &quot;://&quot; + (rawAuthority == null ? &quot;&quot; : rawAuthority + &quot;@&quot;) + urlEncode(</span>
<span class="fc bfc" id="L213" title="All 4 branches covered.">        getHostname()).replace(&quot;%2C&quot;, &quot;,&quot;) + (port &lt;= 0 ? &quot;&quot; : (&quot;:&quot; + port)) + (rawPath == null ? &quot;&quot;</span>
<span class="fc bfc" id="L214" title="All 4 branches covered.">            : rawPath) + (rawQuery == null ? &quot;&quot; : &quot;?&quot; + rawQuery) + (rawFragment == null ? &quot;&quot; : &quot;#&quot;</span>
<span class="fc" id="L215">                + rawFragment));</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>