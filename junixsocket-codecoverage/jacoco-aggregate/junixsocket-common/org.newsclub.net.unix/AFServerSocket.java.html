<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>AFServerSocket.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">junixsocket-codecoverage</a> &gt; <a href="../index.html" class="el_bundle">junixsocket-common</a> &gt; <a href="index.source.html" class="el_package">org.newsclub.net.unix</a> &gt; <span class="el_source">AFServerSocket.java</span></div><h1>AFServerSocket.java</h1><pre class="source lang-java linenums">/*
 * junixsocket
 *
 * Copyright 2009-2022 Christian Kohlschütter
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.newsclub.net.unix;

import java.io.Closeable;
import java.io.File;
import java.io.FileDescriptor;
import java.io.IOException;
import java.net.ServerSocket;
import java.net.SocketAddress;
import java.net.SocketException;
import java.nio.channels.IllegalBlockingModeException;
import java.util.concurrent.atomic.AtomicBoolean;

import org.eclipse.jdt.annotation.NonNull;
import org.eclipse.jdt.annotation.Nullable;

import com.kohlschutter.annotations.compiletime.SuppressFBWarnings;

/**
 * The server part of a junixsocket socket.
 * 
 * @param &lt;A&gt; The concrete {@link AFSocketAddress} that is supported by this type.
 * @author Christian Kohlschütter
 */
public abstract class AFServerSocket&lt;A extends AFSocketAddress&gt; extends ServerSocket implements
    FileDescriptorAccess {
  private final AFSocketImpl&lt;A&gt; implementation;
  private @Nullable A boundEndpoint;
<span class="fc" id="L45">  private final Closeables closeables = new Closeables();</span>
<span class="fc" id="L46">  private final AtomicBoolean created = new AtomicBoolean(false);</span>
<span class="fc" id="L47">  private final AtomicBoolean deleteOnClose = new AtomicBoolean(true);</span>
<span class="fc" id="L48">  private final AFServerSocketChannel&lt;?&gt; channel = newChannel();</span>
  private @Nullable SocketAddressFilter bindFilter;

  /**
   * The constructor of the concrete subclass.
   * 
   * @param &lt;A&gt; The concrete {@link AFSocketAddress} that is supported by this type.
   */
  public interface Constructor&lt;A extends AFSocketAddress&gt; {
    /**
     * Creates a new {@link AFServerSocket} instance.
     * 
     * @param fd The file descriptor.
     * @return The new instance.
     * @throws IOException on error.
     */
    @NonNull
    AFServerSocket&lt;A&gt; newInstance(FileDescriptor fd) throws IOException;
  }

  /**
   * Constructs a new, unconnected instance.
   * 
   * @throws IOException if the operation fails.
   */
  protected AFServerSocket() throws IOException {
<span class="nc" id="L74">    this(null);</span>
<span class="nc" id="L75">  }</span>

  /**
   * Constructs a new instance, optionally associated with the given file descriptor.
   * 
   * @param fdObj The file descriptor, or {@code null}.
   * @throws IOException if the operation fails.
   */
  protected AFServerSocket(FileDescriptor fdObj) throws IOException {
<span class="fc" id="L84">    super();</span>
<span class="fc" id="L85">    this.implementation = newImpl(fdObj);</span>
<span class="fc" id="L86">    NativeUnixSocket.initServerImpl(this, implementation);</span>

<span class="fc" id="L88">    setReuseAddress(true);</span>
<span class="fc" id="L89">  }</span>

  /**
   * Creates a new AFServerSocketChannel for this socket.
   * 
   * @return The new instance.
   */
  protected abstract AFServerSocketChannel&lt;?&gt; newChannel();

  /**
   * Creates a new AFSocketImpl.
   * 
   * @param fdObj The file descriptor.
   * @return The new instance.
   * @throws IOException on error.
   */
  protected abstract AFSocketImpl&lt;A&gt; newImpl(FileDescriptor fdObj) throws IOException;

  /**
   * Creates a new AFServerSocket instance, using the given subclass constructor.
   * 
   * @param &lt;A&gt; The concrete {@link AFSocketAddress} that is supported by this type.
   * @param instanceSupplier The subclass constructor.
   * @return The new instance.
   * @throws IOException on error.
   */
  protected static &lt;A extends AFSocketAddress&gt; AFServerSocket&lt;A&gt; newInstance(
      Constructor&lt;A&gt; instanceSupplier) throws IOException {
<span class="fc" id="L117">    return instanceSupplier.newInstance(null);</span>
  }

  /**
   * Creates a new AFServerSocket instance, using the given subclass constructor.
   * 
   * @param &lt;A&gt; The concrete {@link AFSocketAddress} that is supported by this type.
   * @param instanceSupplier The subclass constructor.
   * @param fdObj The file descriptor.
   * @param localPort The local port.
   * @param remotePort The remote port.
   * @return The new instance.
   * @throws IOException on error.
   */
  protected static &lt;A extends AFSocketAddress&gt; AFServerSocket&lt;A&gt; newInstance(
      Constructor&lt;A&gt; instanceSupplier, FileDescriptor fdObj, int localPort, int remotePort)
      throws IOException {
<span class="pc bpc" id="L134" title="1 of 2 branches missed.">    if (fdObj == null) {</span>
<span class="nc" id="L135">      return instanceSupplier.newInstance(null);</span>
    }

<span class="fc" id="L138">    int status = NativeUnixSocket.socketStatus(fdObj);</span>
<span class="pc bpc" id="L139" title="2 of 4 branches missed.">    if (!fdObj.valid() || status == NativeUnixSocket.SOCKETSTATUS_INVALID) {</span>
<span class="nc" id="L140">      throw new SocketException(&quot;Not a valid socket&quot;);</span>
    }
<span class="fc" id="L142">    AFServerSocket&lt;A&gt; socket = instanceSupplier.newInstance(fdObj);</span>
<span class="fc" id="L143">    socket.getAFImpl().updatePorts(localPort, remotePort);</span>

<span class="pc bpc" id="L145" title="3 of 4 branches missed.">    switch (status) {</span>
      case NativeUnixSocket.SOCKETSTATUS_CONNECTED:
<span class="nc" id="L147">        throw new SocketException(&quot;Not a ServerSocket&quot;);</span>
      case NativeUnixSocket.SOCKETSTATUS_BOUND:
<span class="fc" id="L149">        socket.bind(AFSocketAddress.INTERNAL_DUMMY_BIND);</span>

<span class="fc" id="L151">        socket.setBoundEndpoint(AFSocketAddress.getSocketAddress(fdObj, false, localPort, socket</span>
<span class="fc" id="L152">            .addressFamily()));</span>
<span class="fc" id="L153">        break;</span>
      case NativeUnixSocket.SOCKETSTATUS_UNKNOWN:
<span class="nc" id="L155">        break;</span>
      default:
<span class="nc" id="L157">        throw new IllegalStateException(&quot;Invalid socketStatus response: &quot; + status);</span>
    }

<span class="fc" id="L160">    socket.getAFImpl().setSocketAddress(socket.getLocalSocketAddress());</span>
<span class="fc" id="L161">    return socket;</span>
  }

  /**
   * Returns a new {@link ServerSocket} that is bound to the given {@link AFSocketAddress}.
   * 
   * @param instanceSupplier The constructor of the concrete subclass.
   * @param addr The socket file to bind to.
   * @param &lt;A&gt; The concrete {@link AFSocketAddress} that is supported by this type.
   * @return The new, bound {@link AFServerSocket}.
   * @throws IOException if the operation fails.
   */
  protected static &lt;A extends AFSocketAddress&gt; AFServerSocket&lt;A&gt; bindOn(
      Constructor&lt;A&gt; instanceSupplier, final AFSocketAddress addr) throws IOException {
<span class="fc" id="L175">    AFServerSocket&lt;A&gt; socket = instanceSupplier.newInstance(null);</span>
<span class="fc" id="L176">    socket.bind(addr);</span>
<span class="fc" id="L177">    return socket;</span>
  }

  /**
   * Returns a new {@link ServerSocket} that is bound to the given {@link AFSocketAddress}.
   * 
   * @param instanceSupplier The constructor of the concrete subclass.
   * @param addr The socket file to bind to.
   * @param deleteOnClose If {@code true}, the socket file (if the address points to a file) will be
   *          deleted upon {@link #close}.
   * @param &lt;A&gt; The concrete {@link AFSocketAddress} that is supported by this type.
   * @return The new, bound {@link AFServerSocket}.
   * @throws IOException if the operation fails.
   */
  protected static &lt;A extends AFSocketAddress&gt; AFServerSocket&lt;A&gt; bindOn(
      Constructor&lt;A&gt; instanceSupplier, final A addr, boolean deleteOnClose) throws IOException {
<span class="fc" id="L193">    AFServerSocket&lt;A&gt; socket = instanceSupplier.newInstance(null);</span>
<span class="fc" id="L194">    socket.bind(addr);</span>
<span class="fc" id="L195">    socket.setDeleteOnClose(deleteOnClose);</span>
<span class="fc" id="L196">    return socket;</span>
  }

  /**
   * Returns a new, &lt;em&gt;unbound&lt;/em&gt; {@link ServerSocket} that will always bind to the given
   * address, regardless of any socket address used in a call to &lt;code&gt;bind&lt;/code&gt;.
   * 
   * @param instanceSupplier The constructor of the concrete subclass.
   * @param forceAddr The address to use.
   * @param &lt;A&gt; The concrete {@link AFSocketAddress} that is supported by this type.
   * @return The new, yet unbound {@link AFServerSocket}.
   * @throws IOException if an exception occurs.
   */
  protected static &lt;A extends AFSocketAddress&gt; AFServerSocket&lt;A&gt; forceBindOn(
      Constructor&lt;A&gt; instanceSupplier, final A forceAddr) throws IOException {
<span class="nc" id="L211">    AFServerSocket&lt;A&gt; socket = instanceSupplier.newInstance(null);</span>
<span class="nc" id="L212">    return socket.forceBindAddress(forceAddr);</span>
  }

  /**
   * Forces the address to be used for any subsequent call to {@link #bind(SocketAddress)} to be the
   * given one, regardless of what'll be passed to {@link #bind(SocketAddress, int)}, but doesn't
   * bind yet.
   * 
   * @param endpoint The forced endpoint address.
   * @return This {@link AFServerSocket}.
   */
  public final AFServerSocket&lt;A&gt; forceBindAddress(SocketAddress endpoint) {
<span class="nc" id="L224">    return bindHook((SocketAddress orig) -&gt; {</span>
<span class="nc bnc" id="L225" title="All 2 branches missed.">      return orig == null ? null : endpoint;</span>
    });
  }

  @SuppressWarnings(&quot;unchecked&quot;)
  @Override
  public final void bind(SocketAddress endpoint, int backlog) throws IOException {
<span class="pc bpc" id="L232" title="1 of 2 branches missed.">    if (isClosed()) {</span>
<span class="nc" id="L233">      throw new SocketException(&quot;Socket is closed&quot;);</span>
    }

    boolean bindErrorOk;
<span class="pc bpc" id="L237" title="1 of 2 branches missed.">    if (bindFilter != null) {</span>
<span class="nc" id="L238">      endpoint = bindFilter.apply(endpoint);</span>
<span class="nc bnc" id="L239" title="All 4 branches missed.">      bindErrorOk = endpoint != null &amp;&amp; isBound();</span>
    } else {
<span class="fc" id="L241">      bindErrorOk = false;</span>
    }

<span class="fc bfc" id="L244" title="All 2 branches covered.">    if (!(endpoint instanceof AFSocketAddress)) {</span>
<span class="fc" id="L245">      throw new IllegalArgumentException(&quot;Can only bind to endpoints of type &quot;</span>
<span class="fc" id="L246">          + AFSocketAddress.class.getName() + &quot;: &quot; + endpoint);</span>
    }

    A endpointCast;
    try {
<span class="fc" id="L251">      endpointCast = (A) endpoint;</span>
<span class="nc" id="L252">    } catch (ClassCastException e) {</span>
<span class="nc" id="L253">      throw new IllegalArgumentException(&quot;Can only bind to specific endpoints&quot;, e);</span>
<span class="fc" id="L254">    }</span>

    try {
<span class="fc bfc" id="L257" title="All 2 branches covered.">      getAFImpl().bind(endpoint, getReuseAddress() ? NativeUnixSocket.BIND_OPT_REUSE : 0);</span>
<span class="fc" id="L258">    } catch (SocketException e) {</span>
<span class="pc bpc" id="L259" title="1 of 2 branches missed.">      if (bindErrorOk) {</span>
        // force-binding an address could mean double-binding the same address, that's OK.
<span class="nc" id="L261">        return;</span>
      } else {
<span class="fc" id="L263">        throw e;</span>
      }
<span class="fc" id="L265">    }</span>
<span class="fc" id="L266">    setBoundEndpoint(getAFImpl().getLocalSocketAddress());</span>
<span class="pc bpc" id="L267" title="1 of 2 branches missed.">    if (boundEndpoint == null) {</span>
<span class="nc" id="L268">      setBoundEndpoint(endpointCast);</span>
    }

<span class="fc bfc" id="L271" title="All 2 branches covered.">    if (endpoint == AFSocketAddress.INTERNAL_DUMMY_BIND) { // NOPMD</span>
<span class="fc" id="L272">      return;</span>
    }

<span class="fc" id="L275">    implementation.listen(backlog);</span>
<span class="fc" id="L276">  }</span>

  @Override
  public final boolean isBound() {
<span class="fc bfc" id="L280" title="All 4 branches covered.">    return boundEndpoint != null &amp;&amp; implementation.getFD().valid();</span>
  }

  @Override
  public final boolean isClosed() {
<span class="pc bpc" id="L285" title="1 of 6 branches missed.">    return super.isClosed() || (isBound() &amp;&amp; !implementation.getFD().valid()) || implementation</span>
<span class="pc bpc" id="L286" title="1 of 2 branches missed.">        .isClosed();</span>
  }

  @Override
  public AFSocket&lt;A&gt; accept() throws IOException {
<span class="fc" id="L291">    return accept1(true);</span>
  }

  AFSocket&lt;A&gt; accept1(boolean throwOnFail) throws IOException {
<span class="fc" id="L295">    AFSocket&lt;A&gt; as = newSocketInstance();</span>

<span class="fc" id="L297">    boolean success = implementation.accept0(as.getAFImpl(false));</span>
<span class="fc bfc" id="L298" title="All 2 branches covered.">    if (isClosed()) {</span>
      // We may have connected to the socket to unblock it
<span class="fc" id="L300">      throw new SocketClosedException(&quot;Socket is closed&quot;);</span>
    }

<span class="fc bfc" id="L303" title="All 2 branches covered.">    if (!success) {</span>
<span class="pc bpc" id="L304" title="1 of 2 branches missed.">      if (throwOnFail) {</span>
<span class="nc bnc" id="L305" title="All 2 branches missed.">        if (getChannel().isBlocking()) {</span>
          // unexpected
<span class="nc" id="L307">          return null;</span>
        } else {
          // non-blocking socket, nothing to accept
<span class="nc" id="L310">          throw new IllegalBlockingModeException();</span>
        }
      } else {
<span class="fc" id="L313">        return null;</span>
      }
    }

<span class="fc" id="L317">    as.getAFImpl(true); // trigger create</span>
<span class="fc" id="L318">    as.connect(AFSocketAddress.INTERNAL_DUMMY_CONNECT);</span>
<span class="fc" id="L319">    as.getAFImpl().updatePorts(getAFImpl().getLocalPort1(), getAFImpl().getRemotePort());</span>

<span class="fc" id="L321">    return as;</span>
  }

  /**
   * Returns a new {@link AFSocket} instance.
   * 
   * @return The new instance.
   * @throws IOException on error.
   */
  protected abstract AFSocket&lt;A&gt; newSocketInstance() throws IOException;

  @Override
  public String toString() {
<span class="nc bnc" id="L334" title="All 2 branches missed.">    return getClass().getSimpleName() + &quot;[&quot; + (isBound() ? boundEndpoint : &quot;unbound&quot;) + &quot;]&quot;;</span>
  }

  @Override
  public synchronized void close() throws IOException {
<span class="fc bfc" id="L339" title="All 2 branches covered.">    if (isClosed()) {</span>
<span class="fc" id="L340">      return;</span>
    }

<span class="fc" id="L343">    boolean localSocketAddressValid = isLocalSocketAddressValid();</span>

<span class="fc" id="L345">    AFSocketAddress endpoint = boundEndpoint;</span>

<span class="fc" id="L347">    IOException superException = null;</span>
    try {
<span class="fc" id="L349">      super.close();</span>
<span class="nc" id="L350">    } catch (IOException e) {</span>
<span class="nc" id="L351">      superException = e;</span>
<span class="fc" id="L352">    }</span>
<span class="pc bpc" id="L353" title="1 of 2 branches missed.">    if (implementation != null) {</span>
      try {
<span class="fc" id="L355">        implementation.close();</span>
<span class="nc" id="L356">      } catch (IOException e) {</span>
<span class="nc bnc" id="L357" title="All 2 branches missed.">        if (superException == null) {</span>
<span class="nc" id="L358">          superException = e;</span>
        } else {
<span class="nc" id="L360">          superException.addSuppressed(e);</span>
        }
<span class="fc" id="L362">      }</span>
    }

<span class="fc" id="L365">    IOException ex = null;</span>
    try {
<span class="fc" id="L367">      closeables.close(superException);</span>
    } finally {
<span class="pc bpc" id="L369" title="1 of 6 branches missed.">      if (endpoint != null &amp;&amp; endpoint.hasFilename() &amp;&amp; localSocketAddressValid</span>
<span class="pc bpc" id="L370" title="1 of 2 branches missed.">          &amp;&amp; isDeleteOnClose()) {</span>
<span class="fc" id="L371">        File f = endpoint.getFile();</span>
<span class="pc bpc" id="L372" title="1 of 4 branches missed.">        if (!f.delete() &amp;&amp; f.exists()) {</span>
<span class="nc" id="L373">          ex = new IOException(&quot;Could not delete socket file after close: &quot; + f);</span>
        }
      }
    }
<span class="pc bpc" id="L377" title="1 of 2 branches missed.">    if (ex != null) {</span>
<span class="nc" id="L378">      throw ex;</span>
    }
<span class="fc" id="L380">  }</span>

  /**
   * Registers a {@link Closeable} that should be closed when this socket is closed.
   * 
   * @param closeable The closeable.
   */
  public final void addCloseable(Closeable closeable) {
<span class="fc" id="L388">    closeables.add(closeable);</span>
<span class="fc" id="L389">  }</span>

  /**
   * Unregisters a previously registered {@link Closeable}.
   * 
   * @param closeable The closeable.
   */
  public final void removeCloseable(Closeable closeable) {
<span class="fc" id="L397">    closeables.remove(closeable);</span>
<span class="fc" id="L398">  }</span>

  /**
   * Checks whether everything is setup to support junixsocket sockets.
   * 
   * @return {@code true} if supported.
   */
  public static boolean isSupported() {
<span class="fc" id="L406">    return NativeUnixSocket.isLoaded();</span>
  }

  @Override
  @SuppressFBWarnings(&quot;EI_EXPOSE_REP&quot;)
  public final @Nullable A getLocalSocketAddress() {
<span class="fc bfc" id="L412" title="All 2 branches covered.">    if (boundEndpoint == null) {</span>
<span class="fc" id="L413">      setBoundEndpoint(getAFImpl().getLocalSocketAddress());</span>
    }
<span class="fc" id="L415">    return boundEndpoint;</span>
  }

  /**
   * Checks if the local socket address returned by {@link #getLocalSocketAddress()} is still valid.
   * 
   * The address is no longer valid if the server socket has been closed, {@code null}, or another
   * server socket has been bound on that address.
   * 
   * @return {@code true} iff still valid.
   */
  public boolean isLocalSocketAddressValid() {
<span class="pc bpc" id="L427" title="1 of 2 branches missed.">    if (isClosed()) {</span>
<span class="nc" id="L428">      return false;</span>
    }
    @Nullable
<span class="fc" id="L431">    A addr = getLocalSocketAddress();</span>
<span class="fc bfc" id="L432" title="All 2 branches covered.">    if (addr == null) {</span>
<span class="fc" id="L433">      return false;</span>
    }
<span class="fc" id="L435">    return addr.equals(getAFImpl().getLocalSocketAddress());</span>
  }

  final void setBoundEndpoint(@Nullable A addr) {
<span class="fc" id="L439">    this.boundEndpoint = addr;</span>
    int port;
<span class="fc bfc" id="L441" title="All 2 branches covered.">    if (addr == null) {</span>
<span class="fc" id="L442">      port = -1;</span>
    } else {
<span class="fc" id="L444">      port = addr.getPort();</span>
    }
<span class="fc" id="L446">    getAFImpl().updatePorts(port, -1);</span>
<span class="fc" id="L447">  }</span>

  @Override
  public final int getLocalPort() {
<span class="pc bpc" id="L451" title="1 of 2 branches missed.">    if (boundEndpoint == null) {</span>
<span class="nc" id="L452">      setBoundEndpoint(getAFImpl().getLocalSocketAddress());</span>
    }
<span class="pc bpc" id="L454" title="1 of 2 branches missed.">    if (boundEndpoint == null) {</span>
<span class="nc" id="L455">      return -1;</span>
    } else {
<span class="fc" id="L457">      return getAFImpl().getLocalPort1();</span>
    }
  }

  /**
   * Checks if this {@link AFServerSocket}'s file should be removed upon {@link #close()}.
   * 
   * Deletion is not guaranteed, especially when not supported (e.g., addresses in the abstract
   * namespace).
   * 
   * @return {@code true} if an attempt is made to delete the socket file upon {@link #close()}.
   */
  public final boolean isDeleteOnClose() {
<span class="fc" id="L470">    return deleteOnClose.get();</span>
  }

  /**
   * Enables/disables deleting this {@link AFServerSocket}'s file (or other resource type) upon
   * {@link #close()}.
   * 
   * Deletion is not guaranteed, especially when not supported (e.g., addresses in the abstract
   * namespace).
   * 
   * @param b Enabled if {@code true}.
   */
  public final void setDeleteOnClose(boolean b) {
<span class="fc" id="L483">    deleteOnClose.set(b);</span>
<span class="fc" id="L484">  }</span>

  final AFSocketImpl&lt;A&gt; getAFImpl() {
<span class="fc bfc" id="L487" title="All 2 branches covered.">    if (created.compareAndSet(false, true)) {</span>
      try {
<span class="fc" id="L489">        getSoTimeout(); // trigger create via java.net.Socket</span>
<span class="nc" id="L490">      } catch (IOException e) {</span>
        // ignore
<span class="fc" id="L492">      }</span>
    }
<span class="fc" id="L494">    return implementation;</span>
  }

  @SuppressFBWarnings(&quot;EI_EXPOSE_REP&quot;)
  @Override
  public AFServerSocketChannel&lt;?&gt; getChannel() {
<span class="fc" id="L500">    return channel;</span>
  }

  @Override
  public final FileDescriptor getFileDescriptor() throws IOException {
<span class="fc" id="L505">    return implementation.getFileDescriptor();</span>
  }

  /**
   * Returns the address family supported by this implementation.
   * 
   * @return The family.
   */
  protected final AFAddressFamily&lt;A&gt; addressFamily() {
<span class="fc" id="L514">    return getAFImpl().getAddressFamily();</span>
  }

  /**
   * Sets the hook for any subsequent call to {@link #bind(SocketAddress)} and
   * {@link #bind(SocketAddress, int)} to be the given function.
   * 
   * The function can monitor calls or even alter the endpoint address.
   * 
   * @param hook The function that gets called for each {@code bind} call.
   * @return This instance.
   */
  public final AFServerSocket&lt;A&gt; bindHook(SocketAddressFilter hook) {
<span class="nc" id="L527">    this.bindFilter = hook;</span>
<span class="nc" id="L528">    return this;</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>