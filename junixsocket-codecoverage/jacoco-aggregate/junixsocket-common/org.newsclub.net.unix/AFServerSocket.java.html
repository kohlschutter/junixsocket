<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>AFServerSocket.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">junixsocket-codecoverage</a> &gt; <a href="../index.html" class="el_bundle">junixsocket-common</a> &gt; <a href="index.source.html" class="el_package">org.newsclub.net.unix</a> &gt; <span class="el_source">AFServerSocket.java</span></div><h1>AFServerSocket.java</h1><pre class="source lang-java linenums">/*
 * junixsocket
 *
 * Copyright 2009-2024 Christian Kohlschütter
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.newsclub.net.unix;

import java.io.Closeable;
import java.io.File;
import java.io.FileDescriptor;
import java.io.IOException;
import java.net.InetAddress;
import java.net.ServerSocket;
import java.net.SocketAddress;
import java.net.SocketException;
import java.net.SocketOption;
import java.net.SocketOptions;
import java.nio.channels.IllegalBlockingModeException;
import java.util.Objects;
import java.util.Set;
import java.util.concurrent.atomic.AtomicBoolean;

import org.eclipse.jdt.annotation.NonNull;
import org.eclipse.jdt.annotation.Nullable;

import com.kohlschutter.annotations.compiletime.SuppressFBWarnings;

/**
 * The server part of a junixsocket socket.
 *
 * @param &lt;A&gt; The concrete {@link AFSocketAddress} that is supported by this type.
 * @author Christian Kohlschütter
 */
@SuppressWarnings({&quot;PMD.CyclomaticComplexity&quot;, &quot;PMD.CouplingBetweenObjects&quot;})
public abstract class AFServerSocket&lt;A extends AFSocketAddress&gt; extends ServerSocket implements
    AFSomeSocketThing {
  private final AFSocketImpl&lt;A&gt; implementation;
  private @Nullable A boundEndpoint;
<span class="fc" id="L51">  private final Closeables closeables = new Closeables();</span>
<span class="fc" id="L52">  private final AtomicBoolean created = new AtomicBoolean(false);</span>
<span class="fc" id="L53">  private final AtomicBoolean deleteOnClose = new AtomicBoolean(true);</span>

<span class="fc" id="L55">  @SuppressWarnings(&quot;this-escape&quot;)</span>
<span class="fc" id="L56">  private final AFServerSocketChannel&lt;?&gt; channel = newChannel();</span>
  private @Nullable SocketAddressFilter bindFilter;

  /**
   * The constructor of the concrete subclass.
   *
   * @param &lt;A&gt; The concrete {@link AFSocketAddress} that is supported by this type.
   */
  public interface Constructor&lt;A extends AFSocketAddress&gt; {
    /**
     * Creates a new {@link AFServerSocket} instance.
     *
     * @param fd The file descriptor.
     * @return The new instance.
     * @throws IOException on error.
     */
    @NonNull
    AFServerSocket&lt;A&gt; newInstance(FileDescriptor fd) throws IOException;
  }

  /**
   * Constructs a new, unconnected instance.
   *
   * @throws IOException if the operation fails.
   */
  @SuppressFBWarnings(&quot;CT_CONSTRUCTOR_THROW&quot;)
  protected AFServerSocket() throws IOException {
<span class="nc" id="L83">    this(null);</span>
<span class="nc" id="L84">  }</span>

  /**
   * Constructs a new instance, optionally associated with the given file descriptor.
   *
   * @param fdObj The file descriptor, or {@code null}.
   * @throws IOException if the operation fails.
   */
  @SuppressWarnings({&quot;this-escape&quot;, &quot;PMD.ConstructorCallsOverridableMethod&quot;})
  @SuppressFBWarnings(&quot;CT_CONSTRUCTOR_THROW&quot;)
  protected AFServerSocket(FileDescriptor fdObj) throws IOException {
<span class="fc" id="L95">    super();</span>

<span class="fc" id="L97">    this.implementation = newImpl(fdObj);</span>
<span class="fc" id="L98">    NativeUnixSocket.initServerImpl(this, implementation);</span>

<span class="fc" id="L100">    getAFImpl().setOption(SocketOptions.SO_REUSEADDR, true);</span>
<span class="fc" id="L101">  }</span>

  /**
   * Creates a new AFServerSocketChannel for this socket.
   *
   * @return The new instance.
   */
  protected abstract AFServerSocketChannel&lt;?&gt; newChannel();

  /**
   * Creates a new AFSocketImpl.
   *
   * @param fdObj The file descriptor.
   * @return The new instance.
   * @throws IOException on error.
   */
  protected abstract AFSocketImpl&lt;A&gt; newImpl(FileDescriptor fdObj) throws IOException;

  /**
   * Creates a new AFServerSocket instance, using the given subclass constructor.
   *
   * @param &lt;A&gt; The concrete {@link AFSocketAddress} that is supported by this type.
   * @param instanceSupplier The subclass constructor.
   * @return The new instance.
   * @throws IOException on error.
   */
  protected static &lt;A extends AFSocketAddress&gt; AFServerSocket&lt;A&gt; newInstance(
      Constructor&lt;A&gt; instanceSupplier) throws IOException {
<span class="fc" id="L129">    return instanceSupplier.newInstance(null);</span>
  }

  /**
   * Creates a new AFServerSocket instance, using the given subclass constructor.
   *
   * @param &lt;A&gt; The concrete {@link AFSocketAddress} that is supported by this type.
   * @param instanceSupplier The subclass constructor.
   * @param fdObj The file descriptor.
   * @param localPort The local port.
   * @param remotePort The remote port.
   * @return The new instance.
   * @throws IOException on error.
   */
  protected static &lt;A extends AFSocketAddress&gt; AFServerSocket&lt;A&gt; newInstance(
      Constructor&lt;A&gt; instanceSupplier, FileDescriptor fdObj, int localPort, int remotePort)
      throws IOException {
<span class="pc bpc" id="L146" title="1 of 2 branches missed.">    if (fdObj == null) {</span>
<span class="nc" id="L147">      return instanceSupplier.newInstance(null);</span>
    }

<span class="fc" id="L150">    int status = NativeUnixSocket.socketStatus(fdObj);</span>
<span class="pc bpc" id="L151" title="2 of 4 branches missed.">    if (!fdObj.valid() || status == NativeUnixSocket.SOCKETSTATUS_INVALID) {</span>
<span class="nc" id="L152">      throw new SocketException(&quot;Not a valid socket&quot;);</span>
    }
<span class="fc" id="L154">    AFServerSocket&lt;A&gt; socket = instanceSupplier.newInstance(fdObj);</span>
<span class="fc" id="L155">    socket.getAFImpl().updatePorts(localPort, remotePort);</span>

<span class="pc bpc" id="L157" title="3 of 4 branches missed.">    switch (status) {</span>
      case NativeUnixSocket.SOCKETSTATUS_CONNECTED:
<span class="nc" id="L159">        throw new SocketException(&quot;Not a ServerSocket&quot;);</span>
      case NativeUnixSocket.SOCKETSTATUS_BOUND:
<span class="fc" id="L161">        socket.bind(AFSocketAddress.INTERNAL_DUMMY_BIND);</span>

<span class="fc" id="L163">        socket.setBoundEndpoint(AFSocketAddress.getSocketAddress(fdObj, false, localPort, socket</span>
<span class="fc" id="L164">            .addressFamily()));</span>
<span class="fc" id="L165">        break;</span>
      case NativeUnixSocket.SOCKETSTATUS_UNKNOWN:
<span class="nc" id="L167">        break;</span>
      default:
<span class="nc" id="L169">        throw new IllegalStateException(&quot;Invalid socketStatus response: &quot; + status);</span>
    }

<span class="fc" id="L172">    socket.getAFImpl().setSocketAddress(socket.getLocalSocketAddress());</span>
<span class="fc" id="L173">    return socket;</span>
  }

  /**
   * Returns a new {@link ServerSocket} that is bound to the given {@link AFSocketAddress}.
   *
   * @param instanceSupplier The constructor of the concrete subclass.
   * @param addr The socket file to bind to.
   * @param &lt;A&gt; The concrete {@link AFSocketAddress} that is supported by this type.
   * @return The new, bound {@link AFServerSocket}.
   * @throws IOException if the operation fails.
   */
  protected static &lt;A extends AFSocketAddress&gt; AFServerSocket&lt;A&gt; bindOn(
      Constructor&lt;A&gt; instanceSupplier, final AFSocketAddress addr) throws IOException {
<span class="fc" id="L187">    AFServerSocket&lt;A&gt; socket = instanceSupplier.newInstance(null);</span>
<span class="fc" id="L188">    socket.bind(addr);</span>
<span class="fc" id="L189">    return socket;</span>
  }

  /**
   * Returns a new {@link ServerSocket} that is bound to the given {@link AFSocketAddress}.
   *
   * @param instanceSupplier The constructor of the concrete subclass.
   * @param addr The socket file to bind to.
   * @param deleteOnClose If {@code true}, the socket file (if the address points to a file) will be
   *          deleted upon {@link #close}.
   * @param &lt;A&gt; The concrete {@link AFSocketAddress} that is supported by this type.
   * @return The new, bound {@link AFServerSocket}.
   * @throws IOException if the operation fails.
   */
  protected static &lt;A extends AFSocketAddress&gt; AFServerSocket&lt;A&gt; bindOn(
      Constructor&lt;A&gt; instanceSupplier, final A addr, boolean deleteOnClose) throws IOException {
<span class="fc" id="L205">    AFServerSocket&lt;A&gt; socket = instanceSupplier.newInstance(null);</span>
<span class="fc" id="L206">    socket.bind(addr);</span>
<span class="fc" id="L207">    socket.setDeleteOnClose(deleteOnClose);</span>
<span class="fc" id="L208">    return socket;</span>
  }

  /**
   * Returns a new, &lt;em&gt;unbound&lt;/em&gt; {@link ServerSocket} that will always bind to the given
   * address, regardless of any socket address used in a call to &lt;code&gt;bind&lt;/code&gt;.
   *
   * @param instanceSupplier The constructor of the concrete subclass.
   * @param forceAddr The address to use.
   * @param &lt;A&gt; The concrete {@link AFSocketAddress} that is supported by this type.
   * @return The new, yet unbound {@link AFServerSocket}.
   * @throws IOException if an exception occurs.
   */
  protected static &lt;A extends AFSocketAddress&gt; AFServerSocket&lt;A&gt; forceBindOn(
      Constructor&lt;A&gt; instanceSupplier, final A forceAddr) throws IOException {
<span class="nc" id="L223">    AFServerSocket&lt;A&gt; socket = instanceSupplier.newInstance(null);</span>
<span class="nc" id="L224">    return socket.forceBindAddress(forceAddr);</span>
  }

  /**
   * Forces the address to be used for any subsequent call to {@link #bind(SocketAddress)} to be the
   * given one, regardless of what'll be passed to {@link #bind(SocketAddress, int)}, but doesn't
   * bind yet.
   *
   * @param endpoint The forced endpoint address.
   * @return This {@link AFServerSocket}.
   */
  public final AFServerSocket&lt;A&gt; forceBindAddress(SocketAddress endpoint) {
<span class="nc" id="L236">    return bindHook((SocketAddress orig) -&gt; {</span>
<span class="nc bnc" id="L237" title="All 2 branches missed.">      return orig == null ? null : endpoint;</span>
    });
  }

  @SuppressWarnings(&quot;unchecked&quot;)
  @Override
  public final void bind(SocketAddress endpoint, int backlog) throws IOException {
<span class="pc bpc" id="L244" title="1 of 2 branches missed.">    if (isClosed()) {</span>
<span class="nc" id="L245">      throw new SocketException(&quot;Socket is closed&quot;);</span>
    }

    boolean bindErrorOk;
<span class="pc bpc" id="L249" title="1 of 2 branches missed.">    if (bindFilter != null) {</span>
<span class="nc" id="L250">      endpoint = bindFilter.apply(endpoint);</span>
<span class="nc bnc" id="L251" title="All 4 branches missed.">      bindErrorOk = endpoint != null &amp;&amp; isBound();</span>
    } else {
<span class="fc" id="L253">      bindErrorOk = false;</span>
    }

<span class="fc bfc" id="L256" title="All 2 branches covered.">    if (!(endpoint instanceof AFSocketAddress)) {</span>
<span class="fc" id="L257">      throw new IllegalArgumentException(&quot;Can only bind to endpoints of type &quot;</span>
<span class="fc" id="L258">          + AFSocketAddress.class.getName() + &quot;: &quot; + endpoint);</span>
    }

    A endpointCast;
    try {
<span class="fc" id="L263">      endpointCast = (A) endpoint;</span>
<span class="nc" id="L264">    } catch (ClassCastException e) {</span>
<span class="nc" id="L265">      throw new IllegalArgumentException(&quot;Can only bind to specific endpoints&quot;, e);</span>
<span class="fc" id="L266">    }</span>

    try {
<span class="fc bfc" id="L269" title="All 2 branches covered.">      getAFImpl().bind(endpoint, getReuseAddress() ? NativeUnixSocket.BIND_OPT_REUSE : 0);</span>
<span class="fc" id="L270">    } catch (SocketException e) {</span>
<span class="pc bpc" id="L271" title="1 of 2 branches missed.">      if (bindErrorOk) {</span>
        // force-binding an address could mean double-binding the same address, that's OK.
<span class="nc" id="L273">        return;</span>
      } else {
<span class="fc" id="L275">        throw e;</span>
      }
<span class="fc" id="L277">    }</span>
<span class="fc" id="L278">    setBoundEndpoint(getAFImpl().getLocalSocketAddress());</span>
<span class="pc bpc" id="L279" title="1 of 2 branches missed.">    if (boundEndpoint0() == null) {</span>
<span class="nc" id="L280">      setBoundEndpoint(endpointCast);</span>
    }

<span class="fc bfc" id="L283" title="All 2 branches covered.">    if (endpoint == AFSocketAddress.INTERNAL_DUMMY_BIND) { // NOPMD</span>
<span class="fc" id="L284">      return;</span>
    }

<span class="fc" id="L287">    implementation.listen(backlog);</span>
<span class="fc" id="L288">  }</span>

  @Override
  public final boolean isBound() {
<span class="fc bfc" id="L292" title="All 4 branches covered.">    return boundEndpoint0() != null &amp;&amp; implementation.getFD().valid();</span>
  }

  @Override
  public final boolean isClosed() {
<span class="pc bpc" id="L297" title="1 of 6 branches missed.">    return super.isClosed() || (isBound() &amp;&amp; !implementation.getFD().valid()) || implementation</span>
<span class="fc bfc" id="L298" title="All 2 branches covered.">        .isClosed();</span>
  }

  @Override
  public AFSocket&lt;A&gt; accept() throws IOException {
<span class="fc" id="L303">    return accept1(true);</span>
  }

  AFSocket&lt;A&gt; accept1(boolean throwOnFail) throws IOException {
<span class="fc" id="L307">    AFSocket&lt;A&gt; as = newSocketInstance();</span>

<span class="fc" id="L309">    boolean success = implementation.accept0(as.getAFImpl(false));</span>
<span class="fc bfc" id="L310" title="All 2 branches covered.">    if (isClosed()) {</span>
      // We may have connected to the socket to unblock it
<span class="fc" id="L312">      throw new SocketClosedException(&quot;Socket is closed&quot;);</span>
    }

<span class="fc bfc" id="L315" title="All 2 branches covered.">    if (!success) {</span>
<span class="pc bpc" id="L316" title="1 of 2 branches missed.">      if (throwOnFail) {</span>
<span class="nc bnc" id="L317" title="All 2 branches missed.">        if (getChannel().isBlocking()) {</span>
          // unexpected
<span class="nc" id="L319">          return null;</span>
        } else {
          // non-blocking socket, nothing to accept
<span class="nc" id="L322">          throw new IllegalBlockingModeException();</span>
        }
      } else {
<span class="fc" id="L325">        return null;</span>
      }
    }

<span class="fc" id="L329">    as.getAFImpl(true); // trigger create</span>
<span class="fc" id="L330">    as.connect(AFSocketAddress.INTERNAL_DUMMY_CONNECT);</span>
<span class="fc" id="L331">    as.getAFImpl().updatePorts(getAFImpl().getLocalPort1(), getAFImpl().getRemotePort());</span>

<span class="fc" id="L333">    return as;</span>
  }

  /**
   * Returns a new {@link AFSocket} instance.
   *
   * @return The new instance.
   * @throws IOException on error.
   */
  protected abstract AFSocket&lt;A&gt; newSocketInstance() throws IOException;

  @Override
  public String toString() {
<span class="nc bnc" id="L346" title="All 2 branches missed.">    return getClass().getSimpleName() + &quot;[&quot; + (isBound() ? boundEndpoint0() : &quot;unbound&quot;) + &quot;]&quot;;</span>
  }

  @Override
  public synchronized void close() throws IOException {
<span class="fc bfc" id="L351" title="All 2 branches covered.">    if (isClosed()) {</span>
<span class="fc" id="L352">      return;</span>
    }

<span class="fc" id="L355">    boolean localSocketAddressValid = isLocalSocketAddressValid();</span>

<span class="fc" id="L357">    AFSocketAddress endpoint = boundEndpoint;</span>

<span class="fc" id="L359">    IOException superException = null;</span>
    try {
<span class="fc" id="L361">      super.close();</span>
<span class="nc" id="L362">    } catch (IOException e) {</span>
<span class="nc" id="L363">      superException = e;</span>
<span class="fc" id="L364">    }</span>
<span class="pc bpc" id="L365" title="1 of 2 branches missed.">    if (implementation != null) {</span>
      try {
<span class="fc" id="L367">        implementation.close();</span>
<span class="nc" id="L368">      } catch (IOException e) {</span>
<span class="nc bnc" id="L369" title="All 2 branches missed.">        if (superException == null) {</span>
<span class="nc" id="L370">          superException = e;</span>
        } else {
<span class="nc" id="L372">          superException.addSuppressed(e);</span>
        }
<span class="fc" id="L374">      }</span>
    }

<span class="fc" id="L377">    IOException ex = null;</span>
    try {
<span class="fc" id="L379">      closeables.close(superException);</span>
    } finally {
<span class="pc bpc" id="L381" title="1 of 6 branches missed.">      if (endpoint != null &amp;&amp; endpoint.hasFilename() &amp;&amp; localSocketAddressValid</span>
<span class="pc bpc" id="L382" title="1 of 2 branches missed.">          &amp;&amp; isDeleteOnClose()) {</span>
<span class="fc" id="L383">        File f = endpoint.getFile();</span>
<span class="pc bpc" id="L384" title="1 of 4 branches missed.">        if (!f.delete() &amp;&amp; f.exists()) {</span>
<span class="nc" id="L385">          ex = new IOException(&quot;Could not delete socket file after close: &quot; + f);</span>
        }
      }
    }
<span class="pc bpc" id="L389" title="1 of 2 branches missed.">    if (ex != null) {</span>
<span class="nc" id="L390">      throw ex;</span>
    }
<span class="fc" id="L392">  }</span>

  /**
   * Registers a {@link Closeable} that should be closed when this socket is closed.
   *
   * @param closeable The closeable.
   */
  public final void addCloseable(Closeable closeable) {
<span class="fc" id="L400">    closeables.add(closeable);</span>
<span class="fc" id="L401">  }</span>

  /**
   * Unregisters a previously registered {@link Closeable}.
   *
   * @param closeable The closeable.
   */
  public final void removeCloseable(Closeable closeable) {
<span class="fc" id="L409">    closeables.remove(closeable);</span>
<span class="fc" id="L410">  }</span>

  /**
   * Checks whether everything is setup to support junixsocket sockets.
   *
   * @return {@code true} if supported.
   */
  public static boolean isSupported() {
<span class="fc" id="L418">    return NativeUnixSocket.isLoaded();</span>
  }

  @Override
  @SuppressFBWarnings(&quot;EI_EXPOSE_REP&quot;)
  public final @Nullable A getLocalSocketAddress() {
    @Nullable
<span class="fc" id="L425">    A ep = boundEndpoint0();</span>
<span class="fc bfc" id="L426" title="All 2 branches covered.">    if (ep == null) {</span>
<span class="fc" id="L427">      ep = getAFImpl().getLocalSocketAddress();</span>
<span class="fc" id="L428">      setBoundEndpoint(ep);</span>
    }
<span class="fc" id="L430">    return ep;</span>
  }

  private synchronized @Nullable A boundEndpoint0() {
<span class="fc" id="L434">    return boundEndpoint;</span>
  }

  /**
   * Checks if the local socket address returned by {@link #getLocalSocketAddress()} is still valid.
   *
   * The address is no longer valid if the server socket has been closed, {@code null}, or another
   * server socket has been bound on that address.
   *
   * @return {@code true} iff still valid.
   */
  public boolean isLocalSocketAddressValid() {
<span class="pc bpc" id="L446" title="1 of 2 branches missed.">    if (isClosed()) {</span>
<span class="nc" id="L447">      return false;</span>
    }
    @Nullable
<span class="fc" id="L450">    A addr = getLocalSocketAddress();</span>
<span class="fc bfc" id="L451" title="All 2 branches covered.">    if (addr == null) {</span>
<span class="fc" id="L452">      return false;</span>
    }
<span class="fc" id="L454">    return addr.equals(getAFImpl().getLocalSocketAddress());</span>
  }

  final synchronized void setBoundEndpoint(@Nullable A addr) {
<span class="fc" id="L458">    this.boundEndpoint = addr;</span>
    int port;
<span class="fc bfc" id="L460" title="All 2 branches covered.">    if (addr == null) {</span>
<span class="fc" id="L461">      port = -1;</span>
    } else {
<span class="fc" id="L463">      port = addr.getPort();</span>
    }
<span class="fc" id="L465">    getAFImpl().updatePorts(port, -1);</span>
<span class="fc" id="L466">  }</span>

  @Override
  public final int getLocalPort() {
<span class="pc bpc" id="L470" title="1 of 2 branches missed.">    if (boundEndpoint0() == null) {</span>
<span class="nc" id="L471">      setBoundEndpoint(getAFImpl().getLocalSocketAddress());</span>
    }
<span class="pc bpc" id="L473" title="1 of 2 branches missed.">    if (boundEndpoint0() == null) {</span>
<span class="nc" id="L474">      return -1;</span>
    } else {
<span class="fc" id="L476">      return getAFImpl().getLocalPort1();</span>
    }
  }

  /**
   * Checks if this {@link AFServerSocket}'s file should be removed upon {@link #close()}.
   *
   * Deletion is not guaranteed, especially when not supported (e.g., addresses in the abstract
   * namespace).
   *
   * @return {@code true} if an attempt is made to delete the socket file upon {@link #close()}.
   */
  public final boolean isDeleteOnClose() {
<span class="fc" id="L489">    return deleteOnClose.get();</span>
  }

  /**
   * Enables/disables deleting this {@link AFServerSocket}'s file (or other resource type) upon
   * {@link #close()}.
   *
   * Deletion is not guaranteed, especially when not supported (e.g., addresses in the abstract
   * namespace).
   *
   * @param b Enabled if {@code true}.
   */
  public final void setDeleteOnClose(boolean b) {
<span class="fc" id="L502">    deleteOnClose.set(b);</span>
<span class="fc" id="L503">  }</span>

  final AFSocketImpl&lt;A&gt; getAFImpl() {
<span class="fc bfc" id="L506" title="All 2 branches covered.">    if (created.compareAndSet(false, true)) {</span>
      try {
<span class="fc" id="L508">        getAFImpl().create(true);</span>
<span class="fc" id="L509">        getSoTimeout(); // trigger create via java.net.Socket</span>
<span class="nc" id="L510">      } catch (IOException e) {</span>
        // ignore
<span class="fc" id="L512">      }</span>
    }
<span class="fc" id="L514">    return implementation;</span>
  }

  @SuppressFBWarnings(&quot;EI_EXPOSE_REP&quot;)
  @Override
  public AFServerSocketChannel&lt;?&gt; getChannel() {
<span class="fc" id="L520">    return channel;</span>
  }

  @Override
  public final FileDescriptor getFileDescriptor() throws IOException {
<span class="fc" id="L525">    return implementation.getFileDescriptor();</span>
  }

  /**
   * Returns the address family supported by this implementation.
   *
   * @return The family.
   */
  protected final AFAddressFamily&lt;A&gt; addressFamily() {
<span class="fc" id="L534">    return getAFImpl().getAddressFamily();</span>
  }

  /**
   * Sets the hook for any subsequent call to {@link #bind(SocketAddress)} and
   * {@link #bind(SocketAddress, int)} to be the given function.
   *
   * The function can monitor calls or even alter the endpoint address.
   *
   * @param hook The function that gets called for each {@code bind} call.
   * @return This instance.
   */
  public final AFServerSocket&lt;A&gt; bindHook(SocketAddressFilter hook) {
<span class="nc" id="L547">    this.bindFilter = hook;</span>
<span class="nc" id="L548">    return this;</span>
  }

  @Override
  public void bind(SocketAddress endpoint) throws IOException {
<span class="fc" id="L553">    bind(endpoint, 50);</span>
<span class="fc" id="L554">  }</span>

  @Override
  public InetAddress getInetAddress() {
<span class="nc bnc" id="L558" title="All 2 branches missed.">    if (!isBound()) {</span>
<span class="nc" id="L559">      return null;</span>
    } else {
<span class="nc" id="L561">      return getAFImpl().getInetAddress();</span>
    }
  }

  @Override
  public synchronized void setReceiveBufferSize(int size) throws SocketException {
<span class="nc bnc" id="L567" title="All 2 branches missed.">    if (size &lt;= 0) {</span>
<span class="nc" id="L568">      throw new IllegalArgumentException(&quot;receive buffer size must be a positive number&quot;);</span>
    }
<span class="nc bnc" id="L570" title="All 2 branches missed.">    if (isClosed()) {</span>
<span class="nc" id="L571">      throw new SocketException(&quot;Socket is closed&quot;);</span>
    }
<span class="nc" id="L573">    getAFImpl().setOption(SocketOptions.SO_RCVBUF, size);</span>
<span class="nc" id="L574">  }</span>

  @Override
  public synchronized int getReceiveBufferSize() throws SocketException {
<span class="pc bpc" id="L578" title="1 of 2 branches missed.">    if (isClosed()) {</span>
<span class="nc" id="L579">      throw new SocketException(&quot;Socket is closed&quot;);</span>
    }
<span class="fc" id="L581">    int result = 0;</span>
<span class="fc" id="L582">    Object o = getAFImpl().getOption(SocketOptions.SO_RCVBUF);</span>
<span class="pc bpc" id="L583" title="1 of 2 branches missed.">    if (o instanceof Number) {</span>
<span class="fc" id="L584">      result = ((Number) o).intValue();</span>
    }
<span class="fc" id="L586">    return result;</span>
  }

  @Override
  @SuppressWarnings(&quot;UnsynchronizedOverridesSynchronized&quot; /* errorprone */)
  public void setSoTimeout(int timeout) throws SocketException {
<span class="pc bpc" id="L592" title="1 of 2 branches missed.">    if (isClosed()) {</span>
<span class="nc" id="L593">      throw new SocketException(&quot;Socket is closed&quot;);</span>
    }
<span class="pc bpc" id="L595" title="1 of 2 branches missed.">    if (timeout &lt; 0) {</span>
<span class="nc" id="L596">      throw new IllegalArgumentException(&quot;timeout &lt; 0&quot;);</span>
    }
<span class="fc" id="L598">    getAFImpl().setOption(SocketOptions.SO_TIMEOUT, timeout);</span>
<span class="fc" id="L599">  }</span>

  @Override
  @SuppressWarnings(&quot;UnsynchronizedOverridesSynchronized&quot; /* errorprone */)
  public int getSoTimeout() throws IOException {
<span class="pc bpc" id="L604" title="1 of 2 branches missed.">    if (isClosed()) {</span>
<span class="nc" id="L605">      throw new SocketException(&quot;Socket is closed&quot;);</span>
    }
<span class="fc" id="L607">    Object o = getAFImpl().getOption(SocketOptions.SO_TIMEOUT);</span>
    /* extra type safety */
<span class="pc bpc" id="L609" title="1 of 2 branches missed.">    if (o instanceof Number) {</span>
<span class="fc" id="L610">      return ((Number) o).intValue();</span>
    } else {
<span class="nc" id="L612">      return 0;</span>
    }
  }

  @Override
  public void setReuseAddress(boolean on) throws SocketException {
<span class="pc bpc" id="L618" title="1 of 2 branches missed.">    if (isClosed()) {</span>
<span class="nc" id="L619">      throw new SocketException(&quot;Socket is closed&quot;);</span>
    }
<span class="fc" id="L621">    getAFImpl().setOption(SocketOptions.SO_REUSEADDR, on);</span>
<span class="fc" id="L622">  }</span>

  @Override
  public boolean getReuseAddress() throws SocketException {
<span class="pc bpc" id="L626" title="1 of 2 branches missed.">    if (isClosed()) {</span>
<span class="nc" id="L627">      throw new SocketException(&quot;Socket is closed&quot;);</span>
    }
<span class="fc" id="L629">    return ((Boolean) (getAFImpl().getOption(SocketOptions.SO_REUSEADDR)));</span>
  }

  @Override
  public void setPerformancePreferences(int connectionTime, int latency, int bandwidth) {
<span class="nc" id="L634">  }</span>

  @SuppressWarnings({&quot;all&quot;, &quot;MissingOverride&quot; /* errorprone */})
  public &lt;T&gt; T getOption(SocketOption&lt;T&gt; name) throws IOException {
<span class="fc" id="L638">    Objects.requireNonNull(name);</span>
<span class="pc bpc" id="L639" title="1 of 2 branches missed.">    if (isClosed()) {</span>
<span class="nc" id="L640">      throw new SocketException(&quot;Socket is closed&quot;);</span>
    }
<span class="fc" id="L642">    return getAFImpl().getOption(name);</span>
  }

  @SuppressWarnings({&quot;all&quot;, &quot;MissingOverride&quot; /* errorprone */})
  public &lt;T&gt; ServerSocket setOption(SocketOption&lt;T&gt; name, T value) throws IOException {
<span class="fc" id="L647">    Objects.requireNonNull(name);</span>
<span class="pc bpc" id="L648" title="1 of 2 branches missed.">    if (isClosed()) {</span>
<span class="nc" id="L649">      throw new SocketException(&quot;Socket is closed&quot;);</span>
    }
<span class="fc" id="L651">    getAFImpl().setOption(name, value);</span>
<span class="fc" id="L652">    return this;</span>
  }

  @SuppressWarnings(&quot;all&quot;)
  public Set&lt;SocketOption&lt;?&gt;&gt; supportedOptions() {
<span class="fc" id="L657">    return getAFImpl().supportedOptions();</span>
  }

  @Override
  public void setShutdownOnClose(boolean enabled) {
<span class="nc" id="L662">    getAFImpl().getCore().setShutdownOnClose(enabled);</span>
<span class="nc" id="L663">  }</span>

  // NOTE: We shall re-implement all methods defined in ServerSocket that internally call getImpl()
  // and call getAFImpl() here. This is not strictly necessary for environments where we can
  // override &quot;impl&quot;; however it's the right thing to do.
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>