<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>AFServerSocket.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">junixsocket-codecoverage</a> &gt; <a href="../index.html" class="el_bundle">junixsocket-common</a> &gt; <a href="index.source.html" class="el_package">org.newsclub.net.unix</a> &gt; <span class="el_source">AFServerSocket.java</span></div><h1>AFServerSocket.java</h1><pre class="source lang-java linenums">/*
 * junixsocket
 *
 * Copyright 2009-2024 Christian Kohlschütter
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.newsclub.net.unix;

import java.io.Closeable;
import java.io.File;
import java.io.FileDescriptor;
import java.io.IOException;
import java.net.InetAddress;
import java.net.ServerSocket;
import java.net.SocketAddress;
import java.net.SocketException;
import java.net.SocketOption;
import java.net.SocketOptions;
import java.nio.channels.IllegalBlockingModeException;
import java.util.Objects;
import java.util.Set;
import java.util.concurrent.atomic.AtomicBoolean;

import org.eclipse.jdt.annotation.NonNull;
import org.eclipse.jdt.annotation.Nullable;

import com.kohlschutter.annotations.compiletime.SuppressFBWarnings;

/**
 * The server part of a junixsocket socket.
 *
 * @param &lt;A&gt; The concrete {@link AFSocketAddress} that is supported by this type.
 * @author Christian Kohlschütter
 */
@SuppressWarnings({&quot;PMD.CyclomaticComplexity&quot;, &quot;PMD.CouplingBetweenObjects&quot;})
public abstract class AFServerSocket&lt;A extends AFSocketAddress&gt; extends ServerSocket implements
    AFSomeSocketThing {
  private final AFSocketImpl&lt;A&gt; implementation;
  private @Nullable A boundEndpoint;
<span class="fc" id="L51">  private final Closeables closeables = new Closeables();</span>
<span class="fc" id="L52">  private final AtomicBoolean created = new AtomicBoolean(false);</span>
<span class="fc" id="L53">  private final AtomicBoolean deleteOnClose = new AtomicBoolean(true);</span>

<span class="fc" id="L55">  @SuppressWarnings(&quot;this-escape&quot;)</span>
<span class="fc" id="L56">  private final AFServerSocketChannel&lt;A&gt; channel = newChannel();</span>
  private @Nullable SocketAddressFilter bindFilter;

<span class="fc" id="L59">  private final AtomicBoolean closed = new AtomicBoolean(false);</span>

  /**
   * The constructor of the concrete subclass.
   *
   * @param &lt;A&gt; The concrete {@link AFSocketAddress} that is supported by this type.
   */
  public interface Constructor&lt;A extends AFSocketAddress&gt; {
    /**
     * Creates a new {@link AFServerSocket} instance.
     *
     * @param fd The file descriptor.
     * @return The new instance.
     * @throws IOException on error.
     */
    @NonNull
    AFServerSocket&lt;A&gt; newInstance(FileDescriptor fd) throws IOException;
  }

  /**
   * Constructs a new, unconnected instance.
   *
   * @throws IOException if the operation fails.
   */
  @SuppressFBWarnings(&quot;CT_CONSTRUCTOR_THROW&quot;)
  protected AFServerSocket() throws IOException {
<span class="nc" id="L85">    this(null);</span>
<span class="nc" id="L86">  }</span>

  /**
   * Constructs a new instance, optionally associated with the given file descriptor.
   *
   * @param fdObj The file descriptor, or {@code null}.
   * @throws IOException if the operation fails.
   */
  @SuppressWarnings({&quot;this-escape&quot;, &quot;PMD.ConstructorCallsOverridableMethod&quot;})
  @SuppressFBWarnings(&quot;CT_CONSTRUCTOR_THROW&quot;)
  protected AFServerSocket(FileDescriptor fdObj) throws IOException {
<span class="fc" id="L97">    super();</span>

<span class="fc" id="L99">    this.implementation = newImpl(fdObj);</span>
<span class="fc" id="L100">    NativeUnixSocket.initServerImpl(this, implementation);</span>

<span class="fc" id="L102">    getAFImpl().setOption(SocketOptions.SO_REUSEADDR, true);</span>
<span class="fc" id="L103">  }</span>

  /**
   * Creates a new AFServerSocketChannel for this socket.
   *
   * @return The new instance.
   */
  protected abstract AFServerSocketChannel&lt;A&gt; newChannel();

  /**
   * Creates a new AFSocketImpl.
   *
   * @param fdObj The file descriptor.
   * @return The new instance.
   * @throws IOException on error.
   */
  protected abstract AFSocketImpl&lt;A&gt; newImpl(FileDescriptor fdObj) throws IOException;

  /**
   * Creates a new AFServerSocket instance, using the given subclass constructor.
   *
   * @param &lt;A&gt; The concrete {@link AFSocketAddress} that is supported by this type.
   * @param instanceSupplier The subclass constructor.
   * @return The new instance.
   * @throws IOException on error.
   */
  protected static &lt;A extends AFSocketAddress&gt; AFServerSocket&lt;A&gt; newInstance(
      Constructor&lt;A&gt; instanceSupplier) throws IOException {
<span class="fc" id="L131">    return instanceSupplier.newInstance(null);</span>
  }

  /**
   * Creates a new AFServerSocket instance, using the given subclass constructor.
   *
   * @param &lt;A&gt; The concrete {@link AFSocketAddress} that is supported by this type.
   * @param instanceSupplier The subclass constructor.
   * @param fdObj The file descriptor.
   * @param localPort The local port.
   * @param remotePort The remote port.
   * @return The new instance.
   * @throws IOException on error.
   */
  protected static &lt;A extends AFSocketAddress&gt; AFServerSocket&lt;A&gt; newInstance(
      Constructor&lt;A&gt; instanceSupplier, FileDescriptor fdObj, int localPort, int remotePort)
      throws IOException {
<span class="pc bpc" id="L148" title="1 of 2 branches missed.">    if (fdObj == null) {</span>
<span class="nc" id="L149">      return instanceSupplier.newInstance(null);</span>
    }

<span class="fc" id="L152">    int status = NativeUnixSocket.socketStatus(fdObj);</span>
<span class="pc bpc" id="L153" title="2 of 4 branches missed.">    if (!fdObj.valid() || status == NativeUnixSocket.SOCKETSTATUS_INVALID) {</span>
<span class="nc" id="L154">      throw new SocketException(&quot;Not a valid socket&quot;);</span>
    }
<span class="fc" id="L156">    AFServerSocket&lt;A&gt; socket = instanceSupplier.newInstance(fdObj);</span>
<span class="fc" id="L157">    socket.getAFImpl().updatePorts(localPort, remotePort);</span>

<span class="pc bpc" id="L159" title="3 of 4 branches missed.">    switch (status) {</span>
      case NativeUnixSocket.SOCKETSTATUS_CONNECTED:
<span class="nc" id="L161">        throw new SocketException(&quot;Not a ServerSocket&quot;);</span>
      case NativeUnixSocket.SOCKETSTATUS_BOUND:
<span class="fc" id="L163">        socket.bind(AFSocketAddress.INTERNAL_DUMMY_BIND);</span>

<span class="fc" id="L165">        socket.setBoundEndpoint(AFSocketAddress.getSocketAddress(fdObj, false, localPort, socket</span>
<span class="fc" id="L166">            .addressFamily()));</span>
<span class="fc" id="L167">        break;</span>
      case NativeUnixSocket.SOCKETSTATUS_UNKNOWN:
<span class="nc" id="L169">        break;</span>
      default:
<span class="nc" id="L171">        throw new IllegalStateException(&quot;Invalid socketStatus response: &quot; + status);</span>
    }

<span class="fc" id="L174">    socket.getAFImpl().setSocketAddress(socket.getLocalSocketAddress());</span>
<span class="fc" id="L175">    return socket;</span>
  }

  /**
   * Returns a new {@link ServerSocket} that is bound to the given {@link AFSocketAddress}.
   *
   * @param instanceSupplier The constructor of the concrete subclass.
   * @param addr The socket file to bind to.
   * @param &lt;A&gt; The concrete {@link AFSocketAddress} that is supported by this type.
   * @return The new, bound {@link AFServerSocket}.
   * @throws IOException if the operation fails.
   */
  protected static &lt;A extends AFSocketAddress&gt; AFServerSocket&lt;A&gt; bindOn(
      Constructor&lt;A&gt; instanceSupplier, final AFSocketAddress addr) throws IOException {
<span class="fc" id="L189">    AFServerSocket&lt;A&gt; socket = instanceSupplier.newInstance(null);</span>
<span class="fc" id="L190">    socket.bind(addr);</span>
<span class="fc" id="L191">    return socket;</span>
  }

  /**
   * Returns a new {@link ServerSocket} that is bound to the given {@link AFSocketAddress}.
   *
   * @param instanceSupplier The constructor of the concrete subclass.
   * @param addr The socket file to bind to.
   * @param deleteOnClose If {@code true}, the socket file (if the address points to a file) will be
   *          deleted upon {@link #close}.
   * @param &lt;A&gt; The concrete {@link AFSocketAddress} that is supported by this type.
   * @return The new, bound {@link AFServerSocket}.
   * @throws IOException if the operation fails.
   */
  protected static &lt;A extends AFSocketAddress&gt; AFServerSocket&lt;A&gt; bindOn(
      Constructor&lt;A&gt; instanceSupplier, final A addr, boolean deleteOnClose) throws IOException {
<span class="fc" id="L207">    AFServerSocket&lt;A&gt; socket = instanceSupplier.newInstance(null);</span>
<span class="fc" id="L208">    socket.bind(addr);</span>
<span class="fc" id="L209">    socket.setDeleteOnClose(deleteOnClose);</span>
<span class="fc" id="L210">    return socket;</span>
  }

  /**
   * Returns a new, &lt;em&gt;unbound&lt;/em&gt; {@link ServerSocket} that will always bind to the given
   * address, regardless of any socket address used in a call to &lt;code&gt;bind&lt;/code&gt;.
   *
   * @param instanceSupplier The constructor of the concrete subclass.
   * @param forceAddr The address to use.
   * @param &lt;A&gt; The concrete {@link AFSocketAddress} that is supported by this type.
   * @return The new, yet unbound {@link AFServerSocket}.
   * @throws IOException if an exception occurs.
   */
  protected static &lt;A extends AFSocketAddress&gt; AFServerSocket&lt;A&gt; forceBindOn(
      Constructor&lt;A&gt; instanceSupplier, final A forceAddr) throws IOException {
<span class="nc" id="L225">    AFServerSocket&lt;A&gt; socket = instanceSupplier.newInstance(null);</span>
<span class="nc" id="L226">    return socket.forceBindAddress(forceAddr);</span>
  }

  /**
   * Forces the address to be used for any subsequent call to {@link #bind(SocketAddress)} to be the
   * given one, regardless of what'll be passed to {@link #bind(SocketAddress, int)}, but doesn't
   * bind yet.
   *
   * @param endpoint The forced endpoint address.
   * @return This {@link AFServerSocket}.
   */
  public final AFServerSocket&lt;A&gt; forceBindAddress(SocketAddress endpoint) {
<span class="nc" id="L238">    return bindHook((SocketAddress orig) -&gt; {</span>
<span class="nc bnc" id="L239" title="All 2 branches missed.">      return orig == null ? null : endpoint;</span>
    });
  }

  @Override
  public final void bind(SocketAddress endpoint) throws IOException {
<span class="fc" id="L245">    bind(endpoint, 50);</span>
<span class="fc" id="L246">  }</span>

  @SuppressWarnings(&quot;unchecked&quot;)
  @Override
  public final void bind(SocketAddress endpoint, int backlog) throws IOException {
<span class="pc bpc" id="L251" title="1 of 2 branches missed.">    if (isClosed()) {</span>
<span class="nc" id="L252">      throw new SocketException(&quot;Socket is closed&quot;);</span>
    }

    boolean bindErrorOk;
<span class="pc bpc" id="L256" title="1 of 2 branches missed.">    if (bindFilter != null) {</span>
<span class="nc" id="L257">      endpoint = bindFilter.apply(endpoint);</span>
<span class="nc bnc" id="L258" title="All 4 branches missed.">      bindErrorOk = endpoint != null &amp;&amp; isBound();</span>
    } else {
<span class="fc" id="L260">      bindErrorOk = false;</span>
    }

<span class="fc" id="L263">    endpoint = AFSocketAddress.mapOrFail(endpoint);</span>

    A endpointCast;
    try {
<span class="fc" id="L267">      endpointCast = (A) endpoint;</span>
<span class="nc" id="L268">    } catch (ClassCastException e) {</span>
<span class="nc" id="L269">      throw new IllegalArgumentException(&quot;Can only bind to specific endpoints&quot;, e);</span>
<span class="fc" id="L270">    }</span>

    try {
<span class="fc bfc" id="L273" title="All 2 branches covered.">      getAFImpl().bind(endpoint, getReuseAddress() ? NativeUnixSocket.BIND_OPT_REUSE : 0);</span>
<span class="fc" id="L274">    } catch (SocketException e) {</span>
<span class="pc bpc" id="L275" title="1 of 2 branches missed.">      if (bindErrorOk) {</span>
        // force-binding an address could mean double-binding the same address, that's OK.
<span class="nc" id="L277">        return;</span>
      } else {
<span class="fc" id="L279">        throw e;</span>
      }
<span class="fc" id="L281">    }</span>
<span class="fc" id="L282">    setBoundEndpoint(getAFImpl().getLocalSocketAddress());</span>
<span class="pc bpc" id="L283" title="1 of 2 branches missed.">    if (boundEndpoint0() == null) {</span>
<span class="nc" id="L284">      setBoundEndpoint(endpointCast);</span>
    }

<span class="fc bfc" id="L287" title="All 2 branches covered.">    if (endpoint == AFSocketAddress.INTERNAL_DUMMY_BIND) { // NOPMD</span>
<span class="fc" id="L288">      return;</span>
    }

<span class="fc" id="L291">    implementation.listen(backlog);</span>
<span class="fc" id="L292">  }</span>

  @Override
  public final boolean isBound() {
<span class="fc bfc" id="L296" title="All 4 branches covered.">    return boundEndpoint0() != null &amp;&amp; implementation.getFD().valid();</span>
  }

  @Override
  public final boolean isClosed() {
<span class="pc bpc" id="L301" title="1 of 6 branches missed.">    return super.isClosed() || (isBound() &amp;&amp; !implementation.getFD().valid()) || implementation</span>
<span class="fc bfc" id="L302" title="All 2 branches covered.">        .isClosed();</span>
  }

  @Override
  public AFSocket&lt;A&gt; accept() throws IOException {
<span class="fc" id="L307">    return accept1(true);</span>
  }

  AFSocket&lt;A&gt; accept1(boolean throwOnFail) throws IOException {
<span class="fc" id="L311">    AFSocket&lt;A&gt; as = newSocketInstance();</span>

<span class="fc" id="L313">    boolean success = implementation.accept0(as.getAFImpl(false));</span>
<span class="pc bpc" id="L314" title="1 of 2 branches missed.">    if (isClosed()) {</span>
      // We may have connected to the socket to unblock it
<span class="nc" id="L316">      throw new BrokenPipeSocketException(&quot;Socket is closed&quot;);</span>
    }

<span class="fc bfc" id="L319" title="All 2 branches covered.">    if (!success) {</span>
<span class="pc bpc" id="L320" title="1 of 2 branches missed.">      if (throwOnFail) {</span>
<span class="nc bnc" id="L321" title="All 2 branches missed.">        if (getChannel().isBlocking()) {</span>
          // unexpected
<span class="nc" id="L323">          return null;</span>
        } else {
          // non-blocking socket, nothing to accept
<span class="nc" id="L326">          throw new IllegalBlockingModeException();</span>
        }
      } else {
<span class="fc" id="L329">        return null;</span>
      }
    }

<span class="fc" id="L333">    as.getAFImpl(true); // trigger create</span>
<span class="fc" id="L334">    as.connect(AFSocketAddress.INTERNAL_DUMMY_CONNECT);</span>
<span class="fc" id="L335">    as.getAFImpl().updatePorts(getAFImpl().getLocalPort1(), getAFImpl().getRemotePort());</span>

<span class="fc" id="L337">    return as;</span>
  }

  /**
   * Returns a new {@link AFSocket} instance.
   *
   * @return The new instance.
   * @throws IOException on error.
   */
  protected abstract AFSocket&lt;A&gt; newSocketInstance() throws IOException;

  @Override
  public String toString() {
<span class="nc bnc" id="L350" title="All 2 branches missed.">    return getClass().getSimpleName() + &quot;[&quot; + (isBound() ? boundEndpoint0() : &quot;unbound&quot;) + &quot;]&quot;;</span>
  }

  @Override
  public void close() throws IOException {
<span class="fc bfc" id="L355" title="All 2 branches covered.">    if (!closed.compareAndSet(false, true)) {</span>
<span class="fc" id="L356">      return;</span>
    }
<span class="fc bfc" id="L358" title="All 2 branches covered.">    if (isClosed()) {</span>
<span class="fc" id="L359">      return;</span>
    }

<span class="fc" id="L362">    boolean localSocketAddressValid = isLocalSocketAddressValid();</span>

<span class="fc" id="L364">    AFSocketAddress endpoint = boundEndpoint;</span>

<span class="fc" id="L366">    IOException superException = null;</span>
    try {
<span class="fc" id="L368">      super.close();</span>
<span class="nc" id="L369">    } catch (IOException e) {</span>
<span class="nc" id="L370">      superException = e;</span>
<span class="fc" id="L371">    }</span>
<span class="pc bpc" id="L372" title="1 of 2 branches missed.">    if (implementation != null) {</span>
      try {
<span class="fc" id="L374">        implementation.close();</span>
<span class="nc" id="L375">      } catch (IOException e) {</span>
<span class="nc bnc" id="L376" title="All 2 branches missed.">        if (superException == null) {</span>
<span class="nc" id="L377">          superException = e;</span>
        } else {
<span class="nc" id="L379">          superException.addSuppressed(e);</span>
        }
<span class="fc" id="L381">      }</span>
    }

<span class="fc" id="L384">    IOException ex = null;</span>
    try {
<span class="fc" id="L386">      closeables.close(superException);</span>
    } finally {
<span class="pc bpc" id="L388" title="2 of 6 branches missed.">      if (endpoint != null &amp;&amp; endpoint.hasFilename() &amp;&amp; localSocketAddressValid</span>
<span class="pc bpc" id="L389" title="1 of 2 branches missed.">          &amp;&amp; isDeleteOnClose()) {</span>
<span class="fc" id="L390">        File f = endpoint.getFile();</span>
<span class="pc bpc" id="L391" title="1 of 4 branches missed.">        if (!f.delete() &amp;&amp; f.exists()) {</span>
<span class="nc" id="L392">          ex = new IOException(&quot;Could not delete socket file after close: &quot; + f);</span>
        }
      }
    }
<span class="pc bpc" id="L396" title="1 of 2 branches missed.">    if (ex != null) {</span>
<span class="nc" id="L397">      throw ex;</span>
    }
<span class="fc" id="L399">  }</span>

  /**
   * Registers a {@link Closeable} that should be closed when this socket is closed.
   *
   * @param closeable The closeable.
   */
  public final void addCloseable(Closeable closeable) {
<span class="fc" id="L407">    closeables.add(closeable);</span>
<span class="fc" id="L408">  }</span>

  /**
   * Unregisters a previously registered {@link Closeable}.
   *
   * @param closeable The closeable.
   */
  public final void removeCloseable(Closeable closeable) {
<span class="fc" id="L416">    closeables.remove(closeable);</span>
<span class="fc" id="L417">  }</span>

  /**
   * Checks whether everything is setup to support junixsocket sockets.
   *
   * @return {@code true} if supported.
   */
  public static boolean isSupported() {
<span class="fc" id="L425">    return NativeUnixSocket.isLoaded();</span>
  }

  @Override
  @SuppressFBWarnings(&quot;EI_EXPOSE_REP&quot;)
  public final @Nullable A getLocalSocketAddress() {
    @Nullable
<span class="fc" id="L432">    A ep = boundEndpoint0();</span>
<span class="fc bfc" id="L433" title="All 2 branches covered.">    if (ep == null) {</span>
<span class="fc" id="L434">      ep = getAFImpl().getLocalSocketAddress();</span>
<span class="fc" id="L435">      setBoundEndpoint(ep);</span>
    }
<span class="fc" id="L437">    return ep;</span>
  }

  private synchronized @Nullable A boundEndpoint0() {
<span class="fc" id="L441">    return boundEndpoint;</span>
  }

  /**
   * Checks if the local socket address returned by {@link #getLocalSocketAddress()} is still valid.
   *
   * The address is no longer valid if the server socket has been closed, {@code null}, or another
   * server socket has been bound on that address.
   *
   * @return {@code true} iff still valid.
   */
  public boolean isLocalSocketAddressValid() {
<span class="pc bpc" id="L453" title="1 of 2 branches missed.">    if (isClosed()) {</span>
<span class="nc" id="L454">      return false;</span>
    }
    @Nullable
<span class="fc" id="L457">    A addr = getLocalSocketAddress();</span>
<span class="fc bfc" id="L458" title="All 2 branches covered.">    if (addr == null) {</span>
<span class="fc" id="L459">      return false;</span>
    }
<span class="fc" id="L461">    return addr.equals(getAFImpl().getLocalSocketAddress());</span>
  }

  final synchronized void setBoundEndpoint(@Nullable A addr) {
<span class="fc" id="L465">    this.boundEndpoint = addr;</span>
    int port;
<span class="fc bfc" id="L467" title="All 2 branches covered.">    if (addr == null) {</span>
<span class="fc" id="L468">      port = -1;</span>
    } else {
<span class="fc" id="L470">      port = addr.getPort();</span>
    }
<span class="fc" id="L472">    getAFImpl().updatePorts(port, -1);</span>
<span class="fc" id="L473">  }</span>

  @Override
  public final int getLocalPort() {
<span class="pc bpc" id="L477" title="1 of 2 branches missed.">    if (boundEndpoint0() == null) {</span>
<span class="nc" id="L478">      setBoundEndpoint(getAFImpl().getLocalSocketAddress());</span>
    }
<span class="pc bpc" id="L480" title="1 of 2 branches missed.">    if (boundEndpoint0() == null) {</span>
<span class="nc" id="L481">      return -1;</span>
    } else {
<span class="fc" id="L483">      return getAFImpl().getLocalPort1();</span>
    }
  }

  /**
   * Checks if this {@link AFServerSocket}'s file should be removed upon {@link #close()}.
   *
   * Deletion is not guaranteed, especially when not supported (e.g., addresses in the abstract
   * namespace).
   *
   * @return {@code true} if an attempt is made to delete the socket file upon {@link #close()}.
   */
  public final boolean isDeleteOnClose() {
<span class="fc" id="L496">    return deleteOnClose.get();</span>
  }

  /**
   * Enables/disables deleting this {@link AFServerSocket}'s file (or other resource type) upon
   * {@link #close()}.
   *
   * Deletion is not guaranteed, especially when not supported (e.g., addresses in the abstract
   * namespace).
   *
   * @param b Enabled if {@code true}.
   */
  public final void setDeleteOnClose(boolean b) {
<span class="fc" id="L509">    deleteOnClose.set(b);</span>
<span class="fc" id="L510">  }</span>

  final AFSocketImpl&lt;A&gt; getAFImpl() {
<span class="fc bfc" id="L513" title="All 2 branches covered.">    if (created.compareAndSet(false, true)) {</span>
      try {
<span class="fc" id="L515">        getAFImpl().create(true);</span>
<span class="fc" id="L516">        getSoTimeout(); // trigger create via java.net.Socket</span>
<span class="nc" id="L517">      } catch (IOException e) {</span>
        // ignore
<span class="fc" id="L519">      }</span>
    }
<span class="fc" id="L521">    return implementation;</span>
  }

  @SuppressFBWarnings(&quot;EI_EXPOSE_REP&quot;)
  @Override
  public AFServerSocketChannel&lt;A&gt; getChannel() {
<span class="fc" id="L527">    return channel;</span>
  }

  @Override
  public final FileDescriptor getFileDescriptor() throws IOException {
<span class="fc" id="L532">    return implementation.getFileDescriptor();</span>
  }

  /**
   * Returns the address family supported by this implementation.
   *
   * @return The family.
   */
  protected final AFAddressFamily&lt;A&gt; addressFamily() {
<span class="fc" id="L541">    return getAFImpl().getAddressFamily();</span>
  }

  /**
   * Sets the hook for any subsequent call to {@link #bind(SocketAddress)} and
   * {@link #bind(SocketAddress, int)} to be the given function.
   *
   * The function can monitor calls or even alter the endpoint address.
   *
   * @param hook The function that gets called for each {@code bind} call.
   * @return This instance.
   */
  public final AFServerSocket&lt;A&gt; bindHook(SocketAddressFilter hook) {
<span class="nc" id="L554">    this.bindFilter = hook;</span>
<span class="nc" id="L555">    return this;</span>
  }

  @Override
  public InetAddress getInetAddress() {
<span class="nc bnc" id="L560" title="All 2 branches missed.">    if (!isBound()) {</span>
<span class="nc" id="L561">      return null;</span>
    } else {
<span class="nc" id="L563">      return getAFImpl().getInetAddress();</span>
    }
  }

  @Override
  public synchronized void setReceiveBufferSize(int size) throws SocketException {
<span class="nc bnc" id="L569" title="All 2 branches missed.">    if (size &lt;= 0) {</span>
<span class="nc" id="L570">      throw new IllegalArgumentException(&quot;receive buffer size must be a positive number&quot;);</span>
    }
<span class="nc bnc" id="L572" title="All 2 branches missed.">    if (isClosed()) {</span>
<span class="nc" id="L573">      throw new SocketException(&quot;Socket is closed&quot;);</span>
    }
<span class="nc" id="L575">    getAFImpl().setOption(SocketOptions.SO_RCVBUF, size);</span>
<span class="nc" id="L576">  }</span>

  @Override
  public synchronized int getReceiveBufferSize() throws SocketException {
<span class="pc bpc" id="L580" title="1 of 2 branches missed.">    if (isClosed()) {</span>
<span class="nc" id="L581">      throw new SocketException(&quot;Socket is closed&quot;);</span>
    }
<span class="fc" id="L583">    int result = 0;</span>
<span class="fc" id="L584">    Object o = getAFImpl().getOption(SocketOptions.SO_RCVBUF);</span>
<span class="pc bpc" id="L585" title="1 of 2 branches missed.">    if (o instanceof Number) {</span>
<span class="fc" id="L586">      result = ((Number) o).intValue();</span>
    }
<span class="fc" id="L588">    return result;</span>
  }

  @Override
  @SuppressWarnings(&quot;UnsynchronizedOverridesSynchronized&quot; /* errorprone */)
  public void setSoTimeout(int timeout) throws SocketException {
<span class="pc bpc" id="L594" title="1 of 2 branches missed.">    if (isClosed()) {</span>
<span class="nc" id="L595">      throw new SocketException(&quot;Socket is closed&quot;);</span>
    }
<span class="pc bpc" id="L597" title="1 of 2 branches missed.">    if (timeout &lt; 0) {</span>
<span class="nc" id="L598">      throw new IllegalArgumentException(&quot;timeout &lt; 0&quot;);</span>
    }
<span class="fc" id="L600">    getAFImpl().setOption(SocketOptions.SO_TIMEOUT, timeout);</span>
<span class="fc" id="L601">  }</span>

  @Override
  @SuppressWarnings(&quot;UnsynchronizedOverridesSynchronized&quot; /* errorprone */)
  public int getSoTimeout() throws IOException {
<span class="pc bpc" id="L606" title="1 of 2 branches missed.">    if (isClosed()) {</span>
<span class="nc" id="L607">      throw new SocketException(&quot;Socket is closed&quot;);</span>
    }
<span class="fc" id="L609">    Object o = getAFImpl().getOption(SocketOptions.SO_TIMEOUT);</span>
    /* extra type safety */
<span class="pc bpc" id="L611" title="1 of 2 branches missed.">    if (o instanceof Number) {</span>
<span class="fc" id="L612">      return ((Number) o).intValue();</span>
    } else {
<span class="nc" id="L614">      return 0;</span>
    }
  }

  @Override
  public void setReuseAddress(boolean on) throws SocketException {
<span class="pc bpc" id="L620" title="1 of 2 branches missed.">    if (isClosed()) {</span>
<span class="nc" id="L621">      throw new SocketException(&quot;Socket is closed&quot;);</span>
    }
<span class="fc" id="L623">    getAFImpl().setOption(SocketOptions.SO_REUSEADDR, on);</span>
<span class="fc" id="L624">  }</span>

  @Override
  public boolean getReuseAddress() throws SocketException {
<span class="pc bpc" id="L628" title="1 of 2 branches missed.">    if (isClosed()) {</span>
<span class="nc" id="L629">      throw new SocketException(&quot;Socket is closed&quot;);</span>
    }
<span class="fc" id="L631">    return ((Boolean) (getAFImpl().getOption(SocketOptions.SO_REUSEADDR)));</span>
  }

  @Override
  public void setPerformancePreferences(int connectionTime, int latency, int bandwidth) {
<span class="nc" id="L636">  }</span>

  @SuppressWarnings({&quot;all&quot;, &quot;MissingOverride&quot; /* errorprone */})
  public &lt;T&gt; T getOption(SocketOption&lt;T&gt; name) throws IOException {
<span class="fc" id="L640">    Objects.requireNonNull(name);</span>
<span class="pc bpc" id="L641" title="1 of 2 branches missed.">    if (isClosed()) {</span>
<span class="nc" id="L642">      throw new SocketException(&quot;Socket is closed&quot;);</span>
    }
<span class="fc" id="L644">    return getAFImpl().getOption(name);</span>
  }

  @SuppressWarnings({&quot;all&quot;, &quot;MissingOverride&quot; /* errorprone */})
  public &lt;T&gt; ServerSocket setOption(SocketOption&lt;T&gt; name, T value) throws IOException {
<span class="fc" id="L649">    Objects.requireNonNull(name);</span>
<span class="pc bpc" id="L650" title="1 of 2 branches missed.">    if (isClosed()) {</span>
<span class="nc" id="L651">      throw new SocketException(&quot;Socket is closed&quot;);</span>
    }
<span class="fc" id="L653">    getAFImpl().setOption(name, value);</span>
<span class="fc" id="L654">    return this;</span>
  }

  @SuppressWarnings(&quot;all&quot;)
  public Set&lt;SocketOption&lt;?&gt;&gt; supportedOptions() {
<span class="fc" id="L659">    return getAFImpl().supportedOptions();</span>
  }

  @Override
  public void setShutdownOnClose(boolean enabled) {
<span class="nc" id="L664">    getAFImpl().getCore().setShutdownOnClose(enabled);</span>
<span class="nc" id="L665">  }</span>

  // NOTE: We shall re-implement all methods defined in ServerSocket that internally call getImpl()
  // and call getAFImpl() here. This is not strictly necessary for environments where we can
  // override &quot;impl&quot;; however it's the right thing to do.
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>