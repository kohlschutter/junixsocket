<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>AFSocket.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">junixsocket-codecoverage</a> &gt; <a href="../index.html" class="el_bundle">junixsocket-common</a> &gt; <a href="index.source.html" class="el_package">org.newsclub.net.unix</a> &gt; <span class="el_source">AFSocket.java</span></div><h1>AFSocket.java</h1><pre class="source lang-java linenums">/*
 * junixsocket
 *
 * Copyright 2009-2022 Christian Kohlschütter
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.newsclub.net.unix;

import java.io.Closeable;
import java.io.FileDescriptor;
import java.io.IOException;
import java.net.Socket;
import java.net.SocketAddress;
import java.net.SocketException;
import java.net.SocketImpl;
import java.util.concurrent.atomic.AtomicBoolean;

import org.eclipse.jdt.annotation.NonNull;
import org.eclipse.jdt.annotation.Nullable;

import com.kohlschutter.annotations.compiletime.SuppressFBWarnings;

/**
 * junixsocket's base implementation of a {@link Socket}.
 * 
 * @param &lt;A&gt; The concrete {@link AFSocketAddress} that is supported by this type.
 * @author Christian Kohlschütter
 */
public abstract class AFSocket&lt;A extends AFSocketAddress&gt; extends Socket implements AFSomeSocket,
    AFSocketExtensions {
  static final String PROP_LIBRARY_DISABLE_CAPABILITY_PREFIX =
      &quot;org.newsclub.net.unix.library.disable.&quot;;

<span class="fc" id="L45">  private static final byte[] ZERO_BYTES = new byte[0];</span>

  @SuppressWarnings(&quot;PMD.MutableStaticState&quot;)
  static String loadedLibrary; // set by NativeLibraryLoader

<span class="fc" id="L50">  private static final int CAPABILITIES = initCapabilities();</span>

  private final AFSocketImpl&lt;A&gt; impl;

  private final AFSocketAddressFromHostname&lt;A&gt; afh;
<span class="fc" id="L55">  private final Closeables closeables = new Closeables();</span>
<span class="fc" id="L56">  private final AtomicBoolean created = new AtomicBoolean(false);</span>
<span class="fc" id="L57">  private final AFSocketChannel&lt;A&gt; channel = newChannel();</span>

  private @Nullable SocketAddressFilter connectFilter;

  /**
   * Creates a new {@link AFSocket} instance.
   * 
   * @param impl The corresponding {@link SocketImpl} class.
   * @param afh The conversion helper to get a socket address from an encoded hostname.
   * @throws SocketException on error.
   */
  protected AFSocket(final AFSocketImpl&lt;A&gt; impl, AFSocketAddressFromHostname&lt;A&gt; afh)
      throws SocketException {
<span class="fc" id="L70">    super(impl);</span>
<span class="fc" id="L71">    this.afh = afh;</span>
<span class="fc" id="L72">    this.impl = impl;</span>
<span class="fc" id="L73">  }</span>

  /**
   * Returns the {@link AFSocketAddress} type supported by this socket.
   * 
   * @return The supported {@link AFSocketAddress}.
   */
  protected final Class&lt;? extends AFSocketAddress&gt; socketAddressClass() {
<span class="fc" id="L81">    return getAFImpl(false).getAddressFamily().getSocketAddressClass();</span>
  }

  /**
   * Creates a new {@link AFSocketChannel} for this socket.
   * 
   * @return The new instance.
   */
  protected abstract AFSocketChannel&lt;A&gt; newChannel();

  /**
   * The reference to the constructor of an {@link AFSocket} subclass.
   * 
   * @param &lt;A&gt; The concrete {@link AFSocketAddress} that is supported by this type.
   */
  @FunctionalInterface
  public interface Constructor&lt;A extends AFSocketAddress&gt; {
    /**
     * Constructs a new {@link AFSocket} subclass instance.
     * 
     * @param fdObj The file descriptor.
     * @param factory The socket factory instance.
     * @return The instance.
     * @throws SocketException on error.
     */
    @NonNull
    AFSocket&lt;A&gt; newInstance(FileDescriptor fdObj, AFSocketFactory&lt;A&gt; factory)
        throws SocketException;
  }

  static &lt;A extends AFSocketAddress&gt; AFSocket&lt;A&gt; newInstance(Constructor&lt;A&gt; constr,
      AFSocketFactory&lt;A&gt; sf, FileDescriptor fdObj, int localPort, int remotePort)
      throws IOException {
<span class="pc bpc" id="L114" title="1 of 2 branches missed.">    if (!fdObj.valid()) {</span>
<span class="nc" id="L115">      throw new SocketException(&quot;Invalid file descriptor&quot;);</span>
    }
<span class="fc" id="L117">    int status = NativeUnixSocket.socketStatus(fdObj);</span>
<span class="pc bpc" id="L118" title="1 of 2 branches missed.">    if (status == NativeUnixSocket.SOCKETSTATUS_INVALID) {</span>
<span class="nc" id="L119">      throw new SocketException(&quot;Not a valid socket&quot;);</span>
    }

<span class="fc" id="L122">    AFSocket&lt;A&gt; socket = newInstance0(constr, fdObj, sf);</span>
<span class="fc" id="L123">    socket.getAFImpl().updatePorts(localPort, remotePort);</span>

<span class="pc bpc" id="L125" title="2 of 4 branches missed.">    switch (status) {</span>
      case NativeUnixSocket.SOCKETSTATUS_CONNECTED:
<span class="fc" id="L127">        socket.internalDummyConnect();</span>
<span class="fc" id="L128">        break;</span>
      case NativeUnixSocket.SOCKETSTATUS_BOUND:
<span class="fc" id="L130">        socket.internalDummyBind();</span>
<span class="fc" id="L131">        break;</span>
      case NativeUnixSocket.SOCKETSTATUS_UNKNOWN:
<span class="nc" id="L133">        break;</span>
      default:
<span class="nc" id="L135">        throw new IllegalStateException(&quot;Invalid socketStatus response: &quot; + status);</span>
    }
<span class="fc" id="L137">    socket.getAFImpl().setSocketAddress(socket.getLocalSocketAddress());</span>

<span class="fc" id="L139">    return socket;</span>
  }

  /**
   * Creates a new, unbound {@link AFSocket}.
   * 
   * This &quot;default&quot; implementation is a bit &quot;lenient&quot; with respect to the specification.
   * 
   * In particular, we may ignore calls to {@link Socket#getTcpNoDelay()} and
   * {@link Socket#setTcpNoDelay(boolean)}.
   * 
   * @param &lt;A&gt; The corresponding address type.
   * @param constr The implementation's {@link AFSocket} constructor
   * @param factory The corresponding socket factory, or {@code null}.
   * @return A new, unbound socket.
   * @throws SocketException if the operation fails.
   */
  protected static final &lt;A extends AFSocketAddress&gt; AFSocket&lt;A&gt; newInstance(Constructor&lt;A&gt; constr,
      AFSocketFactory&lt;A&gt; factory) throws SocketException {
<span class="fc" id="L158">    return newInstance0(constr, null, factory);</span>
  }

  private static &lt;A extends AFSocketAddress&gt; @NonNull AFSocket&lt;A&gt; newInstance0(
      Constructor&lt;A&gt; constr, FileDescriptor fdObj, AFSocketFactory&lt;A&gt; factory)
      throws SocketException {
<span class="fc" id="L164">    return constr.newInstance(fdObj, factory);</span>
  }

  /**
   * Creates a new {@link AFSocket} and connects it to the given {@link AFSocketAddress}.
   * 
   * @param &lt;A&gt; The corresponding address type.
   * @param constr The implementation's {@link AFSocket} constructor
   * @param addr The address to connect to.
   * @return A new, connected socket.
   * @throws IOException if the operation fails.
   */
  protected static final &lt;A extends AFSocketAddress&gt; @NonNull AFSocket&lt;A&gt; connectTo(
      Constructor&lt;A&gt; constr, A addr) throws IOException {
<span class="fc" id="L178">    AFSocket&lt;A&gt; socket = constr.newInstance(null, null);</span>
<span class="fc" id="L179">    socket.connect(addr);</span>
<span class="fc" id="L180">    return socket;</span>
  }

  /**
   * Creates a new {@link AFSocket} and connects it to the given {@link AFSocketAddress} using the
   * default implementation suited for that address type.
   * 
   * @param &lt;A&gt; The corresponding address type.
   * @param addr The address to connect to.
   * @return A new, connected socket.
   * @throws IOException if the operation fails.
   */
  public static final &lt;A extends AFSocketAddress&gt; AFSocket&lt;?&gt; connectTo(@NonNull A addr)
      throws IOException {
<span class="fc" id="L194">    AFSocket&lt;?&gt; socket = addr.getAddressFamily().getSocketConstructor().newInstance(null, null);</span>
<span class="fc" id="L195">    socket.connect(addr);</span>
<span class="fc" id="L196">    return socket;</span>
  }

  /**
   * Not supported, since it's not necessary for client sockets.
   * 
   * @see AFServerSocket
   */
  @Override
  public final void bind(SocketAddress bindpoint) throws IOException {
<span class="pc bpc" id="L206" title="1 of 2 branches missed.">    if (bindpoint == null) {</span>
<span class="fc" id="L207">      throw new IllegalArgumentException();</span>
    }
<span class="nc bnc" id="L209" title="All 2 branches missed.">    if (isClosed()) {</span>
<span class="nc" id="L210">      throw new SocketException(&quot;Socket is closed&quot;);</span>
    }
<span class="nc bnc" id="L212" title="All 2 branches missed.">    if (isBound()) {</span>
<span class="nc" id="L213">      throw new SocketException(&quot;Already bound&quot;);</span>
    }
<span class="nc" id="L215">    preprocessSocketAddress(bindpoint);</span>
<span class="nc" id="L216">    throw new SocketException(&quot;Use AF*ServerSocket#bind or #bindOn&quot;);</span>
  }

  @Override
  public final boolean isBound() {
<span class="fc bfc" id="L221" title="All 6 branches covered.">    return impl.getFD().valid() &amp;&amp; (super.isBound() || impl.isBound());</span>
  }

  @Override
  public final boolean isConnected() {
<span class="pc bpc" id="L226" title="1 of 6 branches missed.">    return impl.getFD().valid() &amp;&amp; (super.isConnected() || impl.isConnected());</span>
  }

  @Override
  public final void connect(SocketAddress endpoint) throws IOException {
<span class="fc" id="L231">    connect(endpoint, 0);</span>
<span class="fc" id="L232">  }</span>

  @Override
  public final void connect(SocketAddress endpoint, int timeout) throws IOException {
<span class="fc" id="L236">    connect0(endpoint, timeout);</span>
<span class="fc" id="L237">  }</span>

  private AFSocketAddress preprocessSocketAddress(SocketAddress endpoint) throws SocketException {
<span class="fc bfc" id="L240" title="All 2 branches covered.">    if (endpoint == null) {</span>
<span class="fc" id="L241">      throw new IllegalArgumentException(&quot;endpoint is null&quot;);</span>
<span class="fc bfc" id="L242" title="All 2 branches covered.">    } else if (endpoint instanceof SentinelSocketAddress) {</span>
<span class="fc" id="L243">      return (AFSocketAddress) endpoint;</span>
    } else {
<span class="fc" id="L245">      return AFSocketAddress.preprocessSocketAddress(socketAddressClass(), endpoint, afh);</span>
    }
  }

  final boolean connect0(SocketAddress endpoint, int timeout) throws IOException {
<span class="fc bfc" id="L250" title="All 2 branches covered.">    if (timeout &lt; 0) {</span>
<span class="fc" id="L251">      throw new IllegalArgumentException(&quot;connect: timeout can't be negative&quot;);</span>
    }
<span class="pc bpc" id="L253" title="1 of 2 branches missed.">    if (isClosed()) {</span>
<span class="nc" id="L254">      throw new SocketException(&quot;Socket is closed&quot;);</span>
    }

<span class="fc bfc" id="L257" title="All 2 branches covered.">    if (connectFilter != null) {</span>
<span class="fc" id="L258">      endpoint = connectFilter.apply(endpoint);</span>
    }

<span class="fc" id="L261">    AFSocketAddress address = preprocessSocketAddress(endpoint);</span>

<span class="fc bfc" id="L263" title="All 2 branches covered.">    if (!isBound()) {</span>
<span class="fc" id="L264">      internalDummyBind();</span>
    }

<span class="fc" id="L267">    boolean success = getAFImpl().connect0(address, timeout);</span>
<span class="pc bpc" id="L268" title="1 of 2 branches missed.">    if (success) {</span>
<span class="fc" id="L269">      int port = address.getPort();</span>
<span class="fc bfc" id="L270" title="All 2 branches covered.">      if (port &gt; 0) {</span>
<span class="fc" id="L271">        getAFImpl().updatePorts(getLocalPort(), port);</span>
      }
    }
<span class="fc" id="L274">    internalDummyConnect();</span>
<span class="fc" id="L275">    return success;</span>
  }

  final void internalDummyConnect() throws IOException {
<span class="pc bpc" id="L279" title="1 of 2 branches missed.">    if (!isConnected()) {</span>
<span class="nc" id="L280">      super.connect(AFSocketAddress.INTERNAL_DUMMY_CONNECT, 0);</span>
    }
<span class="fc" id="L282">  }</span>

  final void internalDummyBind() throws IOException {
<span class="fc bfc" id="L285" title="All 2 branches covered.">    if (!isBound()) {</span>
<span class="fc" id="L286">      super.bind(AFSocketAddress.INTERNAL_DUMMY_BIND);</span>
    }
<span class="fc" id="L288">  }</span>

  @Override
  public final String toString() {
<span class="fc" id="L292">    return getClass().getName() + &quot;@&quot; + Integer.toHexString(hashCode()) + toStringSuffix();</span>
  }

  final String toStringSuffix() {
<span class="fc bfc" id="L296" title="All 2 branches covered.">    if (impl.getFD().valid()) {</span>
<span class="fc" id="L297">      return &quot;[local=&quot; + getLocalSocketAddress() + &quot;;remote=&quot; + getRemoteSocketAddress() + &quot;]&quot;;</span>
    } else {
<span class="fc" id="L299">      return &quot;[invalid]&quot;;</span>
    }
  }

  /**
   * Returns &lt;code&gt;true&lt;/code&gt; iff {@link AFSocket}s are supported by the current Java VM.
   * 
   * To support {@link AFSocket}s, a custom JNI library must be loaded that is supplied with
   * &lt;em&gt;junixsocket&lt;/em&gt;.
   * 
   * @return {@code true} iff supported.
   */
  public static boolean isSupported() {
<span class="fc" id="L312">    return NativeUnixSocket.isLoaded();</span>
  }

  /**
   * Checks if {@link AFSocket}s are supported by the current Java VM.
   * 
   * If not, an {@link UnsupportedOperationException} is thrown.
   * 
   * @throws UnsupportedOperationException if not supported.
   */
  public static void ensureSupported() throws UnsupportedOperationException {
<span class="nc" id="L323">    NativeUnixSocket.ensureSupported();</span>
<span class="nc" id="L324">  }</span>

  /**
   * Returns the version of the junixsocket library, as a string, for debugging purposes.
   * 
   * NOTE: Do not rely on the format of the version identifier, use socket capabilities instead.
   * 
   * @return String The version identifier, or {@code null} if it could not be determined.
   * @see #supports(AFSocketCapability)
   */
  public static final String getVersion() {
    try {
<span class="fc" id="L336">      return NativeLibraryLoader.getJunixsocketVersion();</span>
<span class="fc" id="L337">    } catch (IOException e) {</span>
<span class="fc" id="L338">      return null;</span>
    }
  }

  /**
   * Returns an identifier of the loaded native library, or {@code null} if the library hasn't been
   * loaded yet.
   * 
   * The identifier is useful mainly for debugging purposes.
   * 
   * @return The identifier of the loaded junixsocket-native library, or {@code null}.
   */
  public static final String getLoadedLibrary() {
<span class="fc" id="L351">    return loadedLibrary;</span>
  }

  @Override
  public final boolean isClosed() {
<span class="pc bpc" id="L356" title="1 of 8 branches missed.">    return super.isClosed() || (isConnected() &amp;&amp; !impl.getFD().valid()) || impl.isClosed();</span>
  }

  @Override
  public final int getAncillaryReceiveBufferSize() {
<span class="fc" id="L361">    return impl.getAncillaryReceiveBufferSize();</span>
  }

  @Override
  public final void setAncillaryReceiveBufferSize(int size) {
<span class="fc" id="L366">    impl.setAncillaryReceiveBufferSize(size);</span>
<span class="fc" id="L367">  }</span>

  @Override
  public final void ensureAncillaryReceiveBufferSize(int minSize) {
<span class="fc" id="L371">    impl.ensureAncillaryReceiveBufferSize(minSize);</span>
<span class="fc" id="L372">  }</span>

  private static int initCapabilities() {
<span class="fc bfc" id="L375" title="All 2 branches covered.">    if (!isSupported()) {</span>
<span class="fc" id="L376">      return 0;</span>
    } else {
<span class="fc" id="L378">      int v = NativeUnixSocket.capabilities();</span>

<span class="pc bpc" id="L380" title="1 of 2 branches missed.">      if (System.getProperty(&quot;osv.version&quot;) != null) {</span>
        // no fork, no redirect...
<span class="nc" id="L382">        v &amp;= ~(AFSocketCapability.CAPABILITY_FD_AS_REDIRECT.getBitmask());</span>
      }

<span class="fc bfc" id="L385" title="All 2 branches covered.">      for (AFSocketCapability cap : AFSocketCapability.values()) {</span>
<span class="pc bpc" id="L386" title="1 of 2 branches missed.">        if (isCapDisabled(cap)) {</span>
<span class="nc" id="L387">          v &amp;= ~(cap.getBitmask());</span>
        }
      }

<span class="fc" id="L391">      return v;</span>
    }
  }

  private static boolean isCapDisabled(AFSocketCapability cap) {
<span class="fc" id="L396">    return Boolean.valueOf(System.getProperty(PROP_LIBRARY_DISABLE_CAPABILITY_PREFIX + cap.name(),</span>
        &quot;false&quot;));
  }

  /**
   * Checks if the current environment (system platform, native library, etc.) supports a given
   * junixsocket capability.
   * 
   * Deprecated. Please use {@link #supports(AFSocketCapability)} instead.
   * 
   * NOTE: The result may or may not be cached from a previous call or from a check upon
   * initialization.
   * 
   * @param capability The capability.
   * @return true if supported.
   * @see #supports(AFSocketCapability)
   */
  @Deprecated
  public static final boolean supports(AFUNIXSocketCapability capability) {
<span class="nc bnc" id="L415" title="All 2 branches missed.">    return (CAPABILITIES &amp; capability.getBitmask()) != 0;</span>
  }

  /**
   * Checks if the current environment (system platform, native library, etc.) supports a given
   * junixsocket capability.
   * 
   * NOTE: The result may or may not be cached from a previous call or from a check upon
   * initialization.
   * 
   * @param capability The capability.
   * @return true if supported.
   */
  public static final boolean supports(AFSocketCapability capability) {
<span class="fc bfc" id="L429" title="All 2 branches covered.">    return (CAPABILITIES &amp; capability.getBitmask()) != 0;</span>
  }

  @Override
  public final synchronized void close() throws IOException {
<span class="fc" id="L434">    IOException superException = null;</span>
    try {
<span class="fc" id="L436">      super.close();</span>
<span class="nc" id="L437">    } catch (IOException e) {</span>
<span class="nc" id="L438">      superException = e;</span>
<span class="fc" id="L439">    }</span>
<span class="fc" id="L440">    closeables.close(superException);</span>
<span class="fc" id="L441">  }</span>

  /**
   * Registers a {@link Closeable} that should be closed when this socket is closed.
   * 
   * @param closeable The closeable.
   */
  public final void addCloseable(Closeable closeable) {
<span class="fc" id="L449">    closeables.add(closeable);</span>
<span class="fc" id="L450">  }</span>

  /**
   * Unregisters a previously registered {@link Closeable}.
   * 
   * @param closeable The closeable.
   */
  public final void removeCloseable(Closeable closeable) {
<span class="fc" id="L458">    closeables.remove(closeable);</span>
<span class="fc" id="L459">  }</span>

  final AFSocketImpl&lt;A&gt; getAFImpl() {
<span class="fc" id="L462">    return getAFImpl(true);</span>
  }

  final AFSocketImpl&lt;A&gt; getAFImpl(boolean createSocket) {
<span class="fc bfc" id="L466" title="All 4 branches covered.">    if (createSocket &amp;&amp; created.compareAndSet(false, true)) {</span>
      try {
<span class="fc" id="L468">        getSoTimeout(); // trigger create via java.net.Socket</span>
<span class="nc" id="L469">      } catch (SocketException e) {</span>
        // ignore
<span class="fc" id="L471">      }</span>
    }
<span class="fc" id="L473">    return impl;</span>
  }

  @SuppressFBWarnings(&quot;EI_EXPOSE_REP&quot;)
  @Override
  public AFSocketChannel&lt;A&gt; getChannel() {
<span class="fc" id="L479">    return channel;</span>
  }

  @SuppressWarnings(&quot;null&quot;)
  @Override
  public final synchronized A getRemoteSocketAddress() {
<span class="fc bfc" id="L485" title="All 2 branches covered.">    if (!isConnected()) {</span>
<span class="fc" id="L486">      return null;</span>
    }
<span class="fc" id="L488">    return impl.getRemoteSocketAddress();</span>
  }

  @SuppressWarnings(&quot;null&quot;)
  @Override
  public final A getLocalSocketAddress() {
<span class="pc bpc" id="L494" title="1 of 2 branches missed.">    if (isClosed()) {</span>
<span class="nc" id="L495">      return null;</span>
    }
<span class="fc" id="L497">    return impl.getLocalSocketAddress();</span>
  }

  @Override
  public final FileDescriptor getFileDescriptor() throws IOException {
<span class="fc" id="L502">    return impl.getFileDescriptor();</span>
  }

  @Override
  public final AFInputStream getInputStream() throws IOException {
<span class="fc" id="L507">    return getAFImpl().getInputStream();</span>
  }

  @Override
  public final AFOutputStream getOutputStream() throws IOException {
<span class="fc" id="L512">    return getAFImpl().getOutputStream();</span>
  }

  /**
   * Returns the internal helper instance for address-specific extensions.
   * 
   * @return The helper instance.
   * @throws UnsupportedOperationException if such extensions are not supported for this address
   *           type.
   */
  protected final AFSocketImplExtensions&lt;A&gt; getImplExtensions() {
<span class="nc" id="L523">    return getAFImpl(false).getImplExtensions();</span>
  }

  /**
   * Forces the address to be used for any subsequent call to {@link #connect(SocketAddress)} to be
   * the given one, regardless of what'll be passed there.
   * 
   * @param endpoint The forced endpoint address.
   * @return This instance.
   */
  public final AFSocket&lt;A&gt; forceConnectAddress(SocketAddress endpoint) {
<span class="fc" id="L534">    return connectHook((SocketAddress orig) -&gt; {</span>
<span class="pc bpc" id="L535" title="1 of 2 branches missed.">      return orig == null ? null : endpoint;</span>
    });
  }

  /**
   * Sets the hook for any subsequent call to {@link #connect(SocketAddress)} or
   * {@link #connect(SocketAddress, int)} to be the given function.
   * 
   * The function can monitor events or even alter the target address.
   * 
   * @param hook The function that gets called for each connect call.
   * @return This instance.
   */
  public final AFSocket&lt;A&gt; connectHook(SocketAddressFilter hook) {
<span class="fc" id="L549">    this.connectFilter = hook;</span>
<span class="fc" id="L550">    return this;</span>
  }

  /**
   * Probes the status of the socket connection.
   * 
   * This usually involves checking for {@link #isConnected()}, and if assumed connected, also
   * sending a zero-length message to the remote.
   * 
   * @return {@code true} if the connection is known to be closed, {@code false} if the connection
   *         is open/not closed or the condition is unknown.
   * @throws IOException on an unexpected error.
   */
  public boolean checkConnectionClosed() throws IOException {
<span class="pc bpc" id="L564" title="1 of 2 branches missed.">    if (!isConnected()) {</span>
<span class="nc" id="L565">      return true;</span>
    }
    try {
<span class="pc bpc" id="L568" title="1 of 2 branches missed.">      if (!AFSocket.supports(AFSocketCapability.CAPABILITY_ZERO_LENGTH_SEND)) {</span>
<span class="nc" id="L569">        return false;</span>
      }
<span class="fc" id="L571">      getOutputStream().write(ZERO_BYTES);</span>
<span class="fc" id="L572">      return false;</span>
<span class="nc" id="L573">    } catch (SocketClosedException e) {</span>
<span class="nc" id="L574">      return true;</span>
<span class="nc" id="L575">    } catch (IOException e) {</span>
<span class="nc bnc" id="L576" title="All 2 branches missed.">      if (!isConnected()) {</span>
<span class="nc" id="L577">        return true;</span>
      } else {
<span class="nc" id="L579">        throw e;</span>
      }
    }
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>