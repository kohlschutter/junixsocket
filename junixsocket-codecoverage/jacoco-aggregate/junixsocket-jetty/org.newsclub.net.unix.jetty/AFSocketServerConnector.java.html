<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>AFSocketServerConnector.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">junixsocket-codecoverage</a> &gt; <a href="../index.html" class="el_bundle">junixsocket-jetty</a> &gt; <a href="index.source.html" class="el_package">org.newsclub.net.unix.jetty</a> &gt; <span class="el_source">AFSocketServerConnector.java</span></div><h1>AFSocketServerConnector.java</h1><pre class="source lang-java linenums">/*
 * junixsocket
 *
 * Copyright 2009-2024 Christian Kohlsch√ºtter
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
//
// based upon jetty-unixdomain-server
// original copyright message from jetty's UnixDomainServerConnector:
//
// ========================================================================
// Copyright (c) 1995-2022 Mort Bay Consulting Pty Ltd and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// https://www.eclipse.org/legal/epl-2.0, or the Apache License, Version 2.0
// which is available at https://www.apache.org/licenses/LICENSE-2.0.
//
// SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
// ========================================================================
//

package org.newsclub.net.unix.jetty;

import java.io.Closeable;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.net.SocketException;
import java.net.StandardSocketOptions;
import java.nio.channels.Channel;
import java.nio.channels.ClosedByInterruptException;
import java.nio.channels.SelectableChannel;
import java.nio.channels.SelectionKey;
import java.nio.channels.Selector;
import java.nio.channels.ServerSocketChannel;
import java.nio.channels.SocketChannel;
import java.nio.channels.spi.SelectorProvider;
import java.nio.file.Path;
import java.util.EventListener;
import java.util.Locale;
import java.util.concurrent.Executor;
import java.util.concurrent.ForkJoinPool;
import java.util.concurrent.atomic.AtomicReference;

import org.eclipse.jetty.io.ByteBufferPool;
import org.eclipse.jetty.io.Connection;
import org.eclipse.jetty.io.EndPoint;
import org.eclipse.jetty.io.ManagedSelector;
import org.eclipse.jetty.io.SelectorManager;
import org.eclipse.jetty.io.SocketChannelEndPoint;
import org.eclipse.jetty.server.AbstractConnector;
import org.eclipse.jetty.server.ConnectionFactory;
import org.eclipse.jetty.server.Connector;
import org.eclipse.jetty.server.HttpConnectionFactory;
import org.eclipse.jetty.server.Server;
import org.eclipse.jetty.util.IO;
import org.eclipse.jetty.util.annotation.ManagedAttribute;
import org.eclipse.jetty.util.annotation.ManagedObject;
import org.eclipse.jetty.util.thread.ScheduledExecutorScheduler;
import org.eclipse.jetty.util.thread.Scheduler;
import org.newsclub.net.unix.AFServerSocketChannel;
import org.newsclub.net.unix.AFSocketAddress;
import org.newsclub.net.unix.AFUNIXSocketAddress;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.kohlschutter.annotations.compiletime.SuppressFBWarnings;

/**
 * A {@link Connector} implementation for junixsocket server socket channels (Unix domains etc.)
 *
 * Based upon jetty's UnixDomainServerConnector.
 *
 * This implementation should work with jetty version 9.4.12 or newer.
 */
@ManagedObject
@SuppressWarnings(&quot;PMD.CouplingBetweenObjects&quot;)
public class AFSocketServerConnector extends AbstractConnector {
<span class="fc" id="L90">  private static final Logger LOG = LoggerFactory.getLogger(AbstractConnector.class);</span>

<span class="fc" id="L92">  private final AtomicReference&lt;Closeable&gt; acceptor = new AtomicReference&lt;&gt;();</span>
  private final SelectorManager selectorManager;
  private ServerSocketChannel serverChannel;
  private AFSocketAddress listenSocketAddress;
  private boolean inheritChannel;
  private int acceptQueueSize;
  private int acceptedReceiveBufferSize;
  private int acceptedSendBufferSize;

<span class="fc" id="L101">  private boolean mayStopServer = false;</span>
<span class="fc" id="L102">  private boolean mayStopServerForce = false;</span>
  private final Class&lt;? extends EventListener&gt; selectorManagerListenerClass;
  private final Server server;

  /**
   * Creates a new {@link AFSocketServerConnector}.
   *
   * @param server The server this connector will be added to. Must not be null.
   * @param factories The Connection Factories to use.
   */
  public AFSocketServerConnector(Server server, ConnectionFactory... factories) {
<span class="fc" id="L113">    this(server, null, null, null, -1, -1, factories);</span>
<span class="fc" id="L114">  }</span>

  /**
   * Creates a new {@link AFSocketServerConnector}.
   *
   * @param server The server this connector will be added to. Must not be null.
   * @param acceptors the number of acceptor threads to use, or -1 for a default value. If 0, then
   *          no acceptor threads will be launched and some other mechanism will need to be used to
   *          accept new connections.
   * @param selectors The number of selectors to use, or -1 for a default derived
   * @param factories The Connection Factories to use.
   */
  public AFSocketServerConnector(Server server, int acceptors, int selectors,
      ConnectionFactory... factories) {
<span class="fc" id="L128">    this(server, null, null, null, acceptors, selectors, factories);</span>
<span class="fc" id="L129">  }</span>

  /**
   * Creates a new {@link AFSocketServerConnector}.
   *
   * @param server The server this connector will be added to. Must not be null.
   * @param executor An executor for this connector or null to use the servers executor
   * @param scheduler A scheduler for this connector or null to either a {@link Scheduler} set as a
   *          server bean or if none set, then a new {@link ScheduledExecutorScheduler} instance.
   * @param pool A buffer pool for this connector or null to either a {@link ByteBufferPool} set as
   *          a server bean or none set, the new {code ArrayByteBufferPool} instance.
   * @param acceptors the number of acceptor threads to use, or -1 for a default value. If 0, then
   *          no acceptor threads will be launched and some other mechanism will need to be used to
   *          accept new connections.
   * @param selectors The number of selectors to use, or -1 for a default derived
   * @param factories The Connection Factories to use.
   */
  @SuppressFBWarnings(&quot;EI_EXPOSE_REP2&quot;)
  @SuppressWarnings(&quot;PMD.ConstructorCallsOverridableMethod&quot;)
  public AFSocketServerConnector(Server server, Executor executor, Scheduler scheduler,
      ByteBufferPool pool, int acceptors, int selectors, ConnectionFactory... factories) {
<span class="pc bpc" id="L150" title="1 of 2 branches missed.">    super(server, executor, scheduler, pool, acceptors, factories.length &gt; 0 ? factories</span>
<span class="nc" id="L151">        : new ConnectionFactory[] {new HttpConnectionFactory()});</span>
<span class="fc" id="L152">    this.server = server;</span>
<span class="fc" id="L153">    this.selectorManager = newSelectorManager(getExecutor(), getScheduler(), selectors);</span>
<span class="fc" id="L154">    addBean(selectorManager, true);</span>

<span class="fc" id="L156">    this.selectorManagerListenerClass = findSelectorManagerListenerClass();</span>
<span class="fc" id="L157">  }</span>

  @SuppressWarnings(&quot;unchecked&quot;)
  private static Class&lt;? extends EventListener&gt; findSelectorManagerListenerClass() {
    try {
<span class="fc" id="L162">      return (Class&lt;? extends EventListener&gt;) Class.forName(</span>
          &quot;org.eclipse.jetty.io.SelectorManager$SelectorManagerListener&quot;);
<span class="nc" id="L164">    } catch (ClassNotFoundException e) {</span>
<span class="nc" id="L165">      return null;</span>
    }
  }

  private SelectorManager newSelectorManager(Executor executor, Scheduler scheduler,
      int selectors) {
<span class="fc" id="L171">    return new AFSocketSelectorManager(executor, scheduler, selectors);</span>
  }

  /**
   * Returns the Unix-Domain path this connector listens to.
   *
   * Added for compatibility with jetty's {@code UnixDomainServerConnector}.
   *
   * @return The Unix-Domain path this connector listens to.
   * @deprecated Use {@link #getListenSocketAddress()} instead.
   * @see #getListenSocketAddress()
   */
  @ManagedAttribute(&quot;The Unix-Domain path this connector listens to&quot;)
  @Deprecated
  public Path getUnixDomainPath() {
<span class="nc bnc" id="L186" title="All 2 branches missed.">    if (listenSocketAddress instanceof AFUNIXSocketAddress) {</span>
<span class="nc" id="L187">      AFUNIXSocketAddress addr = (AFUNIXSocketAddress) listenSocketAddress;</span>
<span class="nc bnc" id="L188" title="All 2 branches missed.">      if (addr.hasFilename()) {</span>
        try {
<span class="nc" id="L190">          return addr.getFile().toPath();</span>
<span class="nc" id="L191">        } catch (FileNotFoundException e) {</span>
<span class="nc" id="L192">          return null;</span>
        }
      }
    }
<span class="nc" id="L196">    return null;</span>
  }

  /**
   * Sets the Unix-Domain path this connector listens to.
   *
   * Added for compatibility with jetty's {@code UnixDomainServerConnector}.
   *
   * @param unixDomainPath The path.
   * @deprecated Use {@link #setListenSocketAddress(AFSocketAddress)} instead.
   * @see #setListenSocketAddress(AFSocketAddress)
   */
  @Deprecated
  public void setUnixDomainPath(Path unixDomainPath) {
    try {
<span class="nc" id="L211">      this.listenSocketAddress = AFUNIXSocketAddress.of(unixDomainPath);</span>
<span class="nc" id="L212">    } catch (SocketException e) {</span>
<span class="nc" id="L213">      throw new IllegalStateException(e);</span>
<span class="nc" id="L214">    }</span>
<span class="nc" id="L215">  }</span>

  /**
   * Returns the socket address this connector listens to.
   *
   * @return The socket address, or {@code null} if none set.
   */
  @ManagedAttribute(&quot;The socket address this connector listens to&quot;)
  @SuppressFBWarnings(&quot;EI_EXPOSE_REP&quot;)
  public AFSocketAddress getListenSocketAddress() {
<span class="nc" id="L225">    return listenSocketAddress;</span>
  }

  /**
   * Sets the socket address this connector listens to.
   *
   * @param addr The socket address, or {@code null}.
   */
  @SuppressFBWarnings(&quot;EI_EXPOSE_REP2&quot;)
  public void setListenSocketAddress(AFSocketAddress addr) {
<span class="fc" id="L235">    this.listenSocketAddress = addr;</span>
<span class="fc" id="L236">  }</span>

  /**
   * Checks whether this connector uses a server channel inherited from the JVM.
   *
   * @return {@code true} if so.
   */
  @ManagedAttribute(&quot;Whether this connector uses a server channel inherited from the JVM&quot;)
  public boolean isInheritChannel() {
<span class="fc" id="L245">    return inheritChannel;</span>
  }

  /**
   * Sets whether this connector uses a server channel inherited from the JVM.
   *
   * @param inheritChannel {@code true} if so.
   */
  public void setInheritChannel(boolean inheritChannel) {
<span class="nc" id="L254">    this.inheritChannel = inheritChannel;</span>
<span class="nc" id="L255">  }</span>

  /**
   * Returns the accept queue size (backlog) for the server socket.
   *
   * @return The backlog.
   */
  @ManagedAttribute(&quot;The accept queue size (backlog) for the server socket&quot;)
  public int getAcceptQueueSize() {
<span class="fc" id="L264">    return acceptQueueSize;</span>
  }

  /**
   * Sets the accept queue size (backlog) for the server socket.
   *
   * @param acceptQueueSize The backlog.
   */
  public void setAcceptQueueSize(int acceptQueueSize) {
<span class="fc" id="L273">    this.acceptQueueSize = acceptQueueSize;</span>
<span class="fc" id="L274">  }</span>

  /**
   * Returns the SO_RCVBUF size for accepted sockets.
   *
   * @return The buffer size.
   */
  @ManagedAttribute(&quot;The SO_RCVBUF option for accepted sockets&quot;)
  public int getAcceptedReceiveBufferSize() {
<span class="fc" id="L283">    return acceptedReceiveBufferSize;</span>
  }

  /**
   * Sets the SO_RCVBUF size for accepted sockets.
   *
   * @param acceptedReceiveBufferSize The buffer size.
   */
  public void setAcceptedReceiveBufferSize(int acceptedReceiveBufferSize) {
<span class="nc" id="L292">    this.acceptedReceiveBufferSize = acceptedReceiveBufferSize;</span>
<span class="nc" id="L293">  }</span>

  /**
   * Returns the SO_SNDBUF size for accepted sockets.
   *
   * @return The buffer size.
   */
  @ManagedAttribute(&quot;The SO_SNDBUF option for accepted sockets&quot;)
  public int getAcceptedSendBufferSize() {
<span class="fc" id="L302">    return acceptedSendBufferSize;</span>
  }

  /**
   * Sets the SO_SNDBUF size for accepted sockets.
   *
   * @param acceptedSendBufferSize The buffer size.
   */
  public void setAcceptedSendBufferSize(int acceptedSendBufferSize) {
<span class="nc" id="L311">    this.acceptedSendBufferSize = acceptedSendBufferSize;</span>
<span class="nc" id="L312">  }</span>

  @Override
  protected void doStart() throws Exception {
<span class="pc bpc" id="L316" title="1 of 2 branches missed.">    if (selectorManagerListenerClass != null) {</span>
<span class="fc" id="L317">      getBeans(selectorManagerListenerClass).forEach(selectorManager::addEventListener);</span>
    }
<span class="fc" id="L319">    serverChannel = open();</span>
<span class="fc" id="L320">    addBean(serverChannel);</span>
<span class="fc" id="L321">    super.doStart();</span>
<span class="fc" id="L322">  }</span>

  @Override
  protected void doStop() throws Exception {
<span class="fc" id="L326">    super.doStop();</span>
<span class="fc" id="L327">    removeBean(serverChannel);</span>
<span class="fc" id="L328">    close();</span>
<span class="pc bpc" id="L329" title="1 of 2 branches missed.">    if (selectorManagerListenerClass != null) {</span>
<span class="fc" id="L330">      getBeans(selectorManagerListenerClass).forEach(selectorManager::removeEventListener);</span>
    }
<span class="fc" id="L332">  }</span>

  @Override
  @SuppressWarnings(&quot;PMD.CognitiveComplexity&quot;)
  protected void accept(int acceptorID) throws IOException {
<span class="fc" id="L337">    ServerSocketChannel sc = this.serverChannel;</span>
<span class="pc bpc" id="L338" title="1 of 2 branches missed.">    if (sc != null) {</span>
      try {
<span class="fc" id="L340">        SocketChannel channel = sc.accept();</span>
<span class="fc" id="L341">        accepted(channel);</span>
<span class="fc" id="L342">      } catch (IOException e) {</span>
<span class="pc bpc" id="L343" title="3 of 4 branches missed.">        boolean takenOver = !sc.isOpen() || sc.getLocalAddress() == null;</span>

<span class="pc bpc" id="L345" title="3 of 4 branches missed.">        if (!takenOver &amp;&amp; sc instanceof AFServerSocketChannel&lt;?&gt;) {</span>
<span class="nc bnc" id="L346" title="All 2 branches missed.">          takenOver = !((AFServerSocketChannel&lt;?&gt;) sc).isLocalSocketAddressValid();</span>
        }

<span class="pc bpc" id="L349" title="1 of 4 branches missed.">        if (takenOver &amp;&amp; isMayStopServer()) {</span>
<span class="fc" id="L350">          LOG.warn(&quot;Another server has taken over our address&quot;);</span>
<span class="fc" id="L351">          ForkJoinPool.commonPool().execute(this::checkServerStop);</span>
        }

<span class="fc" id="L354">        Thread.currentThread().interrupt();</span>
<span class="fc" id="L355">        throw (ClosedByInterruptException) new ClosedByInterruptException().initCause(e);</span>
<span class="fc" id="L356">      }</span>
    }
<span class="fc" id="L358">  }</span>

  private void checkServerStop() {
<span class="fc" id="L361">    Connector[] connectors = server.getConnectors();</span>

<span class="pc bpc" id="L363" title="2 of 4 branches missed.">    if (connectors != null &amp;&amp; !isMayStopServerForce()) {</span>
<span class="fc bfc" id="L364" title="All 2 branches covered.">      for (Connector conn : connectors) {</span>
<span class="pc bpc" id="L365" title="3 of 4 branches missed.">        if (conn != AFSocketServerConnector.this &amp;&amp; conn.isRunning()) { // NOPMD.CompareObjectsWithEquals</span>
<span class="nc" id="L366">          return; // don't stop</span>
        }
      }
    }

<span class="fc" id="L371">    LOG.warn(&quot;Server has no other connectors; shutting down: &quot; + server); // NOPMD</span>

    try {
<span class="fc" id="L374">      server.stop();</span>
<span class="nc" id="L375">    } catch (Exception e1) {</span>
<span class="nc" id="L376">      LOG.warn(&quot;Exception upon stopping &quot; + server, e1); // NOPMD</span>
<span class="fc" id="L377">    }</span>
<span class="fc" id="L378">  }</span>

  private void accepted(SocketChannel channel) throws IOException {
<span class="fc" id="L381">    channel.configureBlocking(false);</span>
<span class="fc" id="L382">    configure(channel);</span>
<span class="fc" id="L383">    selectorManager.accept(channel);</span>
<span class="fc" id="L384">  }</span>

  /**
   * Configures an incoming {@link SocketChannel}, setting socket options such as receive and send
   * buffer sizes.
   *
   * @param channel The socket channel to configure.
   * @throws IOException on error.
   */
  protected void configure(SocketChannel channel) throws IOException {
<span class="fc" id="L394">    channel.setOption(StandardSocketOptions.SO_REUSEADDR, true);</span>
<span class="fc" id="L395">    int rcvBufSize = getAcceptedReceiveBufferSize();</span>
<span class="pc bpc" id="L396" title="1 of 2 branches missed.">    if (rcvBufSize &gt; 0) {</span>
<span class="nc" id="L397">      channel.setOption(StandardSocketOptions.SO_RCVBUF, rcvBufSize);</span>
    }
<span class="fc" id="L399">    int sndBufSize = getAcceptedSendBufferSize();</span>
<span class="pc bpc" id="L400" title="1 of 2 branches missed.">    if (sndBufSize &gt; 0) {</span>
<span class="nc" id="L401">      channel.setOption(StandardSocketOptions.SO_SNDBUF, sndBufSize);</span>
    }
<span class="fc" id="L403">  }</span>

  @Override
  @SuppressFBWarnings(&quot;EI_EXPOSE_REP&quot;)
  public Object getTransport() {
<span class="nc" id="L408">    return serverChannel;</span>
  }

  private ServerSocketChannel open() throws IOException {
<span class="fc" id="L412">    ServerSocketChannel sc = openServerSocketChannel();</span>
<span class="pc bpc" id="L413" title="1 of 2 branches missed.">    if (getAcceptors() == 0) {</span>
<span class="nc" id="L414">      sc.configureBlocking(false);</span>
<span class="nc" id="L415">      acceptor.set(selectorManager.acceptor(sc));</span>
    }
<span class="fc" id="L417">    return sc;</span>
  }

  private void close() throws IOException {
<span class="fc" id="L421">    ServerSocketChannel sc = this.serverChannel;</span>
<span class="fc" id="L422">    this.serverChannel = null;</span>
<span class="fc" id="L423">    IO.close(sc);</span>
<span class="fc" id="L424">  }</span>

  private ServerSocketChannel openServerSocketChannel() throws IOException {
<span class="fc" id="L427">    ServerSocketChannel sc = null;</span>
<span class="pc bpc" id="L428" title="1 of 2 branches missed.">    if (isInheritChannel()) {</span>
<span class="nc" id="L429">      Channel channel = System.inheritedChannel();</span>
<span class="nc bnc" id="L430" title="All 2 branches missed.">      if (channel instanceof ServerSocketChannel) {</span>
<span class="nc" id="L431">        sc = (ServerSocketChannel) channel;</span>
      } else {
<span class="nc" id="L433">        LOG.warn( // NOPMD.GuardLogStatement</span>
            &quot;Unable to use System.inheritedChannel() {}. Trying a new ServerSocketChannel at {}&quot;,
<span class="nc" id="L435">            channel, getListenSocketAddress());</span>
      }
    }
<span class="pc bpc" id="L438" title="1 of 2 branches missed.">    if (sc == null) {</span>
<span class="fc" id="L439">      sc = bindServerSocketChannel();</span>
    }
<span class="fc" id="L441">    return sc;</span>
  }

  private ServerSocketChannel bindServerSocketChannel() throws IOException {
<span class="fc" id="L445">    AFSocketAddress socketAddress = listenSocketAddress;</span>
<span class="fc" id="L446">    AFServerSocketChannel&lt;?&gt; sc = socketAddress.getAddressFamily().newServerSocketChannel();</span>

    try {
<span class="fc" id="L449">      sc.bind(socketAddress, getAcceptQueueSize());</span>
<span class="fc" id="L450">      return sc;</span>
<span class="fc" id="L451">    } catch (IOException x) {</span>
<span class="fc" id="L452">      String message = String.format(Locale.ENGLISH, &quot;Could not bind %s to %s&quot;,</span>
<span class="fc" id="L453">          AFSocketServerConnector.class.getSimpleName(), listenSocketAddress);</span>
<span class="fc" id="L454">      throw new IOException(message, x);</span>
    }
  }

  @Override
  public void setAccepting(boolean accepting) {
<span class="nc" id="L460">    super.setAccepting(accepting);</span>
<span class="nc bnc" id="L461" title="All 2 branches missed.">    if (getAcceptors() == 0) {</span>
<span class="nc" id="L462">      return;</span>
    }
<span class="nc bnc" id="L464" title="All 2 branches missed.">    if (accepting) {</span>
<span class="nc bnc" id="L465" title="All 2 branches missed.">      if (acceptor.get() == null) {</span>
<span class="nc" id="L466">        Closeable cl = selectorManager.acceptor(serverChannel);</span>
<span class="nc bnc" id="L467" title="All 2 branches missed.">        if (!this.acceptor.compareAndSet(null, cl)) {</span>
<span class="nc" id="L468">          IO.close(cl);</span>
        }
<span class="nc" id="L470">      }</span>
    } else {
<span class="nc" id="L472">      Closeable cl = this.acceptor.get();</span>
<span class="nc bnc" id="L473" title="All 4 branches missed.">      if (cl != null &amp;&amp; this.acceptor.compareAndSet(cl, null)) {</span>
<span class="nc" id="L474">        IO.close(cl);</span>
      }
    }
<span class="nc" id="L477">  }</span>

  @Override
  public String toString() {
<span class="fc" id="L481">    return String.format(Locale.ENGLISH, &quot;%s@%h[%s]&quot;, getClass().getSimpleName(), hashCode(),</span>
        listenSocketAddress);
  }

  private final class AFSocketSelectorManager extends SelectorManager {
<span class="fc" id="L486">    public AFSocketSelectorManager(Executor executor, Scheduler scheduler, int selectors) {</span>
<span class="fc" id="L487">      super(executor, scheduler, selectors);</span>
<span class="fc" id="L488">    }</span>

    @Override
    protected Selector newSelector() throws IOException {
<span class="fc" id="L492">      SelectorProvider provider = listenSocketAddress.getAddressFamily().getSelectorProvider();</span>
<span class="fc" id="L493">      return provider.openSelector();</span>
    }

    @Override
    protected void accepted(SelectableChannel channel) throws IOException {
<span class="nc" id="L498">      AFSocketServerConnector.this.accepted((SocketChannel) channel);</span>
<span class="nc" id="L499">    }</span>

    @Override
    protected EndPoint newEndPoint(SelectableChannel channel, ManagedSelector selector,
        SelectionKey selectionKey) {
<span class="fc" id="L504">      SocketChannelEndPoint endPoint = new SocketChannelEndPoint((SocketChannel) channel, selector,</span>
<span class="fc" id="L505">          selectionKey, getScheduler());</span>
<span class="fc" id="L506">      endPoint.setIdleTimeout(getIdleTimeout());</span>
<span class="fc" id="L507">      return endPoint;</span>
    }

    @Override
    public Connection newConnection(SelectableChannel channel, EndPoint endpoint,
        Object attachment) {
<span class="fc" id="L513">      return getDefaultConnectionFactory().newConnection(AFSocketServerConnector.this, endpoint);</span>
    }

    @Override
    protected void endPointOpened(EndPoint endpoint) {
<span class="fc" id="L518">      super.endPointOpened(endpoint);</span>
<span class="fc" id="L519">      onEndPointOpened(endpoint);</span>
<span class="fc" id="L520">    }</span>

    @Override
    protected void endPointClosed(EndPoint endpoint) {
<span class="fc" id="L524">      onEndPointClosed(endpoint);</span>
<span class="fc" id="L525">      super.endPointClosed(endpoint);</span>
<span class="fc" id="L526">    }</span>
  }

  /**
   * Checks if this connector may stop the server when it's no longer able to serve and no other
   * connectors are available.
   *
   * @return {@code true} if so.
   */
  @ManagedAttribute(&quot;Whether this connector may stop the server when it's no longer able to&quot;
      + &quot; serve and no other connectors are available&quot;)
  public boolean isMayStopServer() {
<span class="fc" id="L538">    return mayStopServer;</span>
  }

  /**
   * Sets if this connector may stop the server when it's no longer able to serve and no other
   * connectors are available.
   *
   * @param mayStopServer {@code true} if so.
   */
  public void setMayStopServer(boolean mayStopServer) {
<span class="fc" id="L548">    this.mayStopServer = mayStopServer;</span>
<span class="fc" id="L549">  }</span>

  /**
   * Checks if this connector may stop the server when it's no longer able to serve, even if other
   * connectors are available.
   *
   * @return {@code true} if so.
   */
  @ManagedAttribute(&quot;Whether this connector may stop the server when it's no longer able to&quot;
      + &quot; serve, even if other connectors are available&quot;)
  public boolean isMayStopServerForce() {
<span class="fc" id="L560">    return mayStopServerForce;</span>
  }

  /**
   * Sets if this connector may stop the server when it's no longer able to serve and no other
   * connectors are available.
   *
   * @param b {@code true} if so (which then also implies {@code setMayStopServer(true)}
   */
  public void setMayStopServerForce(boolean b) {
<span class="nc bnc" id="L570" title="All 2 branches missed.">    if (b) {</span>
<span class="nc" id="L571">      setMayStopServer(true);</span>
    }
<span class="nc" id="L573">    this.mayStopServerForce = b;</span>
<span class="nc" id="L574">  }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>